{
  "version": 3,
  "sources": ["../../iota-array/iota.js", "../../is-buffer/index.js", "../../ndarray/ndarray.js", "../../uniq/uniq.js", "../../cwise-compiler/lib/compile.js", "../../cwise-compiler/lib/thunk.js", "../../cwise-compiler/compiler.js", "../../ndarray-ops/ndarray-ops.js", "../../ndarray-pixels/src/browser-get-pixels.ts", "../../ndarray-pixels/src/common.ts", "../../ndarray-pixels/src/browser-save-pixels.ts", "../../ndarray-pixels/src/index.ts", "../../ktx-parse/src/constants.ts", "../../ktx-parse/src/container.ts", "../../ktx-parse/src/buffer-reader.ts", "../../ktx-parse/src/constants-internal.ts", "../../ktx-parse/src/util.ts", "../../ktx-parse/src/read.ts", "../../ktx-parse/src/write.ts", "../../@gltf-transform/extensions/src/constants.ts", "../../@gltf-transform/extensions/src/ext-mesh-gpu-instancing/instanced-mesh.ts", "../../@gltf-transform/extensions/src/ext-mesh-gpu-instancing/mesh-gpu-instancing.ts", "../../@gltf-transform/extensions/src/ext-meshopt-compression/constants.ts", "../../@gltf-transform/extensions/src/ext-meshopt-compression/encoder.ts", "../../@gltf-transform/extensions/src/ext-meshopt-compression/decoder.ts", "../../@gltf-transform/extensions/src/ext-meshopt-compression/meshopt-compression.ts", "../../@gltf-transform/extensions/src/ext-texture-avif/texture-avif.ts", "../../@gltf-transform/extensions/src/ext-texture-webp/texture-webp.ts", "../../@gltf-transform/extensions/src/khr-draco-mesh-compression/decoder.ts", "../../@gltf-transform/extensions/src/khr-draco-mesh-compression/encoder.ts", "../../@gltf-transform/extensions/src/khr-draco-mesh-compression/draco-mesh-compression.ts", "../../@gltf-transform/extensions/src/khr-lights-punctual/light.ts", "../../@gltf-transform/extensions/src/khr-lights-punctual/lights-punctual.ts", "../../@gltf-transform/extensions/src/khr-materials-anisotropy/anisotropy.ts", "../../@gltf-transform/extensions/src/khr-materials-anisotropy/materials-anisotropy.ts", "../../@gltf-transform/extensions/src/khr-materials-clearcoat/clearcoat.ts", "../../@gltf-transform/extensions/src/khr-materials-clearcoat/materials-clearcoat.ts", "../../@gltf-transform/extensions/src/khr-materials-diffuse-transmission/diffuse-transmission.ts", "../../@gltf-transform/extensions/src/khr-materials-diffuse-transmission/materials-diffuse-transmission.ts", "../../@gltf-transform/extensions/src/khr-materials-dispersion/dispersion.ts", "../../@gltf-transform/extensions/src/khr-materials-dispersion/materials-dispersion.ts", "../../@gltf-transform/extensions/src/khr-materials-emissive-strength/emissive-strength.ts", "../../@gltf-transform/extensions/src/khr-materials-emissive-strength/materials-emissive-strength.ts", "../../@gltf-transform/extensions/src/khr-materials-ior/ior.ts", "../../@gltf-transform/extensions/src/khr-materials-ior/materials-ior.ts", "../../@gltf-transform/extensions/src/khr-materials-iridescence/iridescence.ts", "../../@gltf-transform/extensions/src/khr-materials-iridescence/materials-iridescence.ts", "../../@gltf-transform/extensions/src/khr-materials-pbr-specular-glossiness/pbr-specular-glossiness.ts", "../../@gltf-transform/extensions/src/khr-materials-pbr-specular-glossiness/materials-pbr-specular-glossiness.ts", "../../@gltf-transform/extensions/src/khr-materials-sheen/sheen.ts", "../../@gltf-transform/extensions/src/khr-materials-sheen/materials-sheen.ts", "../../@gltf-transform/extensions/src/khr-materials-specular/specular.ts", "../../@gltf-transform/extensions/src/khr-materials-specular/materials-specular.ts", "../../@gltf-transform/extensions/src/khr-materials-transmission/transmission.ts", "../../@gltf-transform/extensions/src/khr-materials-transmission/materials-transmission.ts", "../../@gltf-transform/extensions/src/khr-materials-unlit/unlit.ts", "../../@gltf-transform/extensions/src/khr-materials-unlit/materials-unlit.ts", "../../@gltf-transform/extensions/src/khr-materials-variants/mapping.ts", "../../@gltf-transform/extensions/src/khr-materials-variants/mapping-list.ts", "../../@gltf-transform/extensions/src/khr-materials-variants/variant.ts", "../../@gltf-transform/extensions/src/khr-materials-variants/materials-variants.ts", "../../@gltf-transform/extensions/src/khr-materials-volume/volume.ts", "../../@gltf-transform/extensions/src/khr-materials-volume/materials-volume.ts", "../../@gltf-transform/extensions/src/khr-mesh-quantization/mesh-quantization.ts", "../../@gltf-transform/extensions/src/khr-texture-basisu/texture-basisu.ts", "../../@gltf-transform/extensions/src/khr-texture-transform/transform.ts", "../../@gltf-transform/extensions/src/khr-texture-transform/texture-transform.ts", "../../@gltf-transform/extensions/src/khr-xmp-json-ld/packet.ts", "../../@gltf-transform/extensions/src/khr-xmp-json-ld/xmp.ts", "../../@gltf-transform/extensions/src/index.ts", "../../ndarray-lanczos/vendor/filters.ts", "../../ndarray-lanczos/src/convolve.ts", "../../ndarray-lanczos/src/index.ts", "../../@gltf-transform/functions/src/utils.ts", "../../@gltf-transform/functions/src/center.ts", "../../@gltf-transform/functions/src/list-node-scenes.ts", "../../@gltf-transform/functions/src/clear-node-parent.ts", "../../node_modules/gl-matrix/esm/common.js", "../../node_modules/gl-matrix/esm/mat4.js", "../../node_modules/gl-matrix/esm/mat3.js", "../../node_modules/gl-matrix/esm/vec3.js", "../../@gltf-transform/functions/src/dedup.ts", "../../node_modules/gl-matrix/esm/vec4.js", "../../@gltf-transform/functions/src/get-texture-color-space.ts", "../../@gltf-transform/functions/src/list-texture-info.ts", "../../@gltf-transform/functions/src/list-texture-slots.ts", "../../@gltf-transform/functions/src/prune.ts", "../../@gltf-transform/functions/src/hash-table.ts", "../../@gltf-transform/functions/src/get-vertex-count.ts", "../../@gltf-transform/functions/src/compact-primitive.ts", "../../@gltf-transform/functions/src/weld.ts", "../../@gltf-transform/functions/src/transform-primitive.ts", "../../@gltf-transform/functions/src/transform-mesh.ts", "../../@gltf-transform/functions/src/clear-node-transform.ts", "../../@gltf-transform/functions/src/convert-primitive-mode.ts", "../../@gltf-transform/functions/src/dequantize.ts", "../../@gltf-transform/functions/src/document-utils.ts", "../../@gltf-transform/functions/src/draco.ts", "../../@gltf-transform/functions/src/flatten.ts", "../../@gltf-transform/functions/src/get-bounds.ts", "../../@gltf-transform/functions/src/inspect.ts", "../../@gltf-transform/functions/src/instance.ts", "../../@gltf-transform/functions/src/join-primitives.ts", "../../@gltf-transform/functions/src/join.ts", "../../@gltf-transform/functions/src/list-texture-channels.ts", "../../@gltf-transform/functions/src/reorder.ts", "../../@gltf-transform/functions/src/sort-primitive-weights.ts", "../../@gltf-transform/functions/src/quantize.ts", "../../@gltf-transform/functions/src/meshopt.ts", "../../@gltf-transform/functions/src/metal-rough.ts", "../../@gltf-transform/functions/src/unweld.ts", "../../@gltf-transform/functions/src/normals.ts", "../../@gltf-transform/functions/src/palette.ts", "../../@gltf-transform/functions/src/partition.ts", "../../node_modules/keyframe-resample/dist/keyframe-resample-browser.modern.js", "../../@gltf-transform/functions/src/resample.ts", "../../@gltf-transform/functions/src/sequence.ts", "../../@gltf-transform/functions/src/simplify.ts", "../../@gltf-transform/functions/src/sparse.ts", "../../@gltf-transform/functions/src/texture-compress.ts", "../../@gltf-transform/functions/src/tangents.ts", "../../@gltf-transform/functions/src/unlit.ts", "../../@gltf-transform/functions/src/unpartition.ts", "../../@gltf-transform/functions/src/vertex-color-space.ts"],
  "sourcesContent": ["\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n", "var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n", "\"use strict\"\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n", "\"use strict\"\n\nvar uniq = require(\"uniq\")\n\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , has_index = proc.indexArgs.length>0\n    , code = []\n    , vars = []\n    , idx=0, pidx=0, i, j\n  for(i=0; i<dimension; ++i) { // Iteration variables\n    vars.push([\"i\",i,\"=0\"].join(\"\"))\n  }\n  //Compute scan deltas\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx\n      idx = order[i]\n      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride\n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"))\n      } else { // For other dimensions the delta is basically the stride minus something which essentially \"rewinds\" the previous (more inner) dimension\n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"))\n      }\n    }\n  }\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }  \n  //Scan loop\n  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards\n    idx = order[i]\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"))\n  }\n  //Push body of inner loop\n  code.push(body)\n  //Advance scan pointers\n  for(i=0; i<dimension; ++i) {\n    pidx = idx\n    idx = order[i]\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"))\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"))\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"))\n    }\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n  var dimension = order.length\n    , nargs = proc.arrayArgs.length\n    , blockSize = proc.blockSize\n    , has_index = proc.indexArgs.length > 0\n    , code = []\n  for(var i=0; i<nargs; ++i) {\n    code.push([\"var offset\",i,\"=p\",i].join(\"\"))\n  }\n  //Generate loops for unmatched dimensions\n  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n  // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n  for(var i=matched; i<dimension; ++i) {\n    code.push([\"for(var j\"+i+\"=SS[\", order[i], \"]|0;j\", i, \">0;){\"].join(\"\")) // Iterate back to front\n    code.push([\"if(j\",i,\"<\",blockSize,\"){\"].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n    code.push([\"s\",order[i],\"=j\",i].join(\"\"))\n    code.push([\"j\",i,\"=0\"].join(\"\"))\n    code.push([\"}else{s\",order[i],\"=\",blockSize].join(\"\"))\n    code.push([\"j\",i,\"-=\",blockSize,\"}\"].join(\"\"))\n    if(has_index) {\n      code.push([\"index[\",order[i],\"]=j\",i].join(\"\"))\n    }\n  }\n  for(var i=0; i<nargs; ++i) {\n    var indexStr = [\"offset\"+i]\n    for(var j=matched; j<dimension; ++j) {\n      indexStr.push([\"j\",j,\"*t\",i,\"p\",order[j]].join(\"\"))\n    }\n    code.push([\"p\",i,\"=(\",indexStr.join(\"+\"),\")\"].join(\"\"))\n  }\n  code.push(innerFill(order, proc, body))\n  for(var i=matched; i<dimension; ++i) {\n    code.push(\"}\")\n  }\n  return code.join(\"\\n\")\n}\n\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n  var matched = 0, dimension = orders[0].length\n  while(matched < dimension) {\n    for(var j=1; j<orders.length; ++j) {\n      if(orders[j][matched] !== orders[0][matched]) {\n        return matched\n      }\n    }\n    ++matched\n  }\n  return matched\n}\n\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n  var code = block.body\n  var pre = []\n  var post = []\n  for(var i=0; i<block.args.length; ++i) {\n    var carg = block.args[i]\n    if(carg.count <= 0) {\n      continue\n    }\n    var re = new RegExp(carg.name, \"g\")\n    var ptrStr = \"\"\n    var arrNum = proc.arrayArgs.indexOf(i)\n    switch(proc.argTypes[i]) {\n      case \"offset\":\n        var offArgIndex = proc.offsetArgIndex.indexOf(i)\n        var offArg = proc.offsetArgs[offArgIndex]\n        arrNum = offArg.array\n        ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n      case \"array\":\n        ptrStr = \"p\" + arrNum + ptrStr\n        var localStr = \"l\" + i\n        var arrStr = \"a\" + arrNum\n        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array\n          if(carg.count === 1) { // Argument/array used only once(?)\n            if(dtypes[arrNum] === \"generic\") {\n              if(carg.lvalue) {\n                pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                code = code.replace(re, localStr)\n                post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n              } else {\n                code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n              }\n            } else {\n              code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n            }\n          } else if(dtypes[arrNum] === \"generic\") {\n            pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            }\n          } else {\n            pre.push([\"var \", localStr, \"=\", arrStr, \"[\", ptrStr, \"]\"].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n            code = code.replace(re, localStr)\n            if(carg.lvalue) {\n              post.push([arrStr, \"[\", ptrStr, \"]=\", localStr].join(\"\"))\n            }\n          }\n        } else { // Argument to body is a \"block\"\n          var reStrArr = [carg.name], ptrStrArr = [ptrStr]\n          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {\n            reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\")\n            ptrStrArr.push(\"$\" + (j+1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n          }\n          re = new RegExp(reStrArr.join(\"\"), \"g\")\n          ptrStr = ptrStrArr.join(\"+\")\n          if(dtypes[arrNum] === \"generic\") {\n            /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/\n            throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\")\n          } else {\n            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n            code = code.replace(re, [arrStr, \"[\", ptrStr, \"]\"].join(\"\"))\n          }\n        }\n      break\n      case \"scalar\":\n        code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i))\n      break\n      case \"index\":\n        code = code.replace(re, \"index\")\n      break\n      case \"shape\":\n        code = code.replace(re, \"shape\")\n      break\n    }\n  }\n  return [pre.join(\"\\n\"), code, post.join(\"\\n\")].join(\"\\n\").trim()\n}\n\nfunction typeSummary(dtypes) {\n  var summary = new Array(dtypes.length)\n  var allEqual = true\n  for(var i=0; i<dtypes.length; ++i) {\n    var t = dtypes[i]\n    var digits = t.match(/\\d+/)\n    if(!digits) {\n      digits = \"\"\n    } else {\n      digits = digits[0]\n    }\n    if(t.charAt(0) === 0) {\n      summary[i] = \"u\" + t.charAt(1) + digits\n    } else {\n      summary[i] = t.charAt(0) + digits\n    }\n    if(i > 0) {\n      allEqual = allEqual && summary[i] === summary[i-1]\n    }\n  }\n  if(allEqual) {\n    return summary[0]\n  }\n  return summary.join(\"\")\n}\n\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n\n  //Compute dimension\n  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0\n  var orders = new Array(proc.arrayArgs.length)\n  var dtypes = new Array(proc.arrayArgs.length)\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    dtypes[i] = typesig[2*i]\n    orders[i] = typesig[2*i+1]\n  }\n  \n  //Determine where block and loop indices start and end\n  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n  var loopBegin = [], loopEnd = [] // These indices are iterated over\n  var loopOrders = [] // orders restricted to the loop indices\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    if (proc.arrayBlockIndices[i]<0) {\n      loopBegin.push(0)\n      loopEnd.push(dimension)\n      blockBegin.push(dimension)\n      blockEnd.push(dimension+proc.arrayBlockIndices[i])\n    } else {\n      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n      loopEnd.push(proc.arrayBlockIndices[i]+dimension)\n      blockBegin.push(0)\n      blockEnd.push(proc.arrayBlockIndices[i])\n    }\n    var newOrder = []\n    for(var j=0; j<orders[i].length; j++) {\n      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {\n        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n      }\n    }\n    loopOrders.push(newOrder)\n  }\n\n  //First create arguments for procedure\n  var arglist = [\"SS\"] // SS is the overall shape over which we iterate\n  var code = [\"'use strict'\"]\n  var vars = []\n  \n  for(var j=0; j<dimension; ++j) {\n    vars.push([\"s\", j, \"=SS[\", j, \"]\"].join(\"\")) // The limits for each dimension.\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    arglist.push(\"a\"+i) // Actual data array\n    arglist.push(\"t\"+i) // Strides\n    arglist.push(\"p\"+i) // Offset in the array at which the data starts (also used for iterating over the data)\n    \n    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping\n      vars.push([\"t\",i,\"p\",j,\"=t\",i,\"[\",loopBegin[i]+j,\"]\"].join(\"\"))\n    }\n    \n    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration\n      vars.push([\"t\",i,\"b\",j,\"=t\",i,\"[\",blockBegin[i]+j,\"]\"].join(\"\"))\n    }\n  }\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    arglist.push(\"Y\" + i)\n  }\n  if(proc.shapeArgs.length > 0) {\n    vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n  }\n  if(proc.indexArgs.length > 0) {\n    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n    var zeros = new Array(dimension)\n    for(var i=0; i<dimension; ++i) {\n      zeros[i] = \"0\"\n    }\n    vars.push([\"index=[\", zeros.join(\",\"), \"]\"].join(\"\"))\n  }\n  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations\n    var off_arg = proc.offsetArgs[i]\n    var init_string = []\n    for(var j=0; j<off_arg.offset.length; ++j) {\n      if(off_arg.offset[j] === 0) {\n        continue\n      } else if(off_arg.offset[j] === 1) {\n        init_string.push([\"t\", off_arg.array, \"p\", j].join(\"\"))      \n      } else {\n        init_string.push([off_arg.offset[j], \"*t\", off_arg.array, \"p\", j].join(\"\"))\n      }\n    }\n    if(init_string.length === 0) {\n      vars.push(\"q\" + i + \"=0\")\n    } else {\n      vars.push([\"q\", i, \"=\", init_string.join(\"+\")].join(\"\"))\n    }\n  }\n\n  //Prepare this variables\n  var thisVars = uniq([].concat(proc.pre.thisVars)\n                      .concat(proc.body.thisVars)\n                      .concat(proc.post.thisVars))\n  vars = vars.concat(thisVars)\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"))\n  }\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    code.push(\"p\"+i+\"|=0\")\n  }\n  \n  //Inline prelude\n  if(proc.pre.body.length > 3) {\n    code.push(processBlock(proc.pre, proc, dtypes))\n  }\n\n  //Process body\n  var body = processBlock(proc.body, proc, dtypes)\n  var matched = countMatches(loopOrders)\n  if(matched < dimension) {\n    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n  } else {\n    code.push(innerFill(loopOrders[0], proc, body))\n  }\n\n  //Inline epilog\n  if(proc.post.body.length > 3) {\n    code.push(processBlock(proc.post, proc, dtypes))\n  }\n  \n  if(proc.debug) {\n    console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  var loopName = [(proc.funcName||\"unnamed\"), \"_cwise_loop_\", orders[0].join(\"s\"),\"m\",matched,typeSummary(dtypes)].join(\"\")\n  var f = new Function([\"function \",loopName,\"(\", arglist.join(\",\"),\"){\", code.join(\"\\n\"),\"} return \", loopName].join(\"\"))\n  return f()\n}\nmodule.exports = generateCWiseOp\n", "\"use strict\"\n\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\n\nvar compile = require(\"./compile.js\")\n\nfunction createThunk(proc) {\n  var code = [\"'use strict'\", \"var CACHED={}\"]\n  var vars = []\n  var thunkName = proc.funcName + \"_cwise_thunk\"\n  \n  //Build thunk\n  code.push([\"return function \", thunkName, \"(\", proc.shimArgs.join(\",\"), \"){\"].join(\"\"))\n  var typesig = []\n  var string_typesig = []\n  var proc_args = [[\"array\",proc.arrayArgs[0],\".shape.slice(\", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).\n                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(\",\"+proc.arrayBlockIndices[0]+\")\"):\")\"].join(\"\")]\n  var shapeLengthConditions = [], shapeConditions = []\n  // Process array arguments\n  for(var i=0; i<proc.arrayArgs.length; ++i) {\n    var j = proc.arrayArgs[i]\n    vars.push([\"t\", j, \"=array\", j, \".dtype,\",\n               \"r\", j, \"=array\", j, \".order\"].join(\"\"))\n    typesig.push(\"t\" + j)\n    typesig.push(\"r\" + j)\n    string_typesig.push(\"t\"+j)\n    string_typesig.push(\"r\"+j+\".join()\")\n    proc_args.push(\"array\" + j + \".data\")\n    proc_args.push(\"array\" + j + \".stride\")\n    proc_args.push(\"array\" + j + \".offset|0\")\n    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)\n      shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))\n      shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0,proc.arrayBlockIndices[i]) + \"]\")\n    }\n  }\n  // Check for shape equality\n  if (proc.arrayArgs.length > 1) {\n    code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\")\n    code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\")\n    code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\")\n    code.push(\"}\")\n  }\n  // Process scalar arguments\n  for(var i=0; i<proc.scalarArgs.length; ++i) {\n    proc_args.push(\"scalar\" + proc.scalarArgs[i])\n  }\n  // Check for cached function (and if not present, generate it)\n  vars.push([\"type=[\", string_typesig.join(\",\"), \"].join()\"].join(\"\"))\n  vars.push(\"proc=CACHED[type]\")\n  code.push(\"var \" + vars.join(\",\"))\n  \n  code.push([\"if(!proc){\",\n             \"CACHED[type]=proc=compile([\", typesig.join(\",\"), \"])}\",\n             \"return proc(\", proc_args.join(\",\"), \")}\"].join(\"\"))\n\n  if(proc.debug) {\n    console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\")\n  }\n  \n  //Compile thunk\n  var thunk = new Function(\"compile\", code.join(\"\\n\"))\n  return thunk(compile.bind(undefined, proc))\n}\n\nmodule.exports = createThunk\n", "\"use strict\"\n\nvar createThunk = require(\"./lib/thunk.js\")\n\nfunction Procedure() {\n  this.argTypes = []\n  this.shimArgs = []\n  this.arrayArgs = []\n  this.arrayBlockIndices = []\n  this.scalarArgs = []\n  this.offsetArgs = []\n  this.offsetArgIndex = []\n  this.indexArgs = []\n  this.shapeArgs = []\n  this.funcName = \"\"\n  this.pre = null\n  this.body = null\n  this.post = null\n  this.debug = false\n}\n\nfunction compileCwise(user_args) {\n  //Create procedure\n  var proc = new Procedure()\n  \n  //Parse blocks\n  proc.pre    = user_args.pre\n  proc.body   = user_args.body\n  proc.post   = user_args.post\n\n  //Parse arguments\n  var proc_args = user_args.args.slice(0)\n  proc.argTypes = proc_args\n  for(var i=0; i<proc_args.length; ++i) {\n    var arg_type = proc_args[i]\n    if(arg_type === \"array\" || (typeof arg_type === \"object\" && arg_type.blockIndices)) {\n      proc.argTypes[i] = \"array\"\n      proc.arrayArgs.push(i)\n      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)\n      proc.shimArgs.push(\"array\" + i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {\n        throw new Error(\"cwise: pre() block may not reference array args\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count>0) {\n        throw new Error(\"cwise: post() block may not reference array args\")\n      }\n    } else if(arg_type === \"scalar\") {\n      proc.scalarArgs.push(i)\n      proc.shimArgs.push(\"scalar\" + i)\n    } else if(arg_type === \"index\") {\n      proc.indexArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n        throw new Error(\"cwise: pre() block may not reference array index\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array index\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].count > 0) {\n        throw new Error(\"cwise: post() block may not reference array index\")\n      }\n    } else if(arg_type === \"shape\") {\n      proc.shapeArgs.push(i)\n      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n        throw new Error(\"cwise: pre() block may not write to array shape\")\n      }\n      if(i < proc.body.args.length && proc.body.args[i].lvalue) {\n        throw new Error(\"cwise: body() block may not write to array shape\")\n      }\n      if(i < proc.post.args.length && proc.post.args[i].lvalue) {\n        throw new Error(\"cwise: post() block may not write to array shape\")\n      }\n    } else if(typeof arg_type === \"object\" && arg_type.offset) {\n      proc.argTypes[i] = \"offset\"\n      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })\n      proc.offsetArgIndex.push(i)\n    } else {\n      throw new Error(\"cwise: Unknown argument type \" + proc_args[i])\n    }\n  }\n  \n  //Make sure at least one array argument was specified\n  if(proc.arrayArgs.length <= 0) {\n    throw new Error(\"cwise: No array arguments specified\")\n  }\n  \n  //Make sure arguments are correct\n  if(proc.pre.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in pre() block\")\n  }\n  if(proc.body.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in body() block\")\n  }\n  if(proc.post.args.length > proc_args.length) {\n    throw new Error(\"cwise: Too many arguments in post() block\")\n  }\n\n  //Check debug flag\n  proc.debug = !!user_args.printCode || !!user_args.debug\n  \n  //Retrieve name\n  proc.funcName = user_args.funcName || \"cwise\"\n  \n  //Read in block size\n  proc.blockSize = user_args.blockSize || 64\n\n  return createThunk(proc)\n}\n\nmodule.exports = compileCwise\n", "\"use strict\"\n\nvar compile = require(\"cwise-compiler\")\n\nvar EmptyProc = {\n  body: \"\",\n  args: [],\n  thisVars: [],\n  localVars: []\n}\n\nfunction fixup(x) {\n  if(!x) {\n    return EmptyProc\n  }\n  for(var i=0; i<x.args.length; ++i) {\n    var a = x.args[i]\n    if(i === 0) {\n      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }\n    } else {\n      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}\n    }\n  }\n  if(!x.thisVars) {\n    x.thisVars = []\n  }\n  if(!x.localVars) {\n    x.localVars = []\n  }\n  return x\n}\n\nfunction pcompile(user_args) {\n  return compile({\n    args:     user_args.args,\n    pre:      fixup(user_args.pre),\n    body:     fixup(user_args.body),\n    post:     fixup(user_args.proc),\n    funcName: user_args.funcName\n  })\n}\n\nfunction makeOp(user_args) {\n  var args = []\n  for(var i=0; i<user_args.args.length; ++i) {\n    args.push(\"a\"+i)\n  }\n  var wrapper = new Function(\"P\", [\n    \"return function \", user_args.funcName, \"_ndarrayops(\", args.join(\",\"), \") {P(\", args.join(\",\"), \");return a0}\"\n  ].join(\"\"))\n  return wrapper(pcompile(user_args))\n}\n\nvar assign_ops = {\n  add:  \"+\",\n  sub:  \"-\",\n  mul:  \"*\",\n  div:  \"/\",\n  mod:  \"%\",\n  band: \"&\",\n  bor:  \"|\",\n  bxor: \"^\",\n  lshift: \"<<\",\n  rshift: \">>\",\n  rrshift: \">>>\"\n}\n;(function(){\n  for(var id in assign_ops) {\n    var op = assign_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\",\"b\",\"c\"],\n             body: \"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\",\"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a\"+op+\"=b\"},\n      rvalue: true,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\", \"array\", \"scalar\"],\n      body: {args:[\"a\",\"b\",\"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\",\"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a\"+op+\"=s\"},\n      rvalue: true,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar unary_ops = {\n  not: \"!\",\n  bnot: \"~\",\n  neg: \"-\",\n  recip: \"1.0/\"\n}\n;(function(){\n  for(var id in unary_ops) {\n    var op = unary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\",\"b\"],\n             body:\"a=\"+op+\"b\"},\n      funcName: id\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\"],\n      body: {args:[\"a\"],\n             body:\"a=\"+op+\"a\"},\n      rvalue: true,\n      count: 2,\n      funcName: id+\"eq\"\n    })\n  }\n})();\n\nvar binary_ops = {\n  and: \"&&\",\n  or: \"||\",\n  eq: \"===\",\n  neq: \"!==\",\n  lt: \"<\",\n  gt: \">\",\n  leq: \"<=\",\n  geq: \">=\"\n}\n;(function() {\n  for(var id in binary_ops) {\n    var op = binary_ops[id]\n    exports[id] = makeOp({\n      args: [\"array\",\"array\",\"array\"],\n      body: {args:[\"a\", \"b\", \"c\"],\n             body:\"a=b\"+op+\"c\"},\n      funcName: id\n    })\n    exports[id+\"s\"] = makeOp({\n      args: [\"array\",\"array\",\"scalar\"],\n      body: {args:[\"a\", \"b\", \"s\"],\n             body:\"a=b\"+op+\"s\"},\n      funcName: id+\"s\"\n    })\n    exports[id+\"eq\"] = makeOp({\n      args: [\"array\", \"array\"],\n      body: {args:[\"a\", \"b\"],\n             body:\"a=a\"+op+\"b\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"eq\"\n    })\n    exports[id+\"seq\"] = makeOp({\n      args: [\"array\", \"scalar\"],\n      body: {args:[\"a\",\"s\"],\n             body:\"a=a\"+op+\"s\"},\n      rvalue:true,\n      count:2,\n      funcName: id+\"seq\"\n    })\n  }\n})();\n\nvar math_unary = [\n  \"abs\",\n  \"acos\",\n  \"asin\",\n  \"atan\",\n  \"ceil\",\n  \"cos\",\n  \"exp\",\n  \"floor\",\n  \"log\",\n  \"round\",\n  \"sin\",\n  \"sqrt\",\n  \"tan\"\n]\n;(function() {\n  for(var i=0; i<math_unary.length; ++i) {\n    var f = math_unary[i]\n    exports[f] = makeOp({\n                    args: [\"array\", \"array\"],\n                    pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                    body: {args:[\"a\",\"b\"], body:\"a=this_f(b)\", thisVars:[\"this_f\"]},\n                    funcName: f\n                  })\n    exports[f+\"eq\"] = makeOp({\n                      args: [\"array\"],\n                      pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                      body: {args: [\"a\"], body:\"a=this_f(a)\", thisVars:[\"this_f\"]},\n                      rvalue: true,\n                      count: 2,\n                      funcName: f+\"eq\"\n                    })\n  }\n})();\n\nvar math_comm = [\n  \"max\",\n  \"min\",\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_comm.length; ++i) {\n    var f= math_comm[i]\n    exports[f] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f\n                })\n    exports[f+\"s\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(b,c)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"s\"\n                  })\n    exports[f+\"eq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"eq\"\n                  })\n    exports[f+\"seq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(a,b)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"seq\"\n                  })\n  }\n})();\n\nvar math_noncomm = [\n  \"atan2\",\n  \"pow\"\n]\n;(function(){\n  for(var i=0; i<math_noncomm.length; ++i) {\n    var f= math_noncomm[i]\n    exports[f+\"op\"] = makeOp({\n                  args:[\"array\", \"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"op\"\n                })\n    exports[f+\"ops\"] = makeOp({\n                  args:[\"array\", \"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\",\"c\"], body:\"a=this_f(c,b)\", thisVars:[\"this_f\"]},\n                  funcName: f+\"ops\"\n                  })\n    exports[f+\"opeq\"] = makeOp({ args:[\"array\", \"array\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue: true,\n                  count: 2,\n                  funcName: f+\"opeq\"\n                  })\n    exports[f+\"opseq\"] = makeOp({ args:[\"array\", \"scalar\"],\n                  pre: {args:[], body:\"this_f=Math.\"+f, thisVars:[\"this_f\"]},\n                  body: {args:[\"a\",\"b\"], body:\"a=this_f(b,a)\", thisVars:[\"this_f\"]},\n                  rvalue:true,\n                  count:2,\n                  funcName: f+\"opseq\"\n                  })\n  }\n})();\n\nexports.any = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"if(a){return true}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return false\"},\n  funcName: \"any\"\n})\n\nexports.all = compile({\n  args:[\"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1}], body: \"if(!x){return false}\", localVars: [], thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"all\"\n})\n\nexports.sum = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s+=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"sum\"\n})\n\nexports.prod = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=1\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:1}], body: \"this_s*=a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"prod\"\n})\n\nexports.norm2squared = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm2squared\"\n})\n  \nexports.norm2 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:2}], body: \"this_s+=a*a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return Math.sqrt(this_s)\"},\n  funcName: \"norm2\"\n})\n  \n\nexports.norminf = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:4}], body:\"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norminf\"\n})\n\nexports.norm1 = compile({\n  args:[\"array\"],\n  pre: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"this_s=0\"},\n  body: {args:[{name:\"a\", lvalue:false, rvalue:true, count:3}], body: \"this_s+=a<0?-a:a\", localVars: [], thisVars: [\"this_s\"]},\n  post: {args:[], localVars:[], thisVars:[\"this_s\"], body:\"return this_s\"},\n  funcName: \"norm1\"\n})\n\nexports.sup = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=-Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.inf = compile({\n  args: [ \"array\" ],\n  pre:\n   { body: \"this_h=Infinity\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  body:\n   { body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n     args: [{\"name\":\"_inline_1_arg0_\",\"lvalue\":false,\"rvalue\":true,\"count\":2} ],\n     thisVars: [ \"this_h\" ],\n     localVars: [] },\n  post:\n   { body: \"return this_h\",\n     args: [],\n     thisVars: [ \"this_h\" ],\n     localVars: [] }\n })\n\nexports.argmin = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})\n\nexports.argmax = compile({\n  args:[\"index\",\"array\",\"shape\"],\n  pre:{\n    body:\"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n    args:[\n      {name:\"_inline_0_arg0_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg1_\",lvalue:false,rvalue:false,count:0},\n      {name:\"_inline_0_arg2_\",lvalue:false,rvalue:true,count:1}\n      ],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[]},\n  body:{\n    body:\"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n    args:[\n      {name:\"_inline_1_arg0_\",lvalue:false,rvalue:true,count:2},\n      {name:\"_inline_1_arg1_\",lvalue:false,rvalue:true,count:2}],\n    thisVars:[\"this_i\",\"this_v\"],\n    localVars:[\"_inline_1_k\"]},\n  post:{\n    body:\"{return this_i}\",\n    args:[],\n    thisVars:[\"this_i\"],\n    localVars:[]}\n})  \n\nexports.random = makeOp({\n  args: [\"array\"],\n  pre: {args:[], body:\"this_f=Math.random\", thisVars:[\"this_f\"]},\n  body: {args: [\"a\"], body:\"a=this_f()\", thisVars:[\"this_f\"]},\n  funcName: \"random\"\n})\n\nexports.assign = makeOp({\n  args:[\"array\", \"array\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assign\" })\n\nexports.assigns = makeOp({\n  args:[\"array\", \"scalar\"],\n  body: {args:[\"a\", \"b\"], body:\"a=b\"},\n  funcName: \"assigns\" })\n\n\nexports.equals = compile({\n  args:[\"array\", \"array\"],\n  pre: EmptyProc,\n  body: {args:[{name:\"x\", lvalue:false, rvalue:true, count:1},\n               {name:\"y\", lvalue:false, rvalue:true, count:1}], \n        body: \"if(x!==y){return false}\", \n        localVars: [], \n        thisVars: []},\n  post: {args:[], localVars:[], thisVars:[], body:\"return true\"},\n  funcName: \"equals\"\n})\n\n\n", "import ndarray from 'ndarray';\nimport type { NdArray } from 'ndarray';\n\nexport function getPixelsInternal(\n\tbuffer: Uint8Array,\n\tmimeType: string\n): Promise<NdArray<Uint8Array>> {\n\t// Warn for Data URIs, URLs, and file paths. Support removed in v3.\n\tif (!(buffer instanceof Uint8Array)) {\n\t\tthrow new Error('[ndarray-pixels] Input must be Uint8Array or Buffer.');\n\t}\n\n\tconst blob = new Blob([buffer], { type: mimeType });\n\tconst path = URL.createObjectURL(blob);\n\n\t// Decode image with Canvas API.\n\treturn new Promise((resolve, reject) => {\n\t\tconst img = new Image();\n\t\timg.crossOrigin = 'anonymous';\n\t\timg.onload = function () {\n\t\t\tURL.revokeObjectURL(path as string);\n\n\t\t\tconst canvas = new OffscreenCanvas(img.width, img.height);\n\t\t\tconst context = canvas.getContext('2d')!;\n\t\t\tcontext.drawImage(img, 0, 0);\n\t\t\tconst pixels = context.getImageData(0, 0, img.width, img.height);\n\t\t\tresolve(\n\t\t\t\tndarray(\n\t\t\t\t\tnew Uint8Array(pixels.data),\n\t\t\t\t\t[img.width, img.height, 4],\n\t\t\t\t\t[4, 4 * img.width, 1],\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t);\n\t\t};\n\t\timg.onerror = (err) => {\n\t\t\tURL.revokeObjectURL(path as string);\n\t\t\treject(err);\n\t\t};\n\t\timg.src = path;\n\t});\n}\n", "import ndarray, { NdArray } from 'ndarray';\nimport ops from 'ndarray-ops';\n\nexport interface ImageEncodeOptions {\n\ttype?: string;\n\tquality?: number;\n}\n\nexport function putPixelData(\n\tarray: NdArray<Uint8Array | Uint8ClampedArray>,\n\tdata: Uint8Array | Uint8ClampedArray,\n\tframe = -1\n): Uint8Array | Uint8ClampedArray {\n\tif (array.shape.length === 4) {\n\t\treturn putPixelData(array.pick(frame), data, 0);\n\t} else if (array.shape.length === 3) {\n\t\tif (array.shape[2] === 3) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\t\tarray\n\t\t\t);\n\t\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t\t} else if (array.shape[2] === 4) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 4], [4, array.shape[0] * 4, 1]),\n\t\t\t\tarray\n\t\t\t);\n\t\t} else if (array.shape[2] === 1) {\n\t\t\tops.assign(\n\t\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\t\tndarray(\n\t\t\t\t\tarray.data,\n\t\t\t\t\t[array.shape[0], array.shape[1], 3],\n\t\t\t\t\t[array.stride[0], array.stride[1], 0],\n\t\t\t\t\tarray.offset\n\t\t\t\t)\n\t\t\t);\n\t\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t\t} else {\n\t\t\tthrow new Error('[ndarray-pixels] Incompatible array shape.');\n\t\t}\n\t} else if (array.shape.length === 2) {\n\t\tops.assign(\n\t\t\tndarray(data, [array.shape[0], array.shape[1], 3], [4, 4 * array.shape[0], 1]),\n\t\t\tndarray(\n\t\t\t\tarray.data,\n\t\t\t\t[array.shape[0], array.shape[1], 3],\n\t\t\t\t[array.stride[0], array.stride[1], 0],\n\t\t\t\tarray.offset\n\t\t\t)\n\t\t);\n\t\tops.assigns(ndarray(data, [array.shape[0] * array.shape[1]], [4], 3), 255);\n\t} else {\n\t\tthrow new Error('[ndarray-pixels] Incompatible array shape.');\n\t}\n\treturn data;\n}\n", "import type { NdArray } from 'ndarray';\nimport { putPixelData } from './common';\nimport type { ImageEncodeOptions } from './common';\n\nexport async function savePixelsInternal(\n\tpixels: NdArray<Uint8Array | Uint8ClampedArray>,\n\toptions: ImageEncodeOptions\n): Promise<Uint8Array> {\n\t// Create OffscreenCanvas and write pixel data.\n\tconst canvas = new OffscreenCanvas(pixels.shape[0], pixels.shape[1]);\n\n\tconst context = canvas.getContext('2d')!;\n\tconst imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\n\tputPixelData(pixels, imageData.data);\n\tcontext.putImageData(imageData, 0, 0);\n\n\treturn streamCanvas(canvas, options);\n}\n\n/** Creates readable stream from given OffscreenCanvas and options. */\nasync function streamCanvas(\n\tcanvas: OffscreenCanvas,\n\toptions: ImageEncodeOptions\n): Promise<Uint8Array> {\n\tconst blob = await canvas.convertToBlob(options);\n\tconst ab = await blob.arrayBuffer();\n\treturn new Uint8Array(ab);\n}\n", "import type { NdArray } from 'ndarray';\nimport { getPixelsInternal } from './node-get-pixels';\nimport { savePixelsInternal } from './node-save-pixels';\n\n/**\n * Decodes image data to an `ndarray`.\n *\n * MIME type is optional when given a path or URL, and required when given a Uint8Array.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param data\n * @param mimeType `image/jpeg`, `image/png`, etc.\n * @returns\n */\nasync function getPixels(data: Uint8Array, mimeType: string): Promise<NdArray<Uint8Array>> {\n\treturn getPixelsInternal(data, mimeType);\n}\n\n/**\n * Encodes an `ndarray` as image data in the given format.\n *\n * If the source `ndarray` was constructed manually with default stride, use\n * `ndarray.transpose(1, 0)` to reshape it and ensure an identical result from getPixels(). For an\n * ndarray created by getPixels(), this isn't necessary.\n *\n * Accepts `image/png` or `image/jpeg` in Node.js, and additional formats on browsers with\n * the necessary support in Canvas 2D.\n *\n * @param pixels ndarray of shape W x H x 4.\n * @param typeOrOptions object with encoding options or just the type\n * @param typeOrOptions.type target format (`image/jpeg`, `image/png`, `image/webp`, etc.)\n * @param typeOrOptions.quality quality as a number from 0 to 1, inclusive\n * @returns\n */\nasync function savePixels(\n\tpixels: NdArray<Uint8Array | Uint8ClampedArray>,\n\ttypeOrOptions: string | { type?: string; quality?: number }\n): Promise<Uint8Array> {\n\tlet options;\n\tif (typeof typeOrOptions === 'string') {\n\t\toptions = {\n\t\t\ttype: typeOrOptions,\n\t\t\tquality: undefined,\n\t\t};\n\t} else {\n\t\toptions = {\n\t\t\ttype: typeOrOptions.type,\n\t\t\tquality: typeOrOptions.quality,\n\t\t};\n\t}\n\treturn savePixelsInternal(pixels, options);\n}\n\nexport { getPixels, savePixels };\n", "///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KHR_SUPERCOMPRESSION_NONE = 0;\nexport const KHR_SUPERCOMPRESSION_BASISLZ = 1;\nexport const KHR_SUPERCOMPRESSION_ZSTD = 2;\nexport const KHR_SUPERCOMPRESSION_ZLIB = 3;\n\nexport type Supercompression =\n\t| typeof KHR_SUPERCOMPRESSION_NONE\n\t| typeof KHR_SUPERCOMPRESSION_BASISLZ\n\t| typeof KHR_SUPERCOMPRESSION_ZSTD\n\t| typeof KHR_SUPERCOMPRESSION_ZLIB;\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport const KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;\nexport const KHR_DF_VENDORID_KHRONOS = 0;\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_MODEL_UNSPECIFIED = 0;\nexport const KHR_DF_MODEL_RGBSDA = 1;\n// ...\nexport const KHR_DF_MODEL_ETC1 = 160;\nexport const KHR_DF_MODEL_ETC2 = 161;\nexport const KHR_DF_MODEL_ASTC = 162;\nexport const KHR_DF_MODEL_ETC1S = 163;\nexport const KHR_DF_MODEL_UASTC = 166;\n\nexport const KHR_DF_FLAG_ALPHA_STRAIGHT = 0;\nexport const KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;\n\nexport const KHR_DF_TRANSFER_UNSPECIFIED = 0;\nexport const KHR_DF_TRANSFER_LINEAR = 1;\nexport const KHR_DF_TRANSFER_SRGB = 2;\nexport const KHR_DF_TRANSFER_ITU = 3;\nexport const KHR_DF_TRANSFER_NTSC = 4;\nexport const KHR_DF_TRANSFER_SLOG = 5;\nexport const KHR_DF_TRANSFER_SLOG2 = 6;\nexport const KHR_DF_TRANSFER_BT1886 = 7;\nexport const KHR_DF_TRANSFER_HLG_OETF = 8;\nexport const KHR_DF_TRANSFER_HLG_EOTF = 9;\nexport const KHR_DF_TRANSFER_PQ_EOTF = 10;\nexport const KHR_DF_TRANSFER_PQ_OETF = 11;\nexport const KHR_DF_TRANSFER_DCIP3 = 12;\nexport const KHR_DF_TRANSFER_PAL_OETF = 13;\nexport const KHR_DF_TRANSFER_PAL625_EOTF = 14;\nexport const KHR_DF_TRANSFER_ST240 = 15;\nexport const KHR_DF_TRANSFER_ACESCC = 16;\nexport const KHR_DF_TRANSFER_ACESCCT = 17;\nexport const KHR_DF_TRANSFER_ADOBERGB = 18;\n\nexport type Transfer =\n\t| typeof KHR_DF_TRANSFER_UNSPECIFIED\n\t| typeof KHR_DF_TRANSFER_LINEAR\n\t| typeof KHR_DF_TRANSFER_SRGB\n\t| typeof KHR_DF_TRANSFER_ITU\n\t| typeof KHR_DF_TRANSFER_NTSC\n\t| typeof KHR_DF_TRANSFER_SLOG\n\t| typeof KHR_DF_TRANSFER_SLOG2\n\t| typeof KHR_DF_TRANSFER_BT1886\n\t| typeof KHR_DF_TRANSFER_HLG_OETF\n\t| typeof KHR_DF_TRANSFER_HLG_EOTF\n\t| typeof KHR_DF_TRANSFER_PQ_EOTF\n\t| typeof KHR_DF_TRANSFER_PQ_OETF\n\t| typeof KHR_DF_TRANSFER_DCIP3\n\t| typeof KHR_DF_TRANSFER_PAL_OETF\n\t| typeof KHR_DF_TRANSFER_PAL625_EOTF\n\t| typeof KHR_DF_TRANSFER_ST240\n\t| typeof KHR_DF_TRANSFER_ACESCC\n\t| typeof KHR_DF_TRANSFER_ACESCCT\n\t| typeof KHR_DF_TRANSFER_ADOBERGB;\n\nexport const KHR_DF_PRIMARIES_UNSPECIFIED = 0;\nexport const KHR_DF_PRIMARIES_BT709 = 1;\nexport const KHR_DF_PRIMARIES_BT601_EBU = 2;\nexport const KHR_DF_PRIMARIES_BT601_SMPTE = 3;\nexport const KHR_DF_PRIMARIES_BT2020 = 4;\nexport const KHR_DF_PRIMARIES_CIEXYZ = 5;\nexport const KHR_DF_PRIMARIES_ACES = 6;\nexport const KHR_DF_PRIMARIES_ACESCC = 7;\nexport const KHR_DF_PRIMARIES_NTSC1953 = 8;\nexport const KHR_DF_PRIMARIES_PAL525 = 9;\nexport const KHR_DF_PRIMARIES_DISPLAYP3 = 10;\nexport const KHR_DF_PRIMARIES_ADOBERGB = 11;\n\nexport type Primaries =\n\t| typeof KHR_DF_PRIMARIES_UNSPECIFIED\n\t| typeof KHR_DF_PRIMARIES_BT709\n\t| typeof KHR_DF_PRIMARIES_BT601_EBU\n\t| typeof KHR_DF_PRIMARIES_BT601_SMPTE\n\t| typeof KHR_DF_PRIMARIES_BT2020\n\t| typeof KHR_DF_PRIMARIES_CIEXYZ\n\t| typeof KHR_DF_PRIMARIES_ACES\n\t| typeof KHR_DF_PRIMARIES_ACESCC\n\t| typeof KHR_DF_PRIMARIES_NTSC1953\n\t| typeof KHR_DF_PRIMARIES_PAL525\n\t| typeof KHR_DF_PRIMARIES_DISPLAYP3\n\t| typeof KHR_DF_PRIMARIES_ADOBERGB;\n\nexport const KHR_DF_CHANNEL_RGBSDA_RED = 0;\nexport const KHR_DF_CHANNEL_RGBSDA_GREEN = 1;\nexport const KHR_DF_CHANNEL_RGBSDA_BLUE = 2;\nexport const KHR_DF_CHANNEL_RGBSDA_STENCIL = 13;\nexport const KHR_DF_CHANNEL_RGBSDA_DEPTH = 14;\nexport const KHR_DF_CHANNEL_RGBSDA_ALPHA = 15;\n\nexport type Channel =\n\t| typeof KHR_DF_CHANNEL_RGBSDA_RED\n\t| typeof KHR_DF_CHANNEL_RGBSDA_GREEN\n\t| typeof KHR_DF_CHANNEL_RGBSDA_BLUE\n\t| typeof KHR_DF_CHANNEL_RGBSDA_STENCIL\n\t| typeof KHR_DF_CHANNEL_RGBSDA_DEPTH\n\t| typeof KHR_DF_CHANNEL_RGBSDA_ALPHA;\n\nexport const KHR_DF_SAMPLE_DATATYPE_FLOAT = 0x80;\nexport const KHR_DF_SAMPLE_DATATYPE_SIGNED = 0x40;\nexport const KHR_DF_SAMPLE_DATATYPE_EXPONENT = 0x20;\nexport const KHR_DF_SAMPLE_DATATYPE_LINEAR = 0x10;\n\nexport type SampleDatatype =\n\t| typeof KHR_DF_SAMPLE_DATATYPE_FLOAT\n\t| typeof KHR_DF_SAMPLE_DATATYPE_SIGNED\n\t| typeof KHR_DF_SAMPLE_DATATYPE_EXPONENT\n\t| typeof KHR_DF_SAMPLE_DATATYPE_LINEAR;\n\n///////////////////////////////////////////////////\n// VK FORMAT.\n///////////////////////////////////////////////////\n\nexport const VK_FORMAT_UNDEFINED = 0;\nexport const VK_FORMAT_R4G4_UNORM_PACK8 = 1;\nexport const VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2;\nexport const VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3;\nexport const VK_FORMAT_R5G6B5_UNORM_PACK16 = 4;\nexport const VK_FORMAT_B5G6R5_UNORM_PACK16 = 5;\nexport const VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6;\nexport const VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7;\nexport const VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8;\nexport const VK_FORMAT_R8_UNORM = 9;\nexport const VK_FORMAT_R8_SNORM = 10;\nexport const VK_FORMAT_R8_UINT = 13;\nexport const VK_FORMAT_R8_SINT = 14;\nexport const VK_FORMAT_R8_SRGB = 15;\nexport const VK_FORMAT_R8G8_UNORM = 16;\nexport const VK_FORMAT_R8G8_SNORM = 17;\nexport const VK_FORMAT_R8G8_UINT = 20;\nexport const VK_FORMAT_R8G8_SINT = 21;\nexport const VK_FORMAT_R8G8_SRGB = 22;\nexport const VK_FORMAT_R8G8B8_UNORM = 23;\nexport const VK_FORMAT_R8G8B8_SNORM = 24;\nexport const VK_FORMAT_R8G8B8_UINT = 27;\nexport const VK_FORMAT_R8G8B8_SINT = 28;\nexport const VK_FORMAT_R8G8B8_SRGB = 29;\nexport const VK_FORMAT_B8G8R8_UNORM = 30;\nexport const VK_FORMAT_B8G8R8_SNORM = 31;\nexport const VK_FORMAT_B8G8R8_UINT = 34;\nexport const VK_FORMAT_B8G8R8_SINT = 35;\nexport const VK_FORMAT_B8G8R8_SRGB = 36;\nexport const VK_FORMAT_R8G8B8A8_UNORM = 37;\nexport const VK_FORMAT_R8G8B8A8_SNORM = 38;\nexport const VK_FORMAT_R8G8B8A8_UINT = 41;\nexport const VK_FORMAT_R8G8B8A8_SINT = 42;\nexport const VK_FORMAT_R8G8B8A8_SRGB = 43;\nexport const VK_FORMAT_B8G8R8A8_UNORM = 44;\nexport const VK_FORMAT_B8G8R8A8_SNORM = 45;\nexport const VK_FORMAT_B8G8R8A8_UINT = 48;\nexport const VK_FORMAT_B8G8R8A8_SINT = 49;\nexport const VK_FORMAT_B8G8R8A8_SRGB = 50;\nexport const VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58;\nexport const VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59;\nexport const VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62;\nexport const VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63;\nexport const VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64;\nexport const VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65;\nexport const VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68;\nexport const VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69;\nexport const VK_FORMAT_R16_UNORM = 70;\nexport const VK_FORMAT_R16_SNORM = 71;\nexport const VK_FORMAT_R16_UINT = 74;\nexport const VK_FORMAT_R16_SINT = 75;\nexport const VK_FORMAT_R16_SFLOAT = 76;\nexport const VK_FORMAT_R16G16_UNORM = 77;\nexport const VK_FORMAT_R16G16_SNORM = 78;\nexport const VK_FORMAT_R16G16_UINT = 81;\nexport const VK_FORMAT_R16G16_SINT = 82;\nexport const VK_FORMAT_R16G16_SFLOAT = 83;\nexport const VK_FORMAT_R16G16B16_UNORM = 84;\nexport const VK_FORMAT_R16G16B16_SNORM = 85;\nexport const VK_FORMAT_R16G16B16_UINT = 88;\nexport const VK_FORMAT_R16G16B16_SINT = 89;\nexport const VK_FORMAT_R16G16B16_SFLOAT = 90;\nexport const VK_FORMAT_R16G16B16A16_UNORM = 91;\nexport const VK_FORMAT_R16G16B16A16_SNORM = 92;\nexport const VK_FORMAT_R16G16B16A16_UINT = 95;\nexport const VK_FORMAT_R16G16B16A16_SINT = 96;\nexport const VK_FORMAT_R16G16B16A16_SFLOAT = 97;\nexport const VK_FORMAT_R32_UINT = 98;\nexport const VK_FORMAT_R32_SINT = 99;\nexport const VK_FORMAT_R32_SFLOAT = 100;\nexport const VK_FORMAT_R32G32_UINT = 101;\nexport const VK_FORMAT_R32G32_SINT = 102;\nexport const VK_FORMAT_R32G32_SFLOAT = 103;\nexport const VK_FORMAT_R32G32B32_UINT = 104;\nexport const VK_FORMAT_R32G32B32_SINT = 105;\nexport const VK_FORMAT_R32G32B32_SFLOAT = 106;\nexport const VK_FORMAT_R32G32B32A32_UINT = 107;\nexport const VK_FORMAT_R32G32B32A32_SINT = 108;\nexport const VK_FORMAT_R32G32B32A32_SFLOAT = 109;\nexport const VK_FORMAT_R64_UINT = 110;\nexport const VK_FORMAT_R64_SINT = 111;\nexport const VK_FORMAT_R64_SFLOAT = 112;\nexport const VK_FORMAT_R64G64_UINT = 113;\nexport const VK_FORMAT_R64G64_SINT = 114;\nexport const VK_FORMAT_R64G64_SFLOAT = 115;\nexport const VK_FORMAT_R64G64B64_UINT = 116;\nexport const VK_FORMAT_R64G64B64_SINT = 117;\nexport const VK_FORMAT_R64G64B64_SFLOAT = 118;\nexport const VK_FORMAT_R64G64B64A64_UINT = 119;\nexport const VK_FORMAT_R64G64B64A64_SINT = 120;\nexport const VK_FORMAT_R64G64B64A64_SFLOAT = 121;\nexport const VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122;\nexport const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123;\nexport const VK_FORMAT_D16_UNORM = 124;\nexport const VK_FORMAT_X8_D24_UNORM_PACK32 = 125;\nexport const VK_FORMAT_D32_SFLOAT = 126;\nexport const VK_FORMAT_S8_UINT = 127;\nexport const VK_FORMAT_D16_UNORM_S8_UINT = 128;\nexport const VK_FORMAT_D24_UNORM_S8_UINT = 129;\nexport const VK_FORMAT_D32_SFLOAT_S8_UINT = 130;\nexport const VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131;\nexport const VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132;\nexport const VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133;\nexport const VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134;\nexport const VK_FORMAT_BC2_UNORM_BLOCK = 135;\nexport const VK_FORMAT_BC2_SRGB_BLOCK = 136;\nexport const VK_FORMAT_BC3_UNORM_BLOCK = 137;\nexport const VK_FORMAT_BC3_SRGB_BLOCK = 138;\nexport const VK_FORMAT_BC4_UNORM_BLOCK = 139;\nexport const VK_FORMAT_BC4_SNORM_BLOCK = 140;\nexport const VK_FORMAT_BC5_UNORM_BLOCK = 141;\nexport const VK_FORMAT_BC5_SNORM_BLOCK = 142;\nexport const VK_FORMAT_BC6H_UFLOAT_BLOCK = 143;\nexport const VK_FORMAT_BC6H_SFLOAT_BLOCK = 144;\nexport const VK_FORMAT_BC7_UNORM_BLOCK = 145;\nexport const VK_FORMAT_BC7_SRGB_BLOCK = 146;\nexport const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147;\nexport const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148;\nexport const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149;\nexport const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150;\nexport const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151;\nexport const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152;\nexport const VK_FORMAT_EAC_R11_UNORM_BLOCK = 153;\nexport const VK_FORMAT_EAC_R11_SNORM_BLOCK = 154;\nexport const VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155;\nexport const VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156;\nexport const VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157;\nexport const VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158;\nexport const VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159;\nexport const VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160;\nexport const VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161;\nexport const VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162;\nexport const VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163;\nexport const VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164;\nexport const VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165;\nexport const VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166;\nexport const VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167;\nexport const VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168;\nexport const VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169;\nexport const VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170;\nexport const VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171;\nexport const VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172;\nexport const VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173;\nexport const VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174;\nexport const VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175;\nexport const VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176;\nexport const VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177;\nexport const VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178;\nexport const VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179;\nexport const VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180;\nexport const VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181;\nexport const VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182;\nexport const VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183;\nexport const VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184;\nexport const VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007;\nexport const VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008;\nexport const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009;\nexport const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010;\nexport const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011;\nexport const VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017;\nexport const VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018;\nexport const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019;\nexport const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020;\nexport const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021;\nexport const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000;\nexport const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001;\nexport const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002;\nexport const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003;\nexport const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004;\nexport const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005;\nexport const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006;\nexport const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007;\nexport const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000;\nexport const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001;\nexport const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002;\nexport const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003;\nexport const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004;\nexport const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005;\nexport const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006;\nexport const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007;\nexport const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008;\nexport const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009;\nexport const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010;\nexport const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011;\nexport const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012;\nexport const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013;\nexport const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000;\nexport const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001;\n\nexport type VKFormat =\n\t| typeof VK_FORMAT_UNDEFINED\n\t| typeof VK_FORMAT_R4G4_UNORM_PACK8\n\t| typeof VK_FORMAT_R4G4B4A4_UNORM_PACK16\n\t| typeof VK_FORMAT_B4G4R4A4_UNORM_PACK16\n\t| typeof VK_FORMAT_R5G6B5_UNORM_PACK16\n\t| typeof VK_FORMAT_B5G6R5_UNORM_PACK16\n\t| typeof VK_FORMAT_R5G5B5A1_UNORM_PACK16\n\t| typeof VK_FORMAT_B5G5R5A1_UNORM_PACK16\n\t| typeof VK_FORMAT_A1R5G5B5_UNORM_PACK16\n\t| typeof VK_FORMAT_R8_UNORM\n\t| typeof VK_FORMAT_R8_SNORM\n\t| typeof VK_FORMAT_R8_UINT\n\t| typeof VK_FORMAT_R8_SINT\n\t| typeof VK_FORMAT_R8_SRGB\n\t| typeof VK_FORMAT_R8G8_UNORM\n\t| typeof VK_FORMAT_R8G8_SNORM\n\t| typeof VK_FORMAT_R8G8_UINT\n\t| typeof VK_FORMAT_R8G8_SINT\n\t| typeof VK_FORMAT_R8G8_SRGB\n\t| typeof VK_FORMAT_R8G8B8_UNORM\n\t| typeof VK_FORMAT_R8G8B8_SNORM\n\t| typeof VK_FORMAT_R8G8B8_UINT\n\t| typeof VK_FORMAT_R8G8B8_SINT\n\t| typeof VK_FORMAT_R8G8B8_SRGB\n\t| typeof VK_FORMAT_B8G8R8_UNORM\n\t| typeof VK_FORMAT_B8G8R8_SNORM\n\t| typeof VK_FORMAT_B8G8R8_UINT\n\t| typeof VK_FORMAT_B8G8R8_SINT\n\t| typeof VK_FORMAT_B8G8R8_SRGB\n\t| typeof VK_FORMAT_R8G8B8A8_UNORM\n\t| typeof VK_FORMAT_R8G8B8A8_SNORM\n\t| typeof VK_FORMAT_R8G8B8A8_UINT\n\t| typeof VK_FORMAT_R8G8B8A8_SINT\n\t| typeof VK_FORMAT_R8G8B8A8_SRGB\n\t| typeof VK_FORMAT_B8G8R8A8_UNORM\n\t| typeof VK_FORMAT_B8G8R8A8_SNORM\n\t| typeof VK_FORMAT_B8G8R8A8_UINT\n\t| typeof VK_FORMAT_B8G8R8A8_SINT\n\t| typeof VK_FORMAT_B8G8R8A8_SRGB\n\t| typeof VK_FORMAT_A2R10G10B10_UNORM_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_SNORM_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_UINT_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_SINT_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_UNORM_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_SNORM_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_UINT_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_SINT_PACK32\n\t| typeof VK_FORMAT_R16_UNORM\n\t| typeof VK_FORMAT_R16_SNORM\n\t| typeof VK_FORMAT_R16_UINT\n\t| typeof VK_FORMAT_R16_SINT\n\t| typeof VK_FORMAT_R16_SFLOAT\n\t| typeof VK_FORMAT_R16G16_UNORM\n\t| typeof VK_FORMAT_R16G16_SNORM\n\t| typeof VK_FORMAT_R16G16_UINT\n\t| typeof VK_FORMAT_R16G16_SINT\n\t| typeof VK_FORMAT_R16G16_SFLOAT\n\t| typeof VK_FORMAT_R16G16B16_UNORM\n\t| typeof VK_FORMAT_R16G16B16_SNORM\n\t| typeof VK_FORMAT_R16G16B16_UINT\n\t| typeof VK_FORMAT_R16G16B16_SINT\n\t| typeof VK_FORMAT_R16G16B16_SFLOAT\n\t| typeof VK_FORMAT_R16G16B16A16_UNORM\n\t| typeof VK_FORMAT_R16G16B16A16_SNORM\n\t| typeof VK_FORMAT_R16G16B16A16_UINT\n\t| typeof VK_FORMAT_R16G16B16A16_SINT\n\t| typeof VK_FORMAT_R16G16B16A16_SFLOAT\n\t| typeof VK_FORMAT_R32_UINT\n\t| typeof VK_FORMAT_R32_SINT\n\t| typeof VK_FORMAT_R32_SFLOAT\n\t| typeof VK_FORMAT_R32G32_UINT\n\t| typeof VK_FORMAT_R32G32_SINT\n\t| typeof VK_FORMAT_R32G32_SFLOAT\n\t| typeof VK_FORMAT_R32G32B32_UINT\n\t| typeof VK_FORMAT_R32G32B32_SINT\n\t| typeof VK_FORMAT_R32G32B32_SFLOAT\n\t| typeof VK_FORMAT_R32G32B32A32_UINT\n\t| typeof VK_FORMAT_R32G32B32A32_SINT\n\t| typeof VK_FORMAT_R32G32B32A32_SFLOAT\n\t| typeof VK_FORMAT_R64_UINT\n\t| typeof VK_FORMAT_R64_SINT\n\t| typeof VK_FORMAT_R64_SFLOAT\n\t| typeof VK_FORMAT_R64G64_UINT\n\t| typeof VK_FORMAT_R64G64_SINT\n\t| typeof VK_FORMAT_R64G64_SFLOAT\n\t| typeof VK_FORMAT_R64G64B64_UINT\n\t| typeof VK_FORMAT_R64G64B64_SINT\n\t| typeof VK_FORMAT_R64G64B64_SFLOAT\n\t| typeof VK_FORMAT_R64G64B64A64_UINT\n\t| typeof VK_FORMAT_R64G64B64A64_SINT\n\t| typeof VK_FORMAT_R64G64B64A64_SFLOAT\n\t| typeof VK_FORMAT_B10G11R11_UFLOAT_PACK32\n\t| typeof VK_FORMAT_E5B9G9R9_UFLOAT_PACK32\n\t| typeof VK_FORMAT_D16_UNORM\n\t| typeof VK_FORMAT_X8_D24_UNORM_PACK32\n\t| typeof VK_FORMAT_D32_SFLOAT\n\t| typeof VK_FORMAT_S8_UINT\n\t| typeof VK_FORMAT_D16_UNORM_S8_UINT\n\t| typeof VK_FORMAT_D24_UNORM_S8_UINT\n\t| typeof VK_FORMAT_D32_SFLOAT_S8_UINT\n\t| typeof VK_FORMAT_BC1_RGB_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC1_RGB_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC1_RGBA_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC1_RGBA_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC2_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC2_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC3_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC3_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC4_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC4_SNORM_BLOCK\n\t| typeof VK_FORMAT_BC5_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC5_SNORM_BLOCK\n\t| typeof VK_FORMAT_BC6H_UFLOAT_BLOCK\n\t| typeof VK_FORMAT_BC6H_SFLOAT_BLOCK\n\t| typeof VK_FORMAT_BC7_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC7_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK\n\t| typeof VK_FORMAT_EAC_R11_UNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11_SNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11G11_UNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11G11_SNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_4x4_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_4x4_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x4_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x4_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x10_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x10_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x10_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x10_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x12_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x12_SRGB_BLOCK\n\t| typeof VK_FORMAT_R10X6_UNORM_PACK16\n\t| typeof VK_FORMAT_R10X6G10X6_UNORM_2PACK16\n\t| typeof VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16\n\t| typeof VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_R12X4_UNORM_PACK16\n\t| typeof VK_FORMAT_R12X4G12X4_UNORM_2PACK16\n\t| typeof VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16\n\t| typeof VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT\n\t| typeof VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT;\n", "import {\n\tKHR_DF_FLAG_ALPHA_STRAIGHT,\n\tKHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\tKHR_DF_MODEL_UNSPECIFIED,\n\tKHR_DF_PRIMARIES_BT709,\n\tKHR_DF_TRANSFER_SRGB,\n\tKHR_DF_VENDORID_KHRONOS,\n\tKHR_DF_VERSION,\n\tKHR_SUPERCOMPRESSION_NONE,\n\tSupercompression,\n\tVKFormat,\n\tVK_FORMAT_UNDEFINED,\n} from './constants.js';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat: VKFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme: Supercompression = KHR_SUPERCOMPRESSION_NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [\n\t\t{\n\t\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\t\tdescriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\t\t\tdescriptorBlockSize: 0,\n\t\t\tversionNumber: KHR_DF_VERSION,\n\t\t\tcolorModel: KHR_DF_MODEL_UNSPECIFIED,\n\t\t\tcolorPrimaries: KHR_DF_PRIMARIES_BT709,\n\t\t\ttransferFunction: KHR_DF_TRANSFER_SRGB,\n\t\t\tflags: KHR_DF_FLAG_ALPHA_STRAIGHT,\n\t\t\ttexelBlockDimension: [0, 0, 0, 0],\n\t\t\tbytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],\n\t\t\tsamples: [],\n\t\t},\n\t];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: { [key: string]: string | Uint8Array } = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n}\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\t/** @deprecated Inferred. */\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: [number, number, number, number];\n\tbytesPlane: [number, number, number, number, number, number, number, number];\n\tsamples: KTX2BasicFormatSample[];\n}\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\t/** @deprecated Renamed to 'channelType'. */\n\tchannelID?: number;\n\tchannelType: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n}\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n}\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n}\n", "export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + 2 ** 32 * right;\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_nextInt32() {\n\t\tconst value = this._dataView.getInt32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint8Array(len: number) {\n\t\tconst value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);\n\t\tthis._offset += len;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);\n\t}\n}\n", "///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\nexport type vec3 = [number, number, number];\nexport type vec2 = [number, number, number];\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '', 'K', 'T', 'X', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n\t0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a,\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n", "import { vec3 } from './constants-internal.js';\nimport {\n\tVKFormat,\n\tVK_FORMAT_ASTC_10x10_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x10_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x8_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x8_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_12x10_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_12x10_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_12x12_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_12x12_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_4x4_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_4x4_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_5x4_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_5x4_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_5x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_5x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_6x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_6x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x8_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x8_UNORM_BLOCK,\n\tVK_FORMAT_BC1_RGB_UNORM_BLOCK,\n\tVK_FORMAT_BC7_SRGB_BLOCK,\n\tVK_FORMAT_EAC_R11G11_SNORM_BLOCK,\n\tVK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,\n\tVK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_UNDEFINED,\n} from './constants.js';\nimport type { KTX2Container } from './container.js';\n\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\treturn new TextEncoder().encode(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\treturn new TextDecoder().decode(buffer);\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat(buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}\n\n/** Returns the least common multiple (LCM) for two positive integers. */\nexport function leastCommonMultiple(a: number, b: number): number {\n\tconst max = Math.max(a, b);\n\tconst min = Math.min(a, b);\n\tlet lcm = max;\n\n\twhile (lcm % min !== 0) {\n\t\tlcm += max;\n\t}\n\n\treturn lcm;\n}\n\n/**\n * Returns amount of padding, in bytes, required to pad a value V to N-byte\n * boundaries. Both V and N must be positive integers.\n */\nexport function getPadding(v: number, n = 4): number {\n\treturn Math.ceil(v / n) * n - v;\n}\n\n/** Returns byte length per texel block. */\nexport function getBlockByteLength(container: KTX2Container): number {\n\treturn container.levels[0].levelData.byteLength / getBlockCount(container, 0);\n}\n\n/**\n * Returns total number of blocks for given level. For VK_FORMAT_UNDEFINED, DFD is required.\n *\n * References:\n * - https://github.khronos.org/KTX-Specification/ktxspec.v2.html#levelImages\n */\nexport function getBlockCount(container: KTX2Container, levelIndex: number): number {\n\tlet blockCount = 1;\n\n\tconst pixelDimensions = [container.pixelWidth, container.pixelHeight, container.pixelDepth];\n\tconst blockDimensions = getBlockDimensions(container);\n\n\tfor (let i = 0; i < 3; i++) {\n\t\tif (pixelDimensions[i] > 0) {\n\t\t\tconst dimBlockCount = Math.ceil(\n\t\t\t\tMath.floor(pixelDimensions[i] * Math.pow(2, -levelIndex)) / blockDimensions[i],\n\t\t\t);\n\t\t\tblockCount *= Math.max(1, dimBlockCount);\n\t\t}\n\t}\n\n\tif (container.layerCount > 0) {\n\t\tblockCount *= container.layerCount;\n\t}\n\n\tif (container.faceCount > 0) {\n\t\tblockCount *= container.faceCount;\n\t}\n\n\treturn blockCount;\n}\n\n/**\n * Given a KTX2 container, returns block dimensions as [width, height, depth]. Requires valid DFD.\n */\nexport function getBlockDimensions(container: KTX2Container): vec3 {\n\tconst [x, y, z] = container.dataFormatDescriptor[0].texelBlockDimension;\n\treturn [x + 1, y + 1, z + 1];\n}\n\n/**\n * Given `vkFormat`, returns block dimensions as [width, height, depth]. Does not support\n * VK_FORMAT_UNDEFINED.\n *\n * References:\n * - https://github.khronos.org/KTX-Specification/ktxspec.v2.html#_mippadding\n * - https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.html#formats-compatibility\n */\nexport function getBlockDimensionsByVKFormat(vkFormat: VKFormat): vec3 {\n\tif (vkFormat === VK_FORMAT_UNDEFINED) {\n\t\tthrow new Error('Unknown block dimensions for VK_FORMAT_UNDEFINED.');\n\t} else if (vkFormat >= VK_FORMAT_BC1_RGB_UNORM_BLOCK && vkFormat <= VK_FORMAT_BC7_SRGB_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat >= VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && vkFormat <= VK_FORMAT_EAC_R11G11_SNORM_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_4x4_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_4x4_SRGB_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_5x4_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_5x4_SRGB_BLOCK) {\n\t\treturn [5, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_5x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_5x5_SRGB_BLOCK) {\n\t\treturn [5, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_6x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_6x5_SRGB_BLOCK) {\n\t\treturn [6, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_6x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_6x6_SRGB_BLOCK) {\n\t\treturn [6, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x5_SRGB_BLOCK) {\n\t\treturn [8, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x6_SRGB_BLOCK) {\n\t\treturn [8, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x8_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x8_SRGB_BLOCK) {\n\t\treturn [8, 8, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x5_SRGB_BLOCK) {\n\t\treturn [10, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x6_SRGB_BLOCK) {\n\t\treturn [10, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x8_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x8_SRGB_BLOCK) {\n\t\treturn [10, 8, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x10_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x10_SRGB_BLOCK) {\n\t\treturn [10, 10, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_12x10_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_12x10_SRGB_BLOCK) {\n\t\treturn [12, 10, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_12x12_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_12x12_SRGB_BLOCK) {\n\t\treturn [12, 12, 1];\n\t} else if (\n\t\tvkFormat === VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG\n\t) {\n\t\treturn [8, 4, 1];\n\t} else if (\n\t\tvkFormat === VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG\n\t) {\n\t\treturn [4, 4, 1];\n\t} else {\n\t\treturn [1, 1, 1];\n\t}\n}\n", "import { BufferReader } from './buffer-reader.js';\nimport { KHR_DF_SAMPLE_DATATYPE_SIGNED, Supercompression, VKFormat } from './constants.js';\nimport { KTX2_ID } from './constants-internal.js';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container.js';\nimport { decodeText } from './util.js';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (\n\t\tid[0] !== KTX2_ID[0] || // ''\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // ''\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32() as VKFormat;\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32() as Supercompression;\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(\n\t\t\t\tdata.buffer,\n\t\t\t\tdata.byteOffset + levelReader._nextUint64(),\n\t\t\t\tlevelReader._nextUint64(),\n\t\t\t),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i++) {\n\t\tconst sample = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelType: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: -Infinity,\n\t\t\tsampleUpper: Infinity,\n\t\t};\n\n\t\tif (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n\t\t\tsample.sampleLower = dfdReader._nextInt32();\n\t\t\tsample.sampleUpper = dfdReader._nextInt32();\n\t\t} else {\n\t\t\tsample.sampleLower = dfdReader._nextUint32();\n\t\t\tsample.sampleUpper = dfdReader._nextUint32();\n\t\t}\n\n\t\tdfd.samples[i] = sample;\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\n\t\tcontainer.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);\n\n\t\tif (key.match(/^ktx/i)) {\n\t\t\tconst text = decodeText(container.keyValue[key] as Uint8Array);\n\t\t\tcontainer.keyValue[key] = text.substring(0, text.lastIndexOf('\\x00'));\n\t\t}\n\n\t\tconst kvPadding = keyValueByteLength % 4 ? 4 - (keyValueByteLength % 4) : 0; // align(4)\n\t\t// 4-byte alignment.\n\t\tkvdReader._skip(kvPadding);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n", "import { HEADER_BYTE_LENGTH, KTX2_ID, KTX_WRITER, NUL } from './constants-internal.js';\nimport {\n\tKHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\tKHR_DF_SAMPLE_DATATYPE_SIGNED,\n\tKHR_SUPERCOMPRESSION_NONE,\n} from './constants.js';\nimport { KTX2Container } from './container.js';\nimport { concat, encodeText, getBlockByteLength, getPadding, leastCommonMultiple } from './util.js';\n\ninterface WriteOptions {\n\tkeepWriter?: boolean;\n}\nconst DEFAULT_OPTIONS: WriteOptions = { keepWriter: false };\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = { ...DEFAULT_OPTIONS, ...options };\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = { ...container.keyValue, KTXwriter: KTX_WRITER };\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? concat([encodeText(value), NUL]) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength;\n\t\tconst kvPadding = getPadding(kvByteLength, 4); // align(4)\n\t\tkeyValueData.push(\n\t\t\tconcat([\n\t\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\t\tkeyData,\n\t\t\t\tNUL,\n\t\t\t\tvalueData,\n\t\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t\t]),\n\t\t);\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tif (\n\t\tcontainer.dataFormatDescriptor.length !== 1 ||\n\t\tcontainer.dataFormatDescriptor[0].descriptorType !== KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT\n\t) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tconst dfdBuffer = new ArrayBuffer(28 + dfd.samples.length * 16);\n\tconst dfdView = new DataView(dfdBuffer);\n\tconst descriptorBlockSize = 24 + dfd.samples.length * 16;\n\n\tdfdView.setUint32(0, dfdBuffer.byteLength, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tif (!Array.isArray(dfd.texelBlockDimension)) {\n\t\tthrow new Error('texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.');\n\t}\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension[0]);\n\tdfdView.setUint8(17, dfd.texelBlockDimension[1]);\n\tdfdView.setUint8(18, dfd.texelBlockDimension[2]);\n\tdfdView.setUint8(19, dfd.texelBlockDimension[3]);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tif (sample.channelID) {\n\t\t\tthrow new Error('channelID has been renamed to channelType.');\n\t\t}\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelType);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tif (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n\t\t\tdfdView.setInt32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\t\tdfdView.setInt32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t\t} else {\n\t\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = sgdBuffer.byteLength > 0 ? kvdByteOffset + kvdBuffer.byteLength : 0;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\tconst levelDataByteOffsets = new Uint32Array(container.levels.length);\n\n\tlet levelAlign = 0;\n\tif (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n\t\tlevelAlign = leastCommonMultiple(getBlockByteLength(container), 4);\n\t}\n\n\t// Level data is ordered small  large.\n\tlet levelDataByteOffset = (sgdByteOffset || kvdByteOffset + kvdBuffer.byteLength) + sgdBuffer.byteLength;\n\tfor (let i = container.levels.length - 1; i >= 0; i--) {\n\t\t// Level padding.\n\t\tif (levelDataByteOffset % levelAlign) {\n\t\t\tconst paddingBytes = getPadding(levelDataByteOffset, levelAlign);\n\t\t\tlevelData.push(new Uint8Array(paddingBytes));\n\t\t\tlevelDataByteOffset += paddingBytes;\n\t\t}\n\n\t\t// Level data.\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelDataByteOffsets[i] = levelDataByteOffset;\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\t// Level index is ordered large  small.\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffsets[i]), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdBuffer.byteLength > 0 ? sgdByteOffset : 0), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(\n\t\tconcat([\n\t\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\t\theaderBuffer,\n\t\t\tlevelIndex.buffer,\n\t\t\tdfdBuffer,\n\t\t\tkvdBuffer,\n\t\t\tsgdByteOffset > 0\n\t\t\t\t? new ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)) // align(8)\n\t\t\t\t: new ArrayBuffer(0),\n\t\t\tsgdBuffer,\n\t\t\t...levelData,\n\t\t]),\n\t);\n}\n", "export const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';\nexport const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const EXT_TEXTURE_WEBP = 'EXT_texture_webp';\nexport const EXT_TEXTURE_AVIF = 'EXT_texture_avif';\nexport const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const KHR_MATERIALS_ANISOTROPY = 'KHR_materials_anisotropy';\nexport const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';\nexport const KHR_MATERIALS_DIFFUSE_TRANSMISSION = 'KHR_materials_diffuse_transmission';\nexport const KHR_MATERIALS_DISPERSION = 'KHR_materials_dispersion';\nexport const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';\nexport const KHR_MATERIALS_IOR = 'KHR_materials_ior';\nexport const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';\nexport const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';\nexport const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';\nexport const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';\nexport const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';\nexport const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';\nexport const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';\nexport const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nexport const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\nexport const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';\n", "import { Accessor, ExtensionProperty, IProperty, Nullable, PropertyType, RefMap } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants.js';\n\ninterface IInstancedMesh extends IProperty {\n\tattributes: RefMap<Accessor>;\n}\n\n// See BufferViewUsage in `writer-context.ts`.\nexport const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';\n\n/**\n * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link EXTMeshGPUInstancing}.\n */\nexport class InstancedMesh extends ExtensionProperty<IInstancedMesh> {\n\tpublic static EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;\n\tpublic declare extensionName: typeof EXT_MESH_GPU_INSTANCING;\n\tpublic declare propertyType: 'InstancedMesh';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = EXT_MESH_GPU_INSTANCING;\n\t\tthis.propertyType = 'InstancedMesh';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<IInstancedMesh> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { attributes: new RefMap<Accessor>() });\n\t}\n\n\t/** Returns an instance attribute as an {@link Accessor}. */\n\tpublic getAttribute(semantic: string): Accessor | null {\n\t\treturn this.getRefMap('attributes', semantic);\n\t}\n\n\t/**\n\t * Sets an instance attribute to an {@link Accessor}. All attributes must have the same\n\t * instance count.\n\t */\n\tpublic setAttribute(semantic: string, accessor: Accessor | null): this {\n\t\treturn this.setRefMap('attributes', semantic, accessor, { usage: INSTANCE_ATTRIBUTE });\n\t}\n\n\t/**\n\t * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order\n\t * will be consistent with the order returned by {@link .listSemantics}().\n\t */\n\tpublic listAttributes(): Accessor[] {\n\t\treturn this.listRefMapValues('attributes');\n\t}\n\n\t/**\n\t * Lists all instance attribute semantics associated with the primitive. Order will be\n\t * consistent with the order returned by {@link .listAttributes}().\n\t */\n\tpublic listSemantics(): string[] {\n\t\treturn this.listRefMapKeys('attributes');\n\t}\n}\n", "import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { EXT_MESH_GPU_INSTANCING } from '../constants.js';\nimport { InstancedMesh, INSTANCE_ATTRIBUTE } from './instanced-mesh.js';\n\nconst NAME = EXT_MESH_GPU_INSTANCING;\n\ninterface InstancedMeshDef {\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\n/**\n * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)\n * prepares mesh data for efficient GPU instancing.\n *\n * GPU instancing allows engines to render many copies of a single mesh at once using a small number\n * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.\n * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling\n * within a batch. Dividing batches into collocated cells may be preferable to using a single large\n * batch.\n *\n * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it\n * > is important to note that (1) GPU instancing and other optimizations are possible  and\n * > encouraged  even without this extension, and (2) other common meanings of the term\n * > \"instancing\" exist, distinct from this extension. See\n * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)\n * > of the `EXT_mesh_gpu_instancing` specification._\n *\n * Properties:\n * - {@link InstancedMesh}\n *\n * ### Example\n *\n * The `EXTMeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,\n * which may be attached to any {@link Node} instance. For example:\n *\n * ```typescript\n * import { EXTMeshGPUInstancing } from '@gltf-transform/extensions';\n *\n * // Create standard mesh, node, and scene hierarchy.\n * // ...\n *\n * // Assign positions for each instance.\n * const batchPositions = doc.createAccessor('instance_positions')\n * \t.setArray(new Float32Array([\n * \t\t0, 0, 0,\n * \t\t1, 0, 0,\n * \t\t2, 0, 0,\n * \t]))\n * \t.setType(Accessor.Type.VEC3)\n * \t.setBuffer(buffer);\n *\n * // Assign IDs for each instance.\n * const batchIDs = doc.createAccessor('instance_ids')\n * \t.setArray(new Uint8Array([0, 1, 2]))\n * \t.setType(Accessor.Type.SCALAR)\n * \t.setBuffer(buffer);\n *\n * // Create an Extension attached to the Document.\n * const batchExtension = document.createExtension(EXTMeshGPUInstancing)\n * \t.setRequired(true);\n * const batch = batchExtension.createInstancedMesh()\n * \t.setAttribute('TRANSLATION', batchPositions)\n * \t.setAttribute('_ID', batchIDs);\n *\n * node\n * \t.setMesh(mesh)\n * \t.setExtension('EXT_mesh_gpu_instancing', batch);\n * ```\n *\n * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor\n * types allowed by the extension specification. Custom instance attributes are allowed, and should\n * be prefixed with an underscore (`_*`).\n */\nexport class EXTMeshGPUInstancing extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly provideTypes = [PropertyType.NODE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new InstancedMesh property for use on a {@link Node}. */\n\tpublic createInstancedMesh(): InstancedMesh {\n\t\treturn new InstancedMesh(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst nodeDefs = jsonDoc.json.nodes || [];\n\t\tnodeDefs.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\n\t\t\tconst instancedMeshDef = nodeDef.extensions[NAME] as InstancedMeshDef;\n\t\t\tconst instancedMesh = this.createInstancedMesh();\n\n\t\t\tfor (const semantic in instancedMeshDef.attributes) {\n\t\t\t\tinstancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);\n\t\t\t}\n\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, instancedMesh);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\t// Set usage for instance attribute accessors, so they are stored in separate buffer\n\t\t// views grouped by parent reference.\n\t\tcontext.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);\n\t\tfor (const prop of this.properties) {\n\t\t\tfor (const attribute of (prop as InstancedMesh).listAttributes()) {\n\t\t\t\tcontext.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst instancedMesh = node.getExtension<InstancedMesh>(NAME);\n\t\t\t\tif (instancedMesh) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\n\t\t\t\t\tconst instancedMeshDef = { attributes: {} } as InstancedMeshDef;\n\n\t\t\t\t\tinstancedMesh.listSemantics().forEach((semantic) => {\n\t\t\t\t\t\tconst attribute = instancedMesh.getAttribute(semantic)!;\n\t\t\t\t\t\tinstancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute)!;\n\t\t\t\t\t});\n\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = instancedMeshDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import type { GLTF, TypedArray } from '@gltf-transform/core';\n\nexport enum EncoderMethod {\n\tQUANTIZE = 'quantize',\n\tFILTER = 'filter',\n}\n\nexport interface MeshoptBufferExtension {\n\tfallback?: boolean;\n}\n\nexport enum MeshoptMode {\n\tATTRIBUTES = 'ATTRIBUTES',\n\tTRIANGLES = 'TRIANGLES',\n\tINDICES = 'INDICES',\n}\n\nexport enum MeshoptFilter {\n\t/** No filter  quantize only. */\n\tNONE = 'NONE',\n\t/** Four 8- or 16-bit normalized values. */\n\tOCTAHEDRAL = 'OCTAHEDRAL',\n\t/** Four 16-bit normalized values. */\n\tQUATERNION = 'QUATERNION',\n\t/** K single-precision floating point values. */\n\tEXPONENTIAL = 'EXPONENTIAL',\n}\n\nexport interface MeshoptBufferViewExtension {\n\tbuffer: number;\n\tbyteOffset: number;\n\tbyteLength: number;\n\tbyteStride: number;\n\tcount: number;\n\tmode: MeshoptMode;\n\tfilter?: MeshoptFilter;\n}\n\n/**\n * When using filters, the accessor definition written to the file will not necessarily have the\n * same properties as the input accessor. For example, octahedral encoding requires int8 or int16\n * output, so float32 input must be ignored.\n */\nexport interface PreparedAccessor {\n\tarray: TypedArray;\n\tbyteStride: number;\n\tnormalized: boolean;\n\tcomponentType: GLTF.AccessorComponentType;\n\tmin?: number[];\n\tmax?: number[];\n}\n", "import { PreparedAccessor, MeshoptFilter, MeshoptMode } from './constants.js';\nimport {\n\tAccessor,\n\tAnimationChannel,\n\tAnimationSampler,\n\tBufferUtils,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPrimitive,\n\tPropertyType,\n\tRoot,\n\tTypedArray,\n\tTypedArrayConstructor,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport type { MeshoptEncoder } from 'meshoptimizer';\n\nconst { BYTE, SHORT, FLOAT } = Accessor.ComponentType;\nconst { encodeNormalizedInt, decodeNormalizedInt } = MathUtils;\n\n/** Pre-processes array with required filters or padding. */\nexport function prepareAccessor(\n\taccessor: Accessor,\n\tencoder: typeof MeshoptEncoder,\n\tmode: MeshoptMode,\n\tfilterOptions: { filter: MeshoptFilter; bits?: number },\n): PreparedAccessor {\n\tconst { filter, bits } = filterOptions as { filter: MeshoptFilter; bits: number };\n\tconst result: PreparedAccessor = {\n\t\tarray: accessor.getArray()!,\n\t\tbyteStride: accessor.getElementSize() * accessor.getComponentSize(),\n\t\tcomponentType: accessor.getComponentType(),\n\t\tnormalized: accessor.getNormalized(),\n\t};\n\n\tif (mode !== MeshoptMode.ATTRIBUTES) return result;\n\n\tif (filter !== MeshoptFilter.NONE) {\n\t\tlet array = accessor.getNormalized() ? decodeNormalizedIntArray(accessor) : new Float32Array(result.array);\n\n\t\tswitch (filter) {\n\t\t\tcase MeshoptFilter.EXPONENTIAL: //  K single-precision floating point values.\n\t\t\t\tresult.byteStride = accessor.getElementSize() * 4;\n\t\t\t\tresult.componentType = FLOAT;\n\t\t\t\tresult.normalized = false;\n\t\t\t\tresult.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.OCTAHEDRAL: //  four 8- or 16-bit normalized values.\n\t\t\t\tresult.byteStride = bits > 8 ? 8 : 4;\n\t\t\t\tresult.componentType = bits > 8 ? SHORT : BYTE;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tarray = accessor.getElementSize() === 3 ? padNormals(array) : array;\n\t\t\t\tresult.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tcase MeshoptFilter.QUATERNION: //  four 16-bit normalized values.\n\t\t\t\tresult.byteStride = 8;\n\t\t\t\tresult.componentType = SHORT;\n\t\t\t\tresult.normalized = true;\n\t\t\t\tresult.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid filter.');\n\t\t}\n\n\t\tresult.min = accessor.getMin([]);\n\t\tresult.max = accessor.getMax([]);\n\t\tif (accessor.getNormalized()) {\n\t\t\tresult.min = result.min.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));\n\t\t\tresult.max = result.max.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));\n\t\t}\n\t\tif (result.normalized) {\n\t\t\tresult.min = result.min.map((v) => encodeNormalizedInt(v, result.componentType));\n\t\t\tresult.max = result.max.map((v) => encodeNormalizedInt(v, result.componentType));\n\t\t}\n\t} else if (result.byteStride % 4) {\n\t\tresult.array = padArrayElements(result.array, accessor.getElementSize());\n\t\tresult.byteStride = result.array.byteLength / accessor.getCount();\n\t}\n\n\treturn result;\n}\n\nfunction decodeNormalizedIntArray(attribute: Accessor): Float32Array {\n\tconst componentType = attribute.getComponentType();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = new Float32Array(srcArray.length);\n\tfor (let i = 0; i < srcArray.length; i++) {\n\t\tdstArray[i] = decodeNormalizedInt(srcArray[i], componentType);\n\t}\n\treturn dstArray;\n}\n\n/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */\nexport function padArrayElements<T extends TypedArray>(srcArray: T, elementSize: number): T {\n\tconst byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);\n\tconst elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;\n\tconst elementCount = srcArray.length / elementSize;\n\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(elementCount * elementStride) as T;\n\n\tfor (let i = 0; i * elementSize < srcArray.length; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementStride + j] = srcArray[i * elementSize + j];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n\n/** Pad normals with a .w component for octahedral encoding. */\nfunction padNormals(srcArray: Float32Array): Float32Array {\n\tconst dstArray = new Float32Array((srcArray.length * 4) / 3);\n\tfor (let i = 0, il = srcArray.length / 3; i < il; i++) {\n\t\tdstArray[i * 4] = srcArray[i * 3];\n\t\tdstArray[i * 4 + 1] = srcArray[i * 3 + 1];\n\t\tdstArray[i * 4 + 2] = srcArray[i * 3 + 2];\n\t}\n\treturn dstArray;\n}\n\nexport function getMeshoptMode(accessor: Accessor, usage: string): MeshoptMode {\n\tif (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {\n\t\tconst isTriangles = accessor.listParents().some((parent) => {\n\t\t\treturn parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;\n\t\t});\n\t\treturn isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;\n\t}\n\n\treturn MeshoptMode.ATTRIBUTES;\n}\n\nexport function getMeshoptFilter(accessor: Accessor, doc: Document): { filter: MeshoptFilter; bits?: number } {\n\tconst refs = doc\n\t\t.getGraph()\n\t\t.listParentEdges(accessor)\n\t\t.filter((edge) => !(edge.getParent() instanceof Root));\n\n\tfor (const ref of refs) {\n\t\tconst refName = ref.getName();\n\t\tconst refKey = (ref.getAttributes().key || '') as string;\n\t\tconst isDelta = ref.getParent().propertyType === PropertyType.PRIMITIVE_TARGET;\n\n\t\t// Indices.\n\t\tif (refName === 'indices') return { filter: MeshoptFilter.NONE };\n\n\t\t// Attributes.\n\t\t//\n\t\t// NOTES:\n\t\t// - Vertex attributes should be filtered IFF they are _not_ quantized in\n\t\t//   'packages/cli/src/transforms/meshopt.ts'.\n\t\t// - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken\n\t\t//   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual\n\t\t//   quantization for these attributes.\n\t\t// - NORMAL and TANGENT attributes use Octahedral filters, but deltas in morphs do not.\n\t\t// - When specifying bit depth for vertex attributes, check the defaults in `quantize.ts`\n\t\t//\t and overrides in `meshopt.ts`. Don't store deltas at higher precision than base.\n\t\tif (refName === 'attributes') {\n\t\t\tif (refKey === 'POSITION') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'TEXCOORD_0') return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey.startsWith('JOINTS_')) return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey.startsWith('WEIGHTS_')) return { filter: MeshoptFilter.NONE };\n\t\t\tif (refKey === 'NORMAL' || refKey === 'TANGENT') {\n\t\t\t\treturn isDelta ? { filter: MeshoptFilter.NONE } : { filter: MeshoptFilter.OCTAHEDRAL, bits: 8 };\n\t\t\t}\n\t\t}\n\n\t\t// Animation.\n\t\tif (refName === 'output') {\n\t\t\tconst targetPath = getTargetPath(accessor);\n\t\t\tif (targetPath === 'rotation') return { filter: MeshoptFilter.QUATERNION, bits: 16 };\n\t\t\tif (targetPath === 'translation') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\tif (targetPath === 'scale') return { filter: MeshoptFilter.EXPONENTIAL, bits: 12 };\n\t\t\treturn { filter: MeshoptFilter.NONE };\n\t\t}\n\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/489\n\t\tif (refName === 'input') return { filter: MeshoptFilter.NONE };\n\n\t\tif (refName === 'inverseBindMatrices') return { filter: MeshoptFilter.NONE };\n\t}\n\n\treturn { filter: MeshoptFilter.NONE };\n}\n\nexport function getTargetPath(accessor: Accessor): GLTF.AnimationChannelTargetPath | null {\n\tfor (const sampler of accessor.listParents()) {\n\t\tif (!(sampler instanceof AnimationSampler)) continue;\n\t\tfor (const channel of sampler.listParents()) {\n\t\t\tif (!(channel instanceof AnimationChannel)) continue;\n\t\t\treturn channel.getTargetPath();\n\t\t}\n\t}\n\treturn null;\n}\n", "import { EXT_MESHOPT_COMPRESSION } from '../constants.js';\nimport type { GLTF } from '@gltf-transform/core';\nimport type { MeshoptBufferExtension } from './constants.js';\n\n/**\n * Returns true for a fallback buffer, else false.\n *\n *   - All references to the fallback buffer must come from bufferViews that\n *     have a EXT_meshopt_compression extension specified.\n *   - No references to the fallback buffer may come from\n *     EXT_meshopt_compression extension JSON.\n */\nexport function isFallbackBuffer(bufferDef: GLTF.IBuffer): boolean {\n\tif (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;\n\tconst fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION] as MeshoptBufferExtension;\n\treturn !!fallbackDef.fallback;\n}\n", "import {\n\tAccessor,\n\tBuffer,\n\tBufferUtils,\n\tExtension,\n\tGLB_BUFFER,\n\tGLTF,\n\tProperty,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { EncoderMethod, MeshoptBufferViewExtension, MeshoptFilter } from './constants.js';\nimport { EXT_MESHOPT_COMPRESSION } from '../constants.js';\nimport { getMeshoptFilter, getMeshoptMode, getTargetPath, prepareAccessor } from './encoder.js';\nimport { isFallbackBuffer } from './decoder.js';\nimport type { MeshoptEncoder, MeshoptDecoder } from 'meshoptimizer';\n\nconst NAME = EXT_MESHOPT_COMPRESSION;\n\ninterface EncoderOptions {\n\tmethod?: EncoderMethod;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: Required<EncoderOptions> = {\n\tmethod: EncoderMethod.QUANTIZE,\n};\n\ntype MeshoptBufferView = { extensions: { [NAME]: MeshoptBufferViewExtension } };\ntype EncodedBufferView = GLTF.IBufferView & MeshoptBufferView;\n\n/**\n * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)\n * provides compression and fast decoding for geometry, morph targets, and animations.\n *\n * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)\n * library) offers a lightweight decoder with very fast runtime decompression, and is\n * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,\n * morph targets, animation, and other numeric data stored in buffer views. When textures are\n * large, other complementary compression methods should be used as well.\n *\n * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless\n * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically\n * pre-optimizes assets for this purpose  without this secondary compression, the size\n * reduction is considerably less.\n *\n * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is\n * considerably faster than Draco decoding, neither compression method will improve runtime\n * performance directly. To improve framerate, you'll need to simplify the geometry by reducing\n * vertex count or draw calls  not just compress it. Finally, be aware that Meshopt compression is\n * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),\n * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or\n * writing files, and must be provided by the application. Compression may alternatively be applied\n * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { reorder, quantize } from '@gltf-transform/functions';\n * import { EXTMeshoptCompression } from '@gltf-transform/extensions';\n * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';\n *\n * await MeshoptDecoder.ready;\n * await MeshoptEncoder.ready;\n *\n * const io = new NodeIO()\n *\t.registerExtensions([EXTMeshoptCompression])\n *\t.registerDependencies({\n *\t\t'meshopt.decoder': MeshoptDecoder,\n *\t\t'meshopt.encoder': MeshoptEncoder,\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode. (Medium, -c)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize()\n * );\n * document.createExtension(EXTMeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: EXTMeshoptCompression.EncoderMethod.QUANTIZE });\n * await io.write('compressed-medium.glb', document);\n *\n * // Write and encode. (High, -cc)\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder}),\n * \tquantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\\d+)?$/}),\n * );\n * document.createExtension(EXTMeshoptCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({ method: EXTMeshoptCompression.EncoderMethod.FILTER });\n * await io.write('compressed-high.glb', document);\n * ```\n */\nexport class EXTMeshoptCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['meshopt.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['meshopt.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoder: typeof MeshoptDecoder | null = null;\n\tprivate _decoderFallbackBufferMap = new Map<Buffer, Buffer>();\n\tprivate _encoder: typeof MeshoptEncoder | null = null;\n\tprivate _encoderOptions: Required<EncoderOptions> = DEFAULT_ENCODER_OPTIONS;\n\tprivate _encoderFallbackBuffer: Buffer | null = null;\n\tprivate _encoderBufferViews: { [key: string]: EncodedBufferView } = {};\n\tprivate _encoderBufferViewData: { [key: string]: Uint8Array[] } = {};\n\tprivate _encoderBufferViewAccessors: { [key: string]: GLTF.IAccessor[] } = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'meshopt.decoder') {\n\t\t\tthis._decoder = dependency as typeof MeshoptDecoder;\n\t\t}\n\t\tif (key === 'meshopt.encoder') {\n\t\t\tthis._encoder = dependency as typeof MeshoptEncoder;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures Meshopt options for quality/compression tuning. The two methods rely on different\n\t * pre-processing before compression, and should be compared on the basis of (a) quality/loss\n\t * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.\n\t *\n\t * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified\n\t * \tprecision) before applying lossless Meshopt compression. Offers a considerable compression\n\t * \tratio with or without further supercompression. Equivalent to `gltfpack -c`.\n\t * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless\n\t *\tMeshopt compression. While output may initially be larger than with the QUANTIZE method,\n\t *\tthis method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to\n\t * \t`gltfpack -cc`.\n\t *\n\t * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or\n\t * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast\n\t * with both methods.\n\t *\n\t * Example:\n\t *\n\t * ```ts\n\t * import { EXTMeshoptCompression } from '@gltf-transform/extensions';\n\t *\n\t * doc.createExtension(EXTMeshoptCompression)\n\t * \t.setRequired(true)\n\t * \t.setEncoderOptions({\n\t * \t\tmethod: EXTMeshoptCompression.EncoderMethod.QUANTIZE\n\t * \t});\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = { ...DEFAULT_ENCODER_OPTIONS, ...options };\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Decoding.\n\t */\n\n\t/** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */\n\tpublic preread(context: ReaderContext, propertyType: PropertyType): this {\n\t\tif (!this._decoder) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"meshopt.decoder\".`);\n\t\t}\n\t\tif (!this._decoder.supported) {\n\t\t\tif (!this.isRequired()) return this;\n\t\t\tthrow new Error(`[${NAME}]: Missing WASM support.`);\n\t\t}\n\n\t\tif (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prereadBuffers(context);\n\t\t} else if (propertyType === PropertyType.PRIMITIVE) {\n\t\t\tthis._prereadPrimitives(context);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @internal Decode buffer views. */\n\tprivate _prereadBuffers(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\t\tviewDefs.forEach((viewDef, index) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\t\t\tconst byteOffset = meshoptDef.byteOffset || 0;\n\t\t\tconst byteLength = meshoptDef.byteLength || 0;\n\t\t\tconst count = meshoptDef.count;\n\t\t\tconst stride = meshoptDef.byteStride;\n\t\t\tconst result = new Uint8Array(count * stride);\n\n\t\t\tconst bufferDef = jsonDoc.json.buffers![meshoptDef.buffer];\n\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\tconst resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];\n\t\t\tconst source = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\tthis._decoder!.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);\n\n\t\t\tcontext.bufferViews[index] = result;\n\t\t});\n\t}\n\n\t/**\n\t * Mark fallback buffers and replacements.\n\t *\n\t * Note: Alignment with primitives is arbitrary; this just needs to happen\n\t * after Buffers have been parsed.\n\t * @internal\n\t */\n\tprivate _prereadPrimitives(context: ReaderContext): void {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst viewDefs = jsonDoc.json.bufferViews || [];\n\n\t\t//\n\t\tviewDefs.forEach((viewDef) => {\n\t\t\tif (!viewDef.extensions || !viewDef.extensions[NAME]) return;\n\n\t\t\tconst meshoptDef = viewDef.extensions[NAME] as MeshoptBufferViewExtension;\n\n\t\t\tconst buffer = context.buffers[meshoptDef.buffer];\n\t\t\tconst fallbackBuffer = context.buffers[viewDef.buffer];\n\t\t\tconst fallbackBufferDef = jsonDoc.json.buffers![viewDef.buffer];\n\t\t\tif (isFallbackBuffer(fallbackBufferDef)) {\n\t\t\t\tthis._decoderFallbackBufferMap.set(fallbackBuffer, buffer);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @hidden Removes Fallback buffers, if extension is required. */\n\tpublic read(_context: ReaderContext): this {\n\t\tif (!this.isRequired()) return this;\n\n\t\t// Replace fallback buffers.\n\t\tfor (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {\n\t\t\tfor (const parent of fallbackBuffer.listParents()) {\n\t\t\t\tif (parent instanceof Accessor) {\n\t\t\t\t\tparent.swap(fallbackBuffer, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallbackBuffer.dispose();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**********************************************************************************************\n\t * Encoding.\n\t */\n\n\t/** @internal Claims accessors that can be compressed and writes compressed buffer views. */\n\tpublic prewrite(context: WriterContext, propertyType: PropertyType): this {\n\t\tif (propertyType === PropertyType.ACCESSOR) {\n\t\t\tthis._prewriteAccessors(context);\n\t\t} else if (propertyType === PropertyType.BUFFER) {\n\t\t\tthis._prewriteBuffers(context);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @internal Claims accessors that can be compressed. */\n\tprivate _prewriteAccessors(context: WriterContext): void {\n\t\tconst json = context.jsonDoc.json;\n\t\tconst encoder = this._encoder!;\n\t\tconst options = this._encoderOptions;\n\t\tconst graph = this.document.getGraph();\n\n\t\tconst fallbackBuffer = this.document.createBuffer(); // Disposed on write.\n\t\tconst fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);\n\n\t\tlet nextID = 1;\n\t\tconst parentToID = new Map<Property, number>();\n\t\tconst getParentID = (property: Property): number => {\n\t\t\tfor (const parent of graph.listParents(property)) {\n\t\t\t\tif (parent.propertyType === PropertyType.ROOT) continue;\n\t\t\t\tlet id = parentToID.get(property);\n\t\t\t\tif (id === undefined) parentToID.set(property, (id = nextID++));\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\tthis._encoderFallbackBuffer = fallbackBuffer;\n\t\tthis._encoderBufferViews = {};\n\t\tthis._encoderBufferViewData = {};\n\t\tthis._encoderBufferViewAccessors = {};\n\n\t\tfor (const accessor of this.document.getRoot().listAccessors()) {\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251\n\t\t\t// Example: https://skfb.ly/6qAD8\n\t\t\tif (getTargetPath(accessor) === 'weights') continue;\n\n\t\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/289\n\t\t\tif (accessor.getSparse()) continue;\n\n\t\t\tconst usage = context.getAccessorUsage(accessor);\n\t\t\tconst parentID = context.accessorUsageGroupedByParent.has(usage) ? getParentID(accessor) : null;\n\t\t\tconst mode = getMeshoptMode(accessor, usage);\n\t\t\tconst filter =\n\t\t\t\toptions.method === EncoderMethod.FILTER\n\t\t\t\t\t? getMeshoptFilter(accessor, this.document)\n\t\t\t\t\t: { filter: MeshoptFilter.NONE };\n\t\t\tconst preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);\n\t\t\tconst { array, byteStride } = preparedAccessor;\n\n\t\t\tconst buffer = accessor.getBuffer();\n\t\t\tif (!buffer) throw new Error(`${NAME}: Missing buffer for accessor.`);\n\t\t\tconst bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);\n\n\t\t\t// Buffer view grouping key.\n\t\t\tconst key = [usage, parentID, mode, filter.filter, byteStride, bufferIndex].join(':');\n\n\t\t\tlet bufferView = this._encoderBufferViews[key];\n\t\t\tlet bufferViewData = this._encoderBufferViewData[key];\n\t\t\tlet bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\n\t\t\t// Write new buffer view, if needed.\n\t\t\tif (!bufferView || !bufferViewData) {\n\t\t\t\tbufferViewAccessors = this._encoderBufferViewAccessors[key] = [];\n\t\t\t\tbufferViewData = this._encoderBufferViewData[key] = [];\n\t\t\t\tbufferView = this._encoderBufferViews[key] = {\n\t\t\t\t\tbuffer: fallbackBufferIndex,\n\t\t\t\t\ttarget: WriterContext.USAGE_TO_TARGET[usage],\n\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\tbyteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,\n\t\t\t\t\textensions: {\n\t\t\t\t\t\t[NAME]: {\n\t\t\t\t\t\t\tbuffer: bufferIndex,\n\t\t\t\t\t\t\tbyteOffset: 0,\n\t\t\t\t\t\t\tbyteLength: 0,\n\t\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\t\tfilter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,\n\t\t\t\t\t\t\tbyteStride: byteStride,\n\t\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Write accessor.\n\t\t\tconst accessorDef = context.createAccessorDef(accessor);\n\t\t\taccessorDef.componentType = preparedAccessor.componentType;\n\t\t\taccessorDef.normalized = preparedAccessor.normalized;\n\t\t\taccessorDef.byteOffset = bufferView.byteLength;\n\t\t\tif (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;\n\t\t\tif (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;\n\t\t\tcontext.accessorIndexMap.set(accessor, json.accessors!.length);\n\t\t\tjson.accessors!.push(accessorDef);\n\t\t\tbufferViewAccessors.push(accessorDef);\n\n\t\t\t// Update buffer view.\n\t\t\tbufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n\t\t\tbufferView.byteLength += array.byteLength;\n\t\t\tbufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();\n\t\t}\n\t}\n\n\t/** @internal Writes compressed buffer views. */\n\tprivate _prewriteBuffers(context: WriterContext): void {\n\t\tconst encoder = this._encoder!;\n\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key];\n\t\t\tconst buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME].buffer];\n\t\t\tconst otherBufferViews = context.otherBufferViews.get(buffer) || [];\n\n\t\t\tconst { count, byteStride, mode } = bufferView.extensions[NAME];\n\t\t\tconst srcArray = BufferUtils.concat(bufferViewData);\n\t\t\tconst dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);\n\t\t\tconst compressedData = BufferUtils.pad(dstArray);\n\n\t\t\tbufferView.extensions[NAME].byteLength = dstArray.byteLength;\n\n\t\t\tbufferViewData.length = 0;\n\t\t\tbufferViewData.push(compressedData);\n\t\t\totherBufferViews.push(compressedData);\n\t\t\tcontext.otherBufferViews.set(buffer, otherBufferViews);\n\t\t}\n\t}\n\n\t/** @hidden Puts encoded data into glTF output. */\n\tpublic write(context: WriterContext): this {\n\t\tlet fallbackBufferByteOffset = 0;\n\n\t\t// Write final encoded buffer view properties.\n\t\tfor (const key in this._encoderBufferViews) {\n\t\t\tconst bufferView = this._encoderBufferViews[key];\n\t\t\tconst bufferViewData = this._encoderBufferViewData[key][0];\n\t\t\tconst bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData)!;\n\n\t\t\tconst bufferViewAccessors = this._encoderBufferViewAccessors[key];\n\t\t\tfor (const accessorDef of bufferViewAccessors) {\n\t\t\t\taccessorDef.bufferView = bufferViewIndex;\n\t\t\t}\n\n\t\t\tconst finalBufferViewDef = context.jsonDoc.json.bufferViews![bufferViewIndex];\n\t\t\tconst compressedByteOffset = finalBufferViewDef.byteOffset || 0;\n\n\t\t\tObject.assign(finalBufferViewDef, bufferView);\n\t\t\tfinalBufferViewDef.byteOffset = fallbackBufferByteOffset;\n\t\t\tconst bufferViewExtensionDef = finalBufferViewDef.extensions![NAME] as MeshoptBufferViewExtension;\n\t\t\tbufferViewExtensionDef.byteOffset = compressedByteOffset;\n\n\t\t\tfallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);\n\t\t}\n\n\t\t// Write final fallback buffer.\n\t\tconst fallbackBuffer = this._encoderFallbackBuffer!;\n\t\tconst fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer)!;\n\t\tconst fallbackBufferDef = context.jsonDoc.json.buffers![fallbackBufferIndex];\n\t\tfallbackBufferDef.byteLength = fallbackBufferByteOffset;\n\t\tfallbackBufferDef.extensions = { [NAME]: { fallback: true } };\n\t\tfallbackBuffer.dispose();\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n\tBufferUtils,\n} from '@gltf-transform/core';\nimport { EXT_TEXTURE_AVIF } from '../constants.js';\n\nconst NAME = EXT_TEXTURE_AVIF;\n\nclass AVIFImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 12 && BufferUtils.decodeText(array.slice(4, 12)) === 'ftypavif';\n\t}\n\t/**\n\t * Probes size of AVIF or HEIC image. Assumes a single static image, without\n\t * orientation or other metadata that would affect dimensions.\n\t */\n\tgetSize(array: Uint8Array): vec2 | null {\n\t\tif (!this.match(array)) return null;\n\n\t\t// References:\n\t\t// - https://stackoverflow.com/questions/66222773/how-to-get-image-dimensions-from-an-avif-file\n\t\t// - https://github.com/nodeca/probe-image-size/blob/master/lib/parse_sync/avif.js\n\n\t\tconst view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n\n\t\tlet box = unbox(view, 0);\n\t\tif (!box) return null;\n\n\t\tlet offset = box.end;\n\t\twhile ((box = unbox(view, offset))) {\n\t\t\tif (box.type === 'meta') {\n\t\t\t\toffset = box.start + 4; // version + flags\n\t\t\t} else if (box.type === 'iprp' || box.type === 'ipco') {\n\t\t\t\toffset = box.start;\n\t\t\t} else if (box.type === 'ispe') {\n\t\t\t\treturn [view.getUint32(box.start + 4), view.getUint32(box.start + 8)];\n\t\t\t} else if (box.type === 'mdat') {\n\t\t\t\tbreak; // mdat should be last, unlikely to find metadata past here.\n\t\t\t} else {\n\t\t\t\toffset = box.end;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * [`EXT_texture_avif`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif/)\n * enables AVIF images for any material texture.\n *\n * AVIF offers greatly reduced transmission size, but\n * [requires browser support](https://caniuse.com/avif). Like PNG and JPEG, an AVIF image is\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\n * like Basis Universal, with the `KHR_texture_basisu` extension.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/avif` MIME type\n * and passing AVIF image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { TextureAVIF } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const avifExtension = document.createExtension(TextureAVIF)\n * \t.setRequired(true);\n * document.createTexture('MyAVIFTexture')\n * \t.setMimeType('image/avif')\n * \t.setImage(fs.readFileSync('my-texture.avif'));\n * ```\n *\n * AVIF conversion is not done automatically when adding the extension as shown above  you must\n * convert the image data first, then pass the `.avif` payload to {@link Texture.setImage}.\n *\n * When the `EXT_texture_avif` extension is added to a file by glTF-Transform, the extension should\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\n * JPEG image data.\n */\nexport class EXTTextureAVIF extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/avif', new AVIFImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\n\t\ttextureDefs.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/avif') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n\ninterface IBox {\n\ttype: string;\n\tstart: number;\n\tend: number;\n}\n\nfunction unbox(data: DataView, offset: number): IBox | null {\n\tif (data.byteLength < 4 + offset) return null;\n\n\t// size includes first 4 bytes (length)\n\tconst size = data.getUint32(offset);\n\tif (data.byteLength < size + offset || size < 8) return null;\n\n\treturn {\n\t\ttype: BufferUtils.decodeText(new Uint8Array(data.buffer, data.byteOffset + offset + 4, 4)),\n\t\tstart: offset + 8,\n\t\tend: offset + size,\n\t};\n}\n", "import {\n\tBufferUtils,\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { EXT_TEXTURE_WEBP } from '../constants.js';\n\nconst NAME = EXT_TEXTURE_WEBP;\n\nclass WEBPImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;\n\t}\n\tgetSize(array: Uint8Array): vec2 | null {\n\t\t// Reference: http://tools.ietf.org/html/rfc6386\n\t\tconst RIFF = BufferUtils.decodeText(array.slice(0, 4));\n\t\tconst WEBP = BufferUtils.decodeText(array.slice(8, 12));\n\t\tif (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;\n\n\t\tconst view = new DataView(array.buffer, array.byteOffset);\n\n\t\t// Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions\n\t\tlet offset = 12;\n\t\twhile (offset < view.byteLength) {\n\t\t\tconst chunkId = BufferUtils.decodeText(\n\t\t\t\tnew Uint8Array([\n\t\t\t\t\tview.getUint8(offset),\n\t\t\t\t\tview.getUint8(offset + 1),\n\t\t\t\t\tview.getUint8(offset + 2),\n\t\t\t\t\tview.getUint8(offset + 3),\n\t\t\t\t]),\n\t\t\t);\n\t\t\tconst chunkByteLength = view.getUint32(offset + 4, true);\n\t\t\tif (chunkId === 'VP8 ') {\n\t\t\t\tconst width = view.getInt16(offset + 14, true) & 0x3fff;\n\t\t\t\tconst height = view.getInt16(offset + 16, true) & 0x3fff;\n\t\t\t\treturn [width, height];\n\t\t\t} else if (chunkId === 'VP8L') {\n\t\t\t\tconst b0 = view.getUint8(offset + 9);\n\t\t\t\tconst b1 = view.getUint8(offset + 10);\n\t\t\t\tconst b2 = view.getUint8(offset + 11);\n\t\t\t\tconst b3 = view.getUint8(offset + 12);\n\t\t\t\tconst width = 1 + (((b1 & 0x3f) << 8) | b0);\n\t\t\t\tconst height = 1 + (((b3 & 0xf) << 10) | (b2 << 2) | ((b1 & 0xc0) >> 6));\n\t\t\t\treturn [width, height];\n\t\t\t}\n\t\t\toffset += 8 + chunkByteLength + (chunkByteLength % 2);\n\t\t}\n\n\t\treturn null;\n\t}\n\tgetChannels(_buffer: Uint8Array): number {\n\t\treturn 4;\n\t}\n}\n\n/**\n * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)\n * enables WebP images for any material texture.\n *\n * WebP offers greatly reduced transmission size, but\n * [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is\n * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.\n * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format\n * like Basis Universal, with the `KHR_texture_basisu` extension.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type\n * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { EXTTextureWebP } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const webpExtension = document.createExtension(EXTTextureWebP)\n * \t.setRequired(true);\n * document.createTexture('MyWebPTexture')\n * \t.setMimeType('image/webp')\n * \t.setImage(fs.readFileSync('my-texture.webp'));\n * ```\n *\n * WebP conversion is not done automatically when adding the extension as shown above  you must\n * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.\n *\n * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should\n * always be required. This tool does not support writing assets that \"fall back\" to optional PNG or\n * JPEG image data.\n */\nexport class EXTTextureWebP extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/webp', new WEBPImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst textureDefs = context.jsonDoc.json.textures || [];\n\t\ttextureDefs.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\ttextureDef.source = (textureDef.extensions[NAME] as { source: number }).source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/webp') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\t\t\t\ttextureDefs.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { Accessor, GLTF, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants.js';\nimport type { Attribute, DataType, Decoder, DecoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\nexport let decoderModule: DecoderModule;\n\n// Initialized when decoder module loads.\nlet COMPONENT_ARRAY: { [key: number]: TypedArrayConstructor };\nlet DATA_TYPE: { [key: number]: DataType };\n\nexport function decodeGeometry(decoder: Decoder, data: Uint8Array): Mesh {\n\tconst buffer = new decoderModule.DecoderBuffer();\n\ttry {\n\t\tbuffer.Init(data as unknown as Int8Array, data.length);\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\tif (geometryType !== decoderModule.TRIANGULAR_MESH) {\n\t\t\tthrow new Error(`[${NAME}] Unknown geometry type.`);\n\t\t}\n\n\t\tconst dracoMesh = new decoderModule.Mesh();\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, dracoMesh);\n\n\t\tif (!status.ok() || dracoMesh.ptr === 0) {\n\t\t\tthrow new Error(`[${NAME}] Decoding failure.`);\n\t\t}\n\n\t\treturn dracoMesh;\n\t} finally {\n\t\tdecoderModule.destroy(buffer);\n\t}\n}\n\nexport function decodeIndex(decoder: Decoder, mesh: Mesh): Uint16Array | Uint32Array {\n\tconst numFaces = mesh.num_faces();\n\tconst numIndices = numFaces * 3;\n\n\tlet ptr: number;\n\tlet indices: Uint16Array | Uint32Array;\n\n\tif (mesh.num_points() <= 65534) {\n\t\tconst byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);\n\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t} else {\n\t\tconst byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;\n\t\tptr = decoderModule._malloc(byteLength);\n\t\tdecoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t}\n\n\tdecoderModule._free(ptr);\n\n\treturn indices;\n}\n\nexport function decodeAttribute(\n\tdecoder: Decoder,\n\tmesh: Mesh,\n\tattribute: Attribute,\n\taccessorDef: GLTF.IAccessor,\n): TypedArray {\n\tconst dataType = DATA_TYPE[accessorDef.componentType];\n\tconst ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];\n\tconst numComponents = attribute.num_components();\n\tconst numPoints = mesh.num_points();\n\tconst numValues = numPoints * numComponents;\n\tconst byteLength: number = numValues * ArrayCtor.BYTES_PER_ELEMENT;\n\n\tconst ptr = decoderModule._malloc(byteLength);\n\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);\n\tconst array: TypedArray = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\tdecoderModule._free(ptr);\n\n\treturn array;\n}\n\nexport function initDecoderModule(_decoderModule: DecoderModule): void {\n\tdecoderModule = _decoderModule;\n\n\tCOMPONENT_ARRAY = {\n\t\t[Accessor.ComponentType.FLOAT]: Float32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,\n\t\t[Accessor.ComponentType.SHORT]: Int16Array,\n\t\t[Accessor.ComponentType.BYTE]: Int8Array,\n\t};\n\n\tDATA_TYPE = {\n\t\t[Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,\n\t\t[Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,\n\t\t[Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,\n\t\t[Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,\n\t\t[Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,\n\t\t[Accessor.ComponentType.BYTE]: decoderModule.DT_INT8,\n\t};\n}\n", "import { Accessor, bbox, GLTF, Primitive, TypedArray } from '@gltf-transform/core';\nimport type { EncoderModule, Mesh, MeshBuilder } from 'draco3dgltf';\n\nexport let encoderModule: EncoderModule;\n\nexport enum EncoderMethod {\n\tEDGEBREAKER = 1,\n\tSEQUENTIAL = 0,\n}\n\nenum AttributeEnum {\n\tPOSITION = 'POSITION',\n\tNORMAL = 'NORMAL',\n\tCOLOR = 'COLOR',\n\tTEX_COORD = 'TEX_COORD',\n\tGENERIC = 'GENERIC',\n}\n\nconst DEFAULT_QUANTIZATION_BITS = {\n\t[AttributeEnum.POSITION]: 14,\n\t[AttributeEnum.NORMAL]: 10,\n\t[AttributeEnum.COLOR]: 8,\n\t[AttributeEnum.TEX_COORD]: 12,\n\t[AttributeEnum.GENERIC]: 12,\n};\n\nexport interface EncodedPrimitive {\n\tnumVertices: number;\n\tnumIndices: number;\n\tdata: Uint8Array;\n\tattributeIDs: { [key: string]: number };\n}\n\nexport interface EncoderOptions {\n\tdecodeSpeed?: number;\n\tencodeSpeed?: number;\n\tmethod?: EncoderMethod;\n\tquantizationBits?: { [key: string]: number };\n\tquantizationVolume?: 'mesh' | 'scene' | bbox;\n}\n\nconst DEFAULT_ENCODER_OPTIONS: EncoderOptions = {\n\tdecodeSpeed: 5,\n\tencodeSpeed: 5,\n\tmethod: EncoderMethod.EDGEBREAKER,\n\tquantizationBits: DEFAULT_QUANTIZATION_BITS,\n\tquantizationVolume: 'mesh',\n};\n\nexport function initEncoderModule(_encoderModule: EncoderModule): void {\n\tencoderModule = _encoderModule;\n}\n\n/**\n * References:\n * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js\n * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js\n */\nexport function encodeGeometry(prim: Primitive, _options: EncoderOptions = DEFAULT_ENCODER_OPTIONS): EncodedPrimitive {\n\tconst options = { ...DEFAULT_ENCODER_OPTIONS, ..._options } as Required<EncoderOptions>;\n\toptions.quantizationBits = { ...DEFAULT_QUANTIZATION_BITS, ..._options.quantizationBits };\n\n\tconst builder = new encoderModule.MeshBuilder();\n\tconst mesh = new encoderModule.Mesh();\n\n\tconst encoder = new encoderModule.ExpertEncoder(mesh);\n\n\tconst attributeIDs: { [key: string]: number } = {};\n\tconst dracoBuffer = new encoderModule.DracoInt8Array();\n\n\tconst hasMorphTargets = prim.listTargets().length > 0;\n\tlet hasSparseAttributes = false;\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\n\t\tif (attribute.getSparse()) {\n\t\t\thasSparseAttributes = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst attributeEnum = getAttributeEnum(semantic);\n\t\tconst attributeID: number = addAttribute(\n\t\t\tbuilder,\n\t\t\tattribute.getComponentType(),\n\t\t\tmesh,\n\t\t\tencoderModule[attributeEnum],\n\t\t\tattribute.getCount(),\n\t\t\tattribute.getElementSize(),\n\t\t\tattribute.getArray()!,\n\t\t);\n\n\t\tif (attributeID === -1) throw new Error(`Error compressing \"${semantic}\" attribute.`);\n\n\t\tattributeIDs[semantic] = attributeID;\n\t\tif (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {\n\t\t\tencoder.SetAttributeQuantization(attributeID, options.quantizationBits[attributeEnum]);\n\t\t} else if (typeof options.quantizationVolume === 'object') {\n\t\t\tconst { quantizationVolume } = options;\n\t\t\tconst range = Math.max(\n\t\t\t\tquantizationVolume.max[0] - quantizationVolume.min[0],\n\t\t\t\tquantizationVolume.max[1] - quantizationVolume.min[1],\n\t\t\t\tquantizationVolume.max[2] - quantizationVolume.min[2],\n\t\t\t);\n\t\t\tencoder.SetAttributeExplicitQuantization(\n\t\t\t\tattributeID,\n\t\t\t\toptions.quantizationBits[attributeEnum],\n\t\t\t\tattribute.getElementSize(),\n\t\t\t\tquantizationVolume.min,\n\t\t\t\trange,\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error('Invalid quantization volume state.');\n\t\t}\n\t}\n\n\tconst indices = prim.getIndices();\n\tif (!indices) throw new EncodingError('Primitive must have indices.');\n\n\tbuilder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray() as unknown as Uint32Array);\n\n\tencoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\n\tencoder.SetTrackEncodedProperties(true);\n\n\t// TODO(cleanup): Use edgebreaker without deduplication if possible.\n\t// See https://github.com/google/draco/issues/929.\n\tif (options.method === EncoderMethod.SEQUENTIAL || hasMorphTargets || hasSparseAttributes) {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);\n\t} else {\n\t\tencoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);\n\t}\n\n\t// Encode, preserving vertex order for primitives with morph targets and sparse accessors.\n\tconst byteLength = encoder.EncodeToDracoBuffer(!(hasMorphTargets || hasSparseAttributes), dracoBuffer);\n\tif (byteLength <= 0) throw new EncodingError('Error applying Draco compression.');\n\n\tconst data = new Uint8Array(byteLength);\n\tfor (let i = 0; i < byteLength; ++i) {\n\t\tdata[i] = dracoBuffer.GetValue(i);\n\t}\n\n\tconst numVertices = encoder.GetNumberOfEncodedPoints();\n\tconst numIndices = encoder.GetNumberOfEncodedFaces() * 3;\n\n\tencoderModule.destroy(dracoBuffer);\n\tencoderModule.destroy(mesh);\n\tencoderModule.destroy(builder);\n\tencoderModule.destroy(encoder);\n\n\treturn { numVertices, numIndices, data, attributeIDs };\n}\n\nfunction getAttributeEnum(semantic: string): AttributeEnum {\n\tif (semantic === 'POSITION') {\n\t\treturn AttributeEnum.POSITION;\n\t} else if (semantic === 'NORMAL') {\n\t\treturn AttributeEnum.NORMAL;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\treturn AttributeEnum.COLOR;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\treturn AttributeEnum.TEX_COORD;\n\t}\n\treturn AttributeEnum.GENERIC;\n}\n\nfunction addAttribute(\n\tbuilder: MeshBuilder,\n\tcomponentType: GLTF.AccessorComponentType,\n\tmesh: Mesh,\n\tattribute: number,\n\tcount: number,\n\titemSize: number,\n\tarray: TypedArray,\n): number {\n\tswitch (componentType) {\n\t\tcase Accessor.ComponentType.UNSIGNED_BYTE:\n\t\t\treturn builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.BYTE:\n\t\t\treturn builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_SHORT:\n\t\t\treturn builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.SHORT:\n\t\t\treturn builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.UNSIGNED_INT:\n\t\t\treturn builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);\n\t\tcase Accessor.ComponentType.FLOAT:\n\t\t\treturn builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);\n\t\tdefault:\n\t\t\tthrow new Error(`Unexpected component type, \"${componentType}\".`);\n\t}\n}\n\nexport class EncodingError extends Error {}\n", "import {\n\tAccessor,\n\tbbox,\n\tgetBounds,\n\tBufferUtils,\n\tDocument,\n\tExtension,\n\tGLB_BUFFER,\n\tPrimitive,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { decodeAttribute, decodeGeometry, decodeIndex, initDecoderModule } from './decoder.js';\nimport {\n\tEncodedPrimitive,\n\tencodeGeometry,\n\tEncoderMethod,\n\tEncoderOptions,\n\tEncodingError,\n\tinitEncoderModule,\n} from './encoder.js';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../constants.js';\nimport type { Decoder, DecoderModule, EncoderModule, Mesh } from 'draco3dgltf';\n\nconst NAME = KHR_DRACO_MESH_COMPRESSION;\n\ninterface DracoPrimitiveExtension {\n\tbufferView: number;\n\tattributes: {\n\t\t[name: string]: number;\n\t};\n}\n\ninterface DracoWriterContext {\n\tprimitiveHashMap: Map<Primitive, string>;\n\tprimitiveEncodingMap: Map<string, EncodedPrimitive>;\n}\n\n/**\n * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)\n * provides advanced compression for mesh geometry.\n *\n * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%\n * in many cases. When animation or textures are large, other complementary compression methods\n * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh\n * size savings.\n *\n * Be aware that decompression happens before uploading to the GPU  this will add some latency to\n * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime\n * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count\n * or draw calls  not just compress it. Finally, be aware that Draco compression is lossy:\n * repeatedly compressing and decompressing a model in a pipeline will lose precision, so\n * compression should generally be the last stage of an art workflow, and uncompressed original\n * files should be kept.\n *\n * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or\n * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,\n * and must be provided by the application.\n *\n * ### Encoding options\n *\n * Two compression methods are available: 'edgebreaker' and 'sequential'. The\n * edgebreaker method will give higher compression in general, but changes the\n * order of the model's vertices. To preserve index order, use sequential\n * compression. When a mesh uses morph targets, or a high decoding speed is\n * selected, sequential compression will automatically be chosen.\n *\n * Both speed options affect the encoder's choice of algorithms. For example, a\n * requirement for fast decoding may prevent the encoder from using the best\n * compression methods even if the encoding speed is set to 0. In general, the\n * faster of the two options limits the choice of features that can be used by the\n * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow\n * the encoder to choose the optimal method out of the available features for the\n * given --decodeSpeed.\n *\n * ### Example\n *\n * ```typescript\n * import { NodeIO } from '@gltf-transform/core';\n * import { KHRDracoMeshCompression } from '@gltf-transform/extensions';\n *\n * import draco3d from 'draco3dgltf';\n *\n * // ...\n *\n * const io = new NodeIO()\n *\t.registerExtensions([KHRDracoMeshCompression])\n *\t.registerDependencies({\n *\t\t'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.\n *\t\t'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.\n *\t});\n *\n * // Read and decode.\n * const document = await io.read('compressed.glb');\n *\n * // Write and encode.\n * document.createExtension(KHRDracoMeshCompression)\n * \t.setRequired(true)\n * \t.setEncoderOptions({\n * \t\tmethod: KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER,\n * \t\tencodeSpeed: 5,\n * \t\tdecodeSpeed: 5,\n * \t});\n * await io.write('compressed.glb', document);\n * ```\n */\nexport class KHRDracoMeshCompression extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.PRIMITIVE];\n\t/** @hidden */\n\tpublic readonly prewriteTypes = [PropertyType.ACCESSOR];\n\t/** @hidden */\n\tpublic readonly readDependencies = ['draco3d.decoder'];\n\t/** @hidden */\n\tpublic readonly writeDependencies = ['draco3d.encoder'];\n\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/**\n\t * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,\n\t * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.\n\t */\n\tpublic static readonly EncoderMethod = EncoderMethod;\n\n\tprivate _decoderModule: DecoderModule | null = null;\n\tprivate _encoderModule: EncoderModule | null = null;\n\tprivate _encoderOptions: EncoderOptions = {};\n\n\t/** @hidden */\n\tpublic install(key: string, dependency: unknown): this {\n\t\tif (key === 'draco3d.decoder') {\n\t\t\tthis._decoderModule = dependency as DecoderModule;\n\t\t\tinitDecoderModule(this._decoderModule);\n\t\t}\n\t\tif (key === 'draco3d.encoder') {\n\t\t\tthis._encoderModule = dependency as EncoderModule;\n\t\t\tinitEncoderModule(this._encoderModule);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets Draco compression options. Compression does not take effect until the Document is\n\t * written with an I/O class.\n\t *\n\t * Defaults:\n\t * ```\n\t * decodeSpeed?: number = 5;\n\t * encodeSpeed?: number = 5;\n\t * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;\n\t * quantizationBits?: {[ATTRIBUTE_NAME]: bits};\n\t * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';\n\t * ```\n\t */\n\tpublic setEncoderOptions(options: EncoderOptions): this {\n\t\tthis._encoderOptions = options;\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tif (!this._decoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.decoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst dracoMeshes: Map<number, [Decoder, Mesh]> = new Map();\n\n\t\ttry {\n\t\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\t\tfor (const meshDef of meshDefs) {\n\t\t\t\tfor (const primDef of meshDef.primitives) {\n\t\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) continue;\n\n\t\t\t\t\tconst dracoDef = primDef.extensions[NAME] as DracoPrimitiveExtension;\n\t\t\t\t\tlet [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];\n\n\t\t\t\t\tif (!dracoMesh || !decoder) {\n\t\t\t\t\t\tconst bufferViewDef = jsonDoc.json.bufferViews![dracoDef.bufferView];\n\t\t\t\t\t\tconst bufferDef = jsonDoc.json.buffers![bufferViewDef.buffer];\n\t\t\t\t\t\t// TODO(cleanup): Should be encapsulated in writer-context.ts.\n\t\t\t\t\t\tconst resource = bufferDef.uri\n\t\t\t\t\t\t\t? jsonDoc.resources[bufferDef.uri]\n\t\t\t\t\t\t\t: jsonDoc.resources[GLB_BUFFER];\n\n\t\t\t\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\t\t\tconst byteLength = bufferViewDef.byteLength;\n\t\t\t\t\t\tconst compressedData = BufferUtils.toView(resource, byteOffset, byteLength);\n\n\t\t\t\t\t\tdecoder = new this._decoderModule.Decoder();\n\t\t\t\t\t\tdracoMesh = decodeGeometry(decoder, compressedData);\n\t\t\t\t\t\tdracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);\n\t\t\t\t\t\tlogger.debug(`[${NAME}] Decompressed ${compressedData.byteLength} bytes.`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attributes.\n\t\t\t\t\tfor (const semantic in primDef.attributes) {\n\t\t\t\t\t\tconst accessorDef = context.jsonDoc.json.accessors![primDef.attributes[semantic]];\n\t\t\t\t\t\tconst dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);\n\t\t\t\t\t\tconst attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);\n\t\t\t\t\t\tcontext.accessors[primDef.attributes[semantic]].setArray(attributeArray);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Indices. Optional, see https://github.com/google/draco/issues/720.\n\t\t\t\t\tif (primDef.indices !== undefined) {\n\t\t\t\t\t\tcontext.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tfor (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {\n\t\t\t\tthis._decoderModule.destroy(decoder);\n\t\t\t\tthis._decoderModule.destroy(dracoMesh);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext, _propertyType: PropertyType): this {\n\t\tif (!this._encoderModule) {\n\t\t\tthrow new Error(`[${NAME}] Please install extension dependency, \"draco3d.encoder\".`);\n\t\t}\n\n\t\tconst logger = this.document.getLogger();\n\t\tlogger.debug(`[${NAME}] Compression options: ${JSON.stringify(this._encoderOptions)}`);\n\n\t\tconst primitiveHashMap = listDracoPrimitives(this.document);\n\t\tconst primitiveEncodingMap = new Map<string, EncodedPrimitive>();\n\n\t\tlet quantizationVolume: bbox | 'mesh' = 'mesh';\n\t\tif (this._encoderOptions.quantizationVolume === 'scene') {\n\t\t\tif (this.document.getRoot().listScenes().length !== 1) {\n\t\t\t\tlogger.warn(`[${NAME}]: quantizationVolume=scene requires exactly 1 scene.`);\n\t\t\t} else {\n\t\t\t\tquantizationVolume = getBounds(this.document.getRoot().listScenes().pop()!);\n\t\t\t}\n\t\t}\n\n\t\tfor (const prim of Array.from(primitiveHashMap.keys())) {\n\t\t\tconst primHash = primitiveHashMap.get(prim);\n\t\t\tif (!primHash) throw new Error('Unexpected primitive.');\n\n\t\t\t// Reuse an existing EncodedPrimitive, if possible.\n\t\t\tif (primitiveEncodingMap.has(primHash)) {\n\t\t\t\tprimitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash)!);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst indices = prim.getIndices()!; // Condition for listDracoPrimitives().\n\t\t\tconst accessorDefs = context.jsonDoc.json.accessors!;\n\n\t\t\t// Create a new EncodedPrimitive.\n\t\t\tlet encodedPrim: EncodedPrimitive;\n\t\t\ttry {\n\t\t\t\tencodedPrim = encodeGeometry(prim, { ...this._encoderOptions, quantizationVolume });\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof EncodingError) {\n\t\t\t\t\tlogger.warn(`[${NAME}]: ${e.message} Skipping primitive compression.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tprimitiveEncodingMap.set(primHash, encodedPrim);\n\n\t\t\t// Create indices definition, update count.\n\t\t\tconst indicesDef = context.createAccessorDef(indices);\n\t\t\tindicesDef.count = encodedPrim.numIndices;\n\t\t\tcontext.accessorIndexMap.set(indices, accessorDefs.length);\n\t\t\taccessorDefs.push(indicesDef);\n\n\t\t\t// In rare cases Draco increases vertex count, requiring a larger index component type.\n\t\t\t// https://github.com/donmccurdy/glTF-Transform/issues/1370\n\t\t\tif (encodedPrim.numVertices > 65534 && indicesDef.componentType !== Accessor.ComponentType.UNSIGNED_INT) {\n\t\t\t\tindicesDef.componentType = Accessor.ComponentType.UNSIGNED_INT;\n\t\t\t}\n\n\t\t\t// Create attribute definitions, update count.\n\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\tif (encodedPrim.attributeIDs[semantic] === undefined) continue; // sparse\n\n\t\t\t\tconst attributeDef = context.createAccessorDef(attribute);\n\t\t\t\tattributeDef.count = encodedPrim.numVertices;\n\t\t\t\tcontext.accessorIndexMap.set(attribute, accessorDefs.length);\n\t\t\t\taccessorDefs.push(attributeDef);\n\t\t\t}\n\n\t\t\t// Map compressed buffer view to a Buffer.\n\t\t\tconst buffer = prim.getAttribute('POSITION')!.getBuffer() || this.document.getRoot().listBuffers()[0];\n\t\t\tif (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);\n\t\t\tcontext.otherBufferViews.get(buffer)!.push(encodedPrim.data);\n\t\t}\n\n\t\tlogger.debug(`[${NAME}] Compressed ${primitiveHashMap.size} primitives.`);\n\n\t\tcontext.extensionData[NAME] = {\n\t\t\tprimitiveHashMap,\n\t\t\tprimitiveEncodingMap,\n\t\t} as DracoWriterContext;\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst dracoContext: DracoWriterContext = context.extensionData[NAME] as DracoWriterContext;\n\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshDef = context.jsonDoc.json.meshes![context.meshIndexMap.get(mesh)!];\n\t\t\tfor (let i = 0; i < mesh.listPrimitives().length; i++) {\n\t\t\t\tconst prim = mesh.listPrimitives()[i];\n\t\t\t\tconst primDef = meshDef.primitives[i];\n\n\t\t\t\tconst primHash = dracoContext.primitiveHashMap.get(prim);\n\t\t\t\tif (!primHash) continue;\n\n\t\t\t\tconst encodedPrim = dracoContext.primitiveEncodingMap.get(primHash)!;\n\t\t\t\tif (!encodedPrim) continue;\n\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = {\n\t\t\t\t\tbufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),\n\t\t\t\t\tattributes: encodedPrim.attributeIDs,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Omit the extension if nothing was compressed.\n\t\tif (!dracoContext.primitiveHashMap.size) {\n\t\t\tconst json = context.jsonDoc.json;\n\t\t\tjson.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== NAME);\n\t\t\tjson.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== NAME);\n\t\t}\n\n\t\treturn this;\n\t}\n}\n\n/**\n * Returns a list of Primitives compatible with Draco compression. If any required preconditions\n * fail, and would break assumptions required for compression, this function will throw an error.\n */\nfunction listDracoPrimitives(doc: Document): Map<Primitive, string> {\n\tconst logger = doc.getLogger();\n\tconst included = new Set<Primitive>();\n\tconst excluded = new Set<Primitive>();\n\n\tlet nonIndexed = 0;\n\tlet nonTriangles = 0;\n\n\t// Support compressing only indexed, mode=TRIANGLES primitives.\n\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tif (!prim.getIndices()) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tnonIndexed++;\n\t\t\t} else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {\n\t\t\t\texcluded.add(prim);\n\t\t\t\tnonTriangles++;\n\t\t\t} else {\n\t\t\t\tincluded.add(prim);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nonIndexed > 0) {\n\t\tlogger.warn(`[${NAME}] Skipping Draco compression of ${nonIndexed} non-indexed primitives.`);\n\t}\n\tif (nonTriangles > 0) {\n\t\tlogger.warn(`[${NAME}] Skipping Draco compression of ${nonTriangles} non-TRIANGLES primitives.`);\n\t}\n\n\t// Create an Accessor->index mapping.\n\tconst accessors = doc.getRoot().listAccessors();\n\tconst accessorIndices = new Map<Accessor, number>();\n\tfor (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);\n\n\t// For each compressed Primitive, create a hash key identifying its accessors. Map each\n\t// compressed Primitive and Accessor to this hash key.\n\tconst includedAccessors = new Map<Accessor, string>();\n\tconst includedHashKeys = new Set<string>();\n\tconst primToHashKey = new Map<Primitive, string>();\n\tfor (const prim of Array.from(included)) {\n\t\tlet hashKey = createHashKey(prim, accessorIndices);\n\n\t\t// If accessors of an identical primitive have already been checked, we're done.\n\t\tif (includedHashKeys.has(hashKey)) {\n\t\t\tprimToHashKey.set(prim, hashKey);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If any accessors are already in use, but the same hashKey hasn't been written, then we\n\t\t// need to create copies of these accessors for the current encoded primitive. We can't\n\t\t// reuse the same compressed accessor for two encoded primitives, because Draco might\n\t\t// change the vertex count, change the vertex order, or cause other conflicts.\n\t\tif (includedAccessors.has(prim.getIndices()!)) {\n\t\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\t\tconst dstIndices = indices.clone();\n\t\t\taccessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);\n\t\t\tprim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.\n\t\t}\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tif (includedAccessors.has(attribute)) {\n\t\t\t\tconst dstAttribute = attribute.clone();\n\t\t\t\taccessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);\n\t\t\t\tprim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.\n\t\t\t}\n\t\t}\n\n\t\t// With conflicts resolved, compute the hash key again.\n\t\thashKey = createHashKey(prim, accessorIndices);\n\n\t\t// Commit the primitive and its accessors to the hash key.\n\t\tincludedHashKeys.add(hashKey);\n\t\tprimToHashKey.set(prim, hashKey);\n\t\tincludedAccessors.set(prim.getIndices()!, hashKey);\n\t\tfor (const attribute of prim.listAttributes()) {\n\t\t\tincludedAccessors.set(attribute, hashKey);\n\t\t}\n\t}\n\n\t// For each compressed Accessor, ensure that it isn't used except by a Primitive.\n\tfor (const accessor of Array.from(includedAccessors.keys())) {\n\t\tconst parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));\n\t\tif (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {\n\t\t\tthrow new Error(`[${NAME}] Compressed accessors must only be used as indices or vertex attributes.`);\n\t\t}\n\t}\n\n\t// For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.\n\tfor (const prim of Array.from(included)) {\n\t\tconst hashKey = primToHashKey.get(prim);\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (\n\t\t\tincludedAccessors.get(indices) !== hashKey ||\n\t\t\tprim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)\n\t\t) {\n\t\t\tthrow new Error(`[${NAME}] Draco primitives must share all, or no, accessors.`);\n\t\t}\n\t}\n\n\t// For each excluded Primitive, ensure that no Accessors are compressed.\n\tfor (const prim of Array.from(excluded)) {\n\t\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\t\tif (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {\n\t\t\tthrow new Error(`[${NAME}] Accessor cannot be shared by compressed and uncompressed primitives.`);\n\t\t}\n\t}\n\n\treturn primToHashKey;\n}\n\nfunction createHashKey(prim: Primitive, indexMap: Map<Accessor, number>): string {\n\tconst hashElements = [];\n\tconst indices = prim.getIndices()!; // Condition for 'included' list.\n\n\thashElements.push(indexMap.get(indices));\n\tfor (const attribute of prim.listAttributes()) {\n\t\thashElements.push(indexMap.get(attribute));\n\t}\n\n\treturn hashElements.sort().join('|');\n}\n", "import { ExtensionProperty, IProperty, Nullable, PropertyType, vec3 } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants.js';\n\ninterface ILight extends IProperty {\n\tcolor: vec3;\n\tintensity: number;\n\ttype: PunctualLightType;\n\trange: number | null;\n\tinnerConeAngle: number;\n\touterConeAngle: number;\n}\n\ntype PunctualLightType = 'point' | 'spot' | 'directional';\n\n/**\n * Defines a light attached to a {@link Node}. See {@link KHRLightsPunctual}.\n */\nexport class Light extends ExtensionProperty<ILight> {\n\tpublic static EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;\n\tpublic declare extensionName: typeof KHR_LIGHTS_PUNCTUAL;\n\tpublic declare propertyType: 'Light';\n\tpublic declare parentTypes: [PropertyType.NODE];\n\n\t/**********************************************************************************************\n\t * CONSTANTS.\n\t */\n\n\tpublic static Type: Record<string, PunctualLightType> = {\n\t\tPOINT: 'point',\n\t\tSPOT: 'spot',\n\t\tDIRECTIONAL: 'directional',\n\t};\n\n\t/**********************************************************************************************\n\t * INSTANCE.\n\t */\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_LIGHTS_PUNCTUAL;\n\t\tthis.propertyType = 'Light';\n\t\tthis.parentTypes = [PropertyType.NODE];\n\t}\n\n\tprotected getDefaults(): Nullable<ILight> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tcolor: [1, 1, 1] as vec3,\n\t\t\tintensity: 1,\n\t\t\ttype: Light.Type.POINT,\n\t\t\trange: null,\n\t\t\tinnerConeAngle: 0,\n\t\t\touterConeAngle: Math.PI / 4,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * COLOR.\n\t */\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic getColor(): vec3 {\n\t\treturn this.get('color');\n\t}\n\n\t/** Light color; Linear-sRGB components. */\n\tpublic setColor(color: vec3): this {\n\t\treturn this.set('color', color);\n\t}\n\n\t/**********************************************************************************************\n\t * INTENSITY.\n\t */\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic getIntensity(): number {\n\t\treturn this.get('intensity');\n\t}\n\n\t/**\n\t * Brightness of light. Units depend on the type of light: point and spot lights use luminous\n\t * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).\n\t */\n\tpublic setIntensity(intensity: number): this {\n\t\treturn this.set('intensity', intensity);\n\t}\n\n\t/**********************************************************************************************\n\t * TYPE.\n\t */\n\n\t/** Type. */\n\tpublic getType(): PunctualLightType {\n\t\treturn this.get('type');\n\t}\n\n\t/** Type. */\n\tpublic setType(type: PunctualLightType): this {\n\t\treturn this.set('type', type);\n\t}\n\n\t/**********************************************************************************************\n\t * RANGE.\n\t */\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic getRange(): number | null {\n\t\treturn this.get('range');\n\t}\n\n\t/**\n\t * Hint defining a distance cutoff at which the light's intensity may be considered to have\n\t * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range\n\t * is assumed to be infinite.\n\t */\n\tpublic setRange(range: number | null): this {\n\t\treturn this.set('range', range);\n\t}\n\n\t/**********************************************************************************************\n\t * SPOT LIGHT PROPERTIES\n\t */\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and\n\t * < outerConeAngle.\n\t */\n\tpublic getInnerConeAngle(): number {\n\t\treturn this.get('innerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and\n\t * < outerConeAngle.\n\t */\n\tpublic setInnerConeAngle(angle: number): this {\n\t\treturn this.set('innerConeAngle', angle);\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t * <= PI / 2.0.\n\t */\n\tpublic getOuterConeAngle(): number {\n\t\treturn this.get('outerConeAngle');\n\t}\n\n\t/**\n\t * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and\n\t * <= PI / 2.0.\n\t */\n\tpublic setOuterConeAngle(angle: number): this {\n\t\treturn this.set('outerConeAngle', angle);\n\t}\n}\n", "import { Extension, MathUtils, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_LIGHTS_PUNCTUAL } from '../constants.js';\nimport { Light } from './light.js';\n\nconst NAME = KHR_LIGHTS_PUNCTUAL;\n\ninterface LightsPunctualRootDef {\n\tlights?: LightDef[];\n}\n\ninterface LightsPunctualNodeDef {\n\tlight: number;\n}\n\ninterface LightDef {\n\tname?: string;\n\tcolor?: vec3;\n\tintensity?: number;\n\trange?: number;\n\ttype: 'spot' | 'point' | 'directional';\n\tspot?: {\n\t\tinnerConeAngle?: number;\n\t\touterConeAngle?: number;\n\t};\n}\n\n/**\n * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three \"punctual\" light types: directional, point and\n * spot.\n *\n * Punctual lights are parameterized, infinitely small points that emit light in\n * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform\n * of that node.\n *\n * Properties:\n * - {@link Light}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRLightsPunctual, Light, LightType } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const lightsExtension = document.createExtension(KHRLightsPunctual);\n *\n * // Create a Light property.\n * const light = lightsExtension.createLight()\n *\t.setType(LightType.POINT)\n *\t.setIntensity(2.0)\n *\t.setColor([1.0, 0.0, 0.0]);\n *\n * // Attach the property to a Material.\n * node.setExtension('KHR_lights_punctual', light);\n * ```\n */\nexport class KHRLightsPunctual extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new punctual Light property for use on a {@link Node}. */\n\tpublic createLight(name = ''): Light {\n\t\treturn new Light(this.document.getGraph(), name);\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\tconst rootDef = jsonDoc.json.extensions[NAME] as LightsPunctualRootDef;\n\t\tconst lightDefs = rootDef.lights || ([] as LightDef[]);\n\t\tconst lights = lightDefs.map((lightDef) => {\n\t\t\tconst light = this.createLight()\n\t\t\t\t.setName(lightDef.name || '')\n\t\t\t\t.setType(lightDef.type);\n\n\t\t\tif (lightDef.color !== undefined) light.setColor(lightDef.color);\n\t\t\tif (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);\n\t\t\tif (lightDef.range !== undefined) light.setRange(lightDef.range);\n\n\t\t\tif (lightDef.spot?.innerConeAngle !== undefined) {\n\t\t\t\tlight.setInnerConeAngle(lightDef.spot.innerConeAngle);\n\t\t\t}\n\t\t\tif (lightDef.spot?.outerConeAngle !== undefined) {\n\t\t\t\tlight.setOuterConeAngle(lightDef.spot.outerConeAngle);\n\t\t\t}\n\n\t\t\treturn light;\n\t\t});\n\n\t\tjsonDoc.json.nodes!.forEach((nodeDef, nodeIndex) => {\n\t\t\tif (!nodeDef.extensions || !nodeDef.extensions[NAME]) return;\n\t\t\tconst lightNodeDef = nodeDef.extensions[NAME] as LightsPunctualNodeDef;\n\t\t\tcontext.nodes[nodeIndex].setExtension(NAME, lights[lightNodeDef.light]);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (this.properties.size === 0) return this;\n\n\t\tconst lightDefs = [];\n\t\tconst lightIndexMap = new Map<Light, number>();\n\n\t\tfor (const property of this.properties) {\n\t\t\tconst light = property as Light;\n\t\t\tconst lightDef = { type: light.getType() } as LightDef;\n\n\t\t\tif (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();\n\t\t\tif (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();\n\t\t\tif (light.getRange() != null) lightDef.range = light.getRange()!;\n\n\t\t\tif (light.getName()) lightDef.name = light.getName();\n\n\t\t\tif (light.getType() === Light.Type.SPOT) {\n\t\t\t\tlightDef.spot = {\n\t\t\t\t\tinnerConeAngle: light.getInnerConeAngle(),\n\t\t\t\t\touterConeAngle: light.getOuterConeAngle(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlightDefs.push(lightDef);\n\t\t\tlightIndexMap.set(light, lightDefs.length - 1);\n\t\t}\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listNodes()\n\t\t\t.forEach((node) => {\n\t\t\t\tconst light = node.getExtension<Light>(NAME);\n\t\t\t\tif (light) {\n\t\t\t\t\tconst nodeIndex = context.nodeIndexMap.get(node)!;\n\t\t\t\t\tconst nodeDef = jsonDoc.json.nodes![nodeIndex];\n\t\t\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\t\t\tnodeDef.extensions[NAME] = { light: lightIndexMap.get(light) };\n\t\t\t\t}\n\t\t\t});\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { lights: lightDefs };\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_ANISOTROPY } from '../constants.js';\n\ninterface IAnisotropy extends IProperty {\n\tanisotropyStrength: number;\n\tanisotropyRotation: number;\n\tanisotropyTexture: Texture;\n\tanisotropyTextureInfo: TextureInfo;\n}\n\nconst { R, G, B } = TextureChannel;\n\n/**\n * Defines anisotropy (directionally-dependent reflections) on a PBR {@link Material}. See\n * {@link KHRMaterialsAnisotropy}.\n */\nexport class Anisotropy extends ExtensionProperty<IAnisotropy> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;\n\tpublic declare extensionName: typeof KHR_MATERIALS_ANISOTROPY;\n\tpublic declare propertyType: 'Anisotropy';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_ANISOTROPY;\n\t\tthis.propertyType = 'Anisotropy';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IAnisotropy> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tanisotropyStrength: 0.0,\n\t\t\tanisotropyRotation: 0.0,\n\t\t\tanisotropyTexture: null,\n\t\t\tanisotropyTextureInfo: new TextureInfo(this.graph, 'anisotropyTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Anisotropy strength.\n\t */\n\n\t/** Anisotropy strength. */\n\tpublic getAnisotropyStrength(): number {\n\t\treturn this.get('anisotropyStrength');\n\t}\n\n\t/** Anisotropy strength. */\n\tpublic setAnisotropyStrength(strength: number): this {\n\t\treturn this.set('anisotropyStrength', strength);\n\t}\n\n\t/**********************************************************************************************\n\t * Anisotropy rotation.\n\t */\n\n\t/** Anisotropy rotation; linear multiplier. */\n\tpublic getAnisotropyRotation(): number {\n\t\treturn this.get('anisotropyRotation');\n\t}\n\n\t/** Anisotropy rotation; linear multiplier. */\n\tpublic setAnisotropyRotation(rotation: number): this {\n\t\treturn this.set('anisotropyRotation', rotation);\n\t}\n\n\t/**********************************************************************************************\n\t * Anisotropy texture.\n\t */\n\n\t/**\n\t * Anisotropy texture. Red and green channels represent the anisotropy\n\t * direction in [-1, 1] tangent, bitangent space, to be rotated by\n\t * anisotropyRotation. The blue channel contains strength as [0, 1] to be\n\t * multiplied by anisotropyStrength.\n\t */\n\tpublic getAnisotropyTexture(): Texture | null {\n\t\treturn this.getRef('anisotropyTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its anisotropy texture. If no\n\t * texture is attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getAnisotropyTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('anisotropyTexture') ? this.getRef('anisotropyTextureInfo') : null;\n\t}\n\n\t/** Anisotropy texture. See {@link Anisotropy.getAnisotropyTexture getAnisotropyTexture}. */\n\tpublic setAnisotropyTexture(texture: Texture | null): this {\n\t\treturn this.setRef('anisotropyTexture', texture, { channels: R | G | B });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_ANISOTROPY } from '../constants.js';\nimport { Anisotropy } from './anisotropy.js';\n\nconst NAME = KHR_MATERIALS_ANISOTROPY;\n\ninterface AnisotropyDef {\n\tanisotropyStrength: number;\n\tanisotropyRotation: number;\n\tanisotropyTexture: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_anisotropy`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/)\n * defines anisotropy (directionally-dependent reflections) on a PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-anisotropy.jpg)\n *\n * > _**Figure:** Effect of each color channel in the anisotropyTexture. Left\n * > to right: the full anisotropy texture, filling the red channel with black,\n * > filling the green channel with black, filling the blue channel with black.\n * > Source: [Khronos Group & Wayfair](https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/AnisotropyBarnLamp)._\n *\n * This extension defines the anisotropic property of a material as observable with brushed metals\n * for instance. An asymmetric specular lobe model is introduced to allow for such phenomena. The\n * visually distinct feature of that lobe is the elongated appearance of the specular reflection.\n * For a single punctual light source, the specular reflection will eventually degenerate into a\n * zero width line in the limit, that is where the material is fully anisotropic, as opposed to be\n * fully isotropic in which case the specular reflection is radially symmetric.\n *\n * Properties:\n * - {@link Anisotropy}\n *\n * ### Example\n *\n * The `KHRMaterialsAnisotropy` class provides a single {@link ExtensionProperty} type, `Anisotropy`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsAnisotropy, Anisotropy } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const anisotropyExtension = document.createExtension(KHRMaterialsAnisotropy);\n *\n * // Create an Anisotropy property.\n * const anisotropy = anisotropyExtension.createAnisotropy()\n * \t.setAnisotropyStrength(1.0)\n * \t.setAnisotropyRotation(Math.PI / 4);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_anisotropy', anisotropy);\n * ```\n */\nexport class KHRMaterialsAnisotropy extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Anisotropy property for use on a {@link Material}. */\n\tpublic createAnisotropy(): Anisotropy {\n\t\treturn new Anisotropy(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst anisotropy = this.createAnisotropy();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, anisotropy);\n\n\t\t\t\tconst anisotropyDef = materialDef.extensions[NAME] as AnisotropyDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (anisotropyDef.anisotropyStrength !== undefined) {\n\t\t\t\t\tanisotropy.setAnisotropyStrength(anisotropyDef.anisotropyStrength);\n\t\t\t\t}\n\t\t\t\tif (anisotropyDef.anisotropyRotation !== undefined) {\n\t\t\t\t\tanisotropy.setAnisotropyRotation(anisotropyDef.anisotropyRotation);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (anisotropyDef.anisotropyTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = anisotropyDef.anisotropyTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tanisotropy.setAnisotropyTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(anisotropy.getAnisotropyTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst anisotropy = material.getExtension<Anisotropy>(NAME);\n\t\t\t\tif (anisotropy) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst anisotropyDef = (materialDef.extensions[NAME] = {} as AnisotropyDef);\n\n\t\t\t\t\tif (anisotropy.getAnisotropyStrength() > 0) {\n\t\t\t\t\t\tanisotropyDef.anisotropyStrength = anisotropy.getAnisotropyStrength();\n\t\t\t\t\t}\n\t\t\t\t\tif (anisotropy.getAnisotropyRotation() !== 0) {\n\t\t\t\t\t\tanisotropyDef.anisotropyRotation = anisotropy.getAnisotropyRotation();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (anisotropy.getAnisotropyTexture()) {\n\t\t\t\t\t\tconst texture = anisotropy.getAnisotropyTexture()!;\n\t\t\t\t\t\tconst textureInfo = anisotropy.getAnisotropyTextureInfo()!;\n\t\t\t\t\t\tanisotropyDef.anisotropyTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants.js';\n\ninterface IClearcoat extends IProperty {\n\tclearcoatFactor: number;\n\tclearcoatTexture: Texture;\n\tclearcoatTextureInfo: TextureInfo;\n\n\tclearcoatRoughnessFactor: number;\n\tclearcoatRoughnessTexture: Texture;\n\tclearcoatRoughnessTextureInfo: TextureInfo;\n\n\tclearcoatNormalScale: number;\n\tclearcoatNormalTexture: Texture;\n\tclearcoatNormalTextureInfo: TextureInfo;\n}\n\nconst { R, G, B } = TextureChannel;\n\n/**\n * Defines clear coat for a PBR material. See {@link KHRMaterialsClearcoat}.\n */\nexport class Clearcoat extends ExtensionProperty<IClearcoat> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_CLEARCOAT;\n\tpublic declare propertyType: 'Clearcoat';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_CLEARCOAT;\n\t\tthis.propertyType = 'Clearcoat';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IClearcoat> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tclearcoatFactor: 0,\n\t\t\tclearcoatTexture: null,\n\t\t\tclearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),\n\n\t\t\tclearcoatRoughnessFactor: 0,\n\t\t\tclearcoatRoughnessTexture: null,\n\t\t\tclearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),\n\n\t\t\tclearcoatNormalScale: 1,\n\t\t\tclearcoatNormalTexture: null,\n\t\t\tclearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat.\n\t */\n\n\t/** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n\tpublic getClearcoatFactor(): number {\n\t\treturn this.get('clearcoatFactor');\n\t}\n\n\t/** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n\tpublic setClearcoatFactor(factor: number): this {\n\t\treturn this.set('clearcoatFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount\n\t * [0-1] of coating over the surface of the material, which may have its own roughness and\n\t * normal map properties.\n\t */\n\tpublic getClearcoatTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat texture. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */\n\tpublic setClearcoatTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat roughness.\n\t */\n\n\t/**\n\t * Clearcoat roughness; linear multiplier.\n\t * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n\t */\n\tpublic getClearcoatRoughnessFactor(): number {\n\t\treturn this.get('clearcoatRoughnessFactor');\n\t}\n\n\t/**\n\t * Clearcoat roughness; linear multiplier.\n\t * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n\t */\n\tpublic setClearcoatRoughnessFactor(factor: number): this {\n\t\treturn this.set('clearcoatRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getClearcoatRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets clearcoat roughness texture.\n\t * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.\n\t */\n\tpublic setClearcoatRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatRoughnessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Clearcoat normals.\n\t */\n\n\t/** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n\tpublic getClearcoatNormalScale(): number {\n\t\treturn this.get('clearcoatNormalScale');\n\t}\n\n\t/** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalScale(scale: number): this {\n\t\treturn this.set('clearcoatNormalScale', scale);\n\t}\n\n\t/**\n\t * Clearcoat normal map. Independent of the material base layer normal map.\n\t */\n\tpublic getClearcoatNormalTexture(): Texture | null {\n\t\treturn this.getRef('clearcoatNormalTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its clearcoat normal texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getClearcoatNormalTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;\n\t}\n\n\t/** Sets clearcoat normal texture. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */\n\tpublic setClearcoatNormalTexture(texture: Texture | null): this {\n\t\treturn this.setRef('clearcoatNormalTexture', texture, { channels: R | G | B });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_CLEARCOAT } from '../constants.js';\nimport { Clearcoat } from './clearcoat.js';\n\nconst NAME = KHR_MATERIALS_CLEARCOAT;\n\ninterface ClearcoatDef {\n\tclearcoatFactor?: number;\n\tclearcoatRoughnessFactor?: number;\n\tclearcoatTexture?: GLTF.ITextureInfo;\n\tclearcoatRoughnessTexture?: GLTF.ITextureInfo;\n\tclearcoatNormalTexture?: GLTF.IMaterialNormalTextureInfo;\n}\n\n/**\n * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)\n * defines a clear coating on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-clearcoat.png)\n *\n * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat\n * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._\n *\n * A clear coat is a common technique used in Physically-Based\n * Rendering for a protective layer applied to a base material.\n * Commonly used to represent car paint, carbon fiber, or thin lacquers.\n *\n * Properties:\n * - {@link Clearcoat}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const clearcoatExtension = document.createExtension(KHRMaterialsClearcoat);\n *\n * // Create Clearcoat property.\n * const clearcoat = clearcoatExtension.createClearcoat()\n *\t.setClearcoatFactor(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_clearcoat', clearcoat);\n * ```\n */\nexport class KHRMaterialsClearcoat extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Clearcoat property for use on a {@link Material}. */\n\tpublic createClearcoat(): Clearcoat {\n\t\treturn new Clearcoat(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst clearcoat = this.createClearcoat();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, clearcoat);\n\n\t\t\t\tconst clearcoatDef = materialDef.extensions[NAME] as ClearcoatDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (clearcoatDef.clearcoatFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessFactor !== undefined) {\n\t\t\t\t\tclearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (clearcoatDef.clearcoatTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (clearcoatDef.clearcoatNormalTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = clearcoatDef.clearcoatNormalTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tclearcoat.setClearcoatNormalTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo()!, textureInfoDef);\n\t\t\t\t\tif (textureInfoDef.scale !== undefined) {\n\t\t\t\t\t\tclearcoat.setClearcoatNormalScale(textureInfoDef.scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst clearcoat = material.getExtension<Clearcoat>(NAME);\n\t\t\t\tif (clearcoat) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst clearcoatDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tclearcoatFactor: clearcoat.getClearcoatFactor(),\n\t\t\t\t\t\tclearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor(),\n\t\t\t\t\t} as ClearcoatDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (clearcoat.getClearcoatTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatRoughnessTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (clearcoat.getClearcoatNormalTexture()) {\n\t\t\t\t\t\tconst texture = clearcoat.getClearcoatNormalTexture()!;\n\t\t\t\t\t\tconst textureInfo = clearcoat.getClearcoatNormalTextureInfo()!;\n\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t\tif (clearcoat.getClearcoatNormalScale() !== 1) {\n\t\t\t\t\t\t\tclearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_DIFFUSE_TRANSMISSION } from '../constants.js';\n\ninterface IDiffuseTransmission extends IProperty {\n\tdiffuseTransmissionFactor: number;\n\tdiffuseTransmissionTexture: Texture;\n\tdiffuseTransmissionTextureInfo: TextureInfo;\n\tdiffuseTransmissionColorFactor: vec3;\n\tdiffuseTransmissionColorTexture: Texture;\n\tdiffuseTransmissionColorTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * Defines diffuse transmission on a PBR {@link Material}. See {@link KHRMaterialsDiffuseTransmission}.\n *\n * @experimental KHR_materials_diffuse_transmission is not yet ratified by the Khronos Group.\n */\nexport class DiffuseTransmission extends ExtensionProperty<IDiffuseTransmission> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n\tpublic declare propertyType: 'DiffuseTransmission';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n\t\tthis.propertyType = 'DiffuseTransmission';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IDiffuseTransmission> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tdiffuseTransmissionFactor: 0.0,\n\t\t\tdiffuseTransmissionTexture: null,\n\t\t\tdiffuseTransmissionTextureInfo: new TextureInfo(this.graph, 'diffuseTransmissionTextureInfo'),\n\t\t\tdiffuseTransmissionColorFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tdiffuseTransmissionColorTexture: null,\n\t\t\tdiffuseTransmissionColorTextureInfo: new TextureInfo(this.graph, 'diffuseTransmissionColorTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse transmission.\n\t */\n\n\t/**\n\t * Percentage of reflected, non-specularly reflected light that is transmitted through the\n\t * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse\n\t * transmission effect.\n\t */\n\tpublic getDiffuseTransmissionFactor(): number {\n\t\treturn this.get('diffuseTransmissionFactor');\n\t}\n\n\t/**\n\t * Percentage of reflected, non-specularly reflected light that is transmitted through the\n\t * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse\n\t * transmission effect.\n\t */\n\tpublic setDiffuseTransmissionFactor(factor: number): this {\n\t\treturn this.set('diffuseTransmissionFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)\n\t * channel. Will be multiplied by the diffuseTransmissionFactor.\n\t */\n\tpublic getDiffuseTransmissionTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTransmissionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse transmission texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTransmissionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTransmissionTexture') ? this.getRef('diffuseTransmissionTextureInfo') : null;\n\t}\n\n\t/**\n\t * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)\n\t * channel. Will be multiplied by the diffuseTransmissionFactor.\n\t */\n\tpublic setDiffuseTransmissionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTransmissionTexture', texture, { channels: A });\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse transmission color.\n\t */\n\n\t/** Color of the transmitted light; Linear-sRGB components. */\n\tpublic getDiffuseTransmissionColorFactor(): vec3 {\n\t\treturn this.get('diffuseTransmissionColorFactor');\n\t}\n\n\t/** Color of the transmitted light; Linear-sRGB components. */\n\tpublic setDiffuseTransmissionColorFactor(factor: vec3): this {\n\t\treturn this.set('diffuseTransmissionColorFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the color of the transmitted light, stored in the RGB channels and\n\t * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.\n\t */\n\tpublic getDiffuseTransmissionColorTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTransmissionColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse transmission color texture. If no\n\t * texture is attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTransmissionColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTransmissionColorTexture')\n\t\t\t? this.getRef('diffuseTransmissionColorTextureInfo')\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Texture that defines the color of the transmitted light, stored in the RGB channels and\n\t * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.\n\t */\n\tpublic setDiffuseTransmissionColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTransmissionColorTexture', texture, { channels: R | G | B });\n\t}\n}\n", "import { Extension, GLTF, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_DIFFUSE_TRANSMISSION } from '../constants.js';\nimport { DiffuseTransmission } from './diffuse-transmission.js';\n\nconst NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;\n\ninterface DiffuseTransmissionDef {\n\tdiffuseTransmissionFactor?: number;\n\tdiffuseTransmissionTexture?: GLTF.ITextureInfo;\n\tdiffuseTransmissionColorFactor?: vec3;\n\tdiffuseTransmissionColorTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * [KHR_materials_diffuse_transmission](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_diffuse_transmission/)\n * defines diffuse transmission on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-diffuse-transmission.png)\n *\n * > _**Figure:** Sphere using `KHR_materials_diffuse_transmission` with varying roughness (0.0, 0.2, 0.4).\n * > Source: Khronos Group._\n *\n * Adds a Lambertian diffuse transmission BSDF to the metallic-roughness\n * material. Thin, dielectric objects like leaves or paper diffusely transmit\n * incoming light to the opposite side of the surface. For optically thick\n * media (volumes) with short scattering distances and therefore dense\n * scattering behavior, a diffuse transmission lobe is a phenomenological\n * plausible and cheap approximation.\n *\n * Properties:\n * - {@link DiffuseTransmission}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsDiffuseTransmission, DiffuseTransmission } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const diffuseTransmissionExtension = document.createExtension(KHRMaterialsDiffuseTransmission);\n *\n * // Create DiffuseTransmission property.\n * const diffuseTransmission = diffuseTransmission.createDiffuseTransmission()\n *\t.setDiffuseTransmissionFactor(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_diffuse_transmission', diffuseTransmission);\n * ```\n *\n * @experimental KHR_materials_diffuse_transmission is not yet ratified by the Khronos Group.\n */\nexport class KHRMaterialsDiffuseTransmission extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new DiffuseTransmission property for use on a {@link Material}. */\n\tpublic createDiffuseTransmission(): DiffuseTransmission {\n\t\treturn new DiffuseTransmission(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst transmission = this.createDiffuseTransmission();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\n\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as DiffuseTransmissionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (transmissionDef.diffuseTransmissionFactor !== undefined) {\n\t\t\t\t\ttransmission.setDiffuseTransmissionFactor(transmissionDef.diffuseTransmissionFactor);\n\t\t\t\t}\n\n\t\t\t\tif (transmissionDef.diffuseTransmissionColorFactor !== undefined) {\n\t\t\t\t\ttransmission.setDiffuseTransmissionColorFactor(transmissionDef.diffuseTransmissionColorFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (transmissionDef.diffuseTransmissionTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.diffuseTransmissionTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setDiffuseTransmissionTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getDiffuseTransmissionTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\n\t\t\t\tif (transmissionDef.diffuseTransmissionColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.diffuseTransmissionColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setDiffuseTransmissionColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getDiffuseTransmissionColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tfor (const material of this.document.getRoot().listMaterials()) {\n\t\t\tconst transmission = material.getExtension<DiffuseTransmission>(NAME);\n\t\t\tif (!transmission) continue;\n\n\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t// Factors.\n\n\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\n\t\t\t\tdiffuseTransmissionFactor: transmission.getDiffuseTransmissionFactor(),\n\t\t\t\tdiffuseTransmissionColorFactor: transmission.getDiffuseTransmissionColorFactor(),\n\t\t\t} as DiffuseTransmissionDef);\n\n\t\t\t// Textures.\n\n\t\t\tif (transmission.getDiffuseTransmissionTexture()) {\n\t\t\t\tconst texture = transmission.getDiffuseTransmissionTexture()!;\n\t\t\t\tconst textureInfo = transmission.getDiffuseTransmissionTextureInfo()!;\n\t\t\t\ttransmissionDef.diffuseTransmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\n\t\t\tif (transmission.getDiffuseTransmissionColorTexture()) {\n\t\t\t\tconst texture = transmission.getDiffuseTransmissionColorTexture()!;\n\t\t\t\tconst textureInfo = transmission.getDiffuseTransmissionColorTextureInfo()!;\n\t\t\t\ttransmissionDef.diffuseTransmissionColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_DISPERSION } from '../constants.js';\n\ninterface IDispersion extends IProperty {\n\tdispersion: number;\n}\n\n/**\n * Defines dispersion for a PBR {@link Material}. See {@link KHRMaterialsDispersion}.\n */\nexport class Dispersion extends ExtensionProperty<IDispersion> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_DISPERSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_DISPERSION;\n\tpublic declare propertyType: 'Dispersion';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_DISPERSION;\n\t\tthis.propertyType = 'Dispersion';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IDispersion> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { dispersion: 0 });\n\t}\n\n\t/**********************************************************************************************\n\t * Dispersion.\n\t */\n\n\t/** Dispersion. */\n\tpublic getDispersion(): number {\n\t\treturn this.get('dispersion');\n\t}\n\n\t/** Dispersion. */\n\tpublic setDispersion(dispersion: number): this {\n\t\treturn this.set('dispersion', dispersion);\n\t}\n}\n", "import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_DISPERSION } from '../constants.js';\nimport { Dispersion } from './dispersion.js';\n\nconst NAME = KHR_MATERIALS_DISPERSION;\n\ninterface DispersionDef {\n\tdispersion?: number;\n}\n\n/**\n * [KHR_materials_dispersion](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_dispersion/)\n * defines dispersion on a glTF PBR material.\n *\n * ![illustration](/media/extensions/khr-materials-dispersion.jpg)\n *\n * > _**Figure:** Prisms demonstrating volumetric refraction and dispersion, for varying\n * > values of dispersion and IOR. Source: Khronos Group, rendered in Adobe Stager._\n *\n * Dispersion enables configuring the strength of the angular separation of colors (chromatic\n * aberration) transmitting through a relatively clear volume.  It is an enhancement to the\n * default `KHR_materials_volume` transmission model which assumes no dispersion.\n *\n * Properties:\n * - {@link Dispersion}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsDispersion, Dispersion } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const dispersionExtension = document.createExtension(KHRMaterialsDispersion);\n *\n * // Create Dispersion property.\n * const dispersion = dispersionExtension.createDispersion().setDispersion(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_dispersion', dispersion);\n * ```\n */\nexport class KHRMaterialsDispersion extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Dispersion property for use on a {@link Material}. */\n\tpublic createDispersion(): Dispersion {\n\t\treturn new Dispersion(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst dispersion = this.createDispersion();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, dispersion);\n\n\t\t\t\tconst dispersionDef = materialDef.extensions[NAME] as DispersionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (dispersionDef.dispersion !== undefined) {\n\t\t\t\t\tdispersion.setDispersion(dispersionDef.dispersion);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst dispersion = material.getExtension<Dispersion>(NAME);\n\t\t\t\tif (dispersion) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\tdispersion: dispersion.getDispersion(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants.js';\n\ninterface IEmissiveStrength extends IProperty {\n\temissiveStrength: number;\n}\n\n/**\n * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range\n * (HDR) emissive materials. See {@link KHRMaterialsEmissiveStrength}.\n */\nexport class EmissiveStrength extends ExtensionProperty<IEmissiveStrength> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare extensionName: typeof KHR_MATERIALS_EMISSIVE_STRENGTH;\n\tpublic declare propertyType: 'EmissiveStrength';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\t\tthis.propertyType = 'EmissiveStrength';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IEmissiveStrength> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { emissiveStrength: 1.0 });\n\t}\n\n\t/**********************************************************************************************\n\t * EmissiveStrength.\n\t */\n\n\t/** EmissiveStrength. */\n\tpublic getEmissiveStrength(): number {\n\t\treturn this.get('emissiveStrength');\n\t}\n\n\t/** EmissiveStrength. */\n\tpublic setEmissiveStrength(strength: number): this {\n\t\treturn this.set('emissiveStrength', strength);\n\t}\n}\n", "import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_EMISSIVE_STRENGTH } from '../constants.js';\nimport { EmissiveStrength } from './emissive-strength.js';\n\nconst NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;\n\ninterface EmissiveStrengthDef {\n\temissiveStrength?: number;\n}\n\n/**\n * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)\n * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.\n *\n * ![Illustration](/media/extensions/khr-materials-emissive-strength.jpg)\n *\n * > _**Figure:** Cubes with emissive color #59BCF3 and emissive strength\n * > increasing from 1 to 256 nits, left to right. Rendered in [three.js](https://threejs.org/),\n * > with independent point lighting and a bloom effect.\n * > Source: [Don McCurdy](https://www.donmccurdy.com/2024/04/27/emission-and-bloom/)._\n *\n * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}\n * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity\n * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in\n * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.\n *\n * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar\n * factor is supplied, which governs the upper limit of emissive strength per material and may be\n * given arbitrarily high values.\n *\n * For implementations where a physical light unit is needed, the units for the multiplicative\n * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes\n * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an\n * emissive factor of 1.0 results in a fully exposed pixel.\n *\n * Properties:\n * - {@link EmissiveStrength}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const emissiveStrengthExtension = document.createExtension(KHRMaterialsEmissiveStrength);\n *\n * // Create EmissiveStrength property.\n * const emissiveStrength = emissiveStrengthExtension\n * \t.createEmissiveStrength().setEmissiveStrength(5.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);\n * ```\n */\nexport class KHRMaterialsEmissiveStrength extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new EmissiveStrength property for use on a {@link Material}. */\n\tpublic createEmissiveStrength(): EmissiveStrength {\n\t\treturn new EmissiveStrength(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst emissiveStrength = this.createEmissiveStrength();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, emissiveStrength);\n\n\t\t\t\tconst emissiveStrengthDef = materialDef.extensions[NAME] as EmissiveStrengthDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (emissiveStrengthDef.emissiveStrength !== undefined) {\n\t\t\t\t\temissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst emissiveStrength = material.getExtension<EmissiveStrength>(NAME);\n\t\t\t\tif (emissiveStrength) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\temissiveStrength: emissiveStrength.getEmissiveStrength(),\n\t\t\t\t\t} as EmissiveStrengthDef;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty, IProperty, Nullable, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants.js';\n\ninterface IIOR extends IProperty {\n\tior: number;\n}\n\n/**\n * Defines index of refraction for a PBR {@link Material}. See {@link KHRMaterialsIOR}.\n */\nexport class IOR extends ExtensionProperty<IIOR> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IOR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IOR;\n\tpublic declare propertyType: 'IOR';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IOR;\n\t\tthis.propertyType = 'IOR';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIOR> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { ior: 1.5 });\n\t}\n\n\t/**********************************************************************************************\n\t * IOR.\n\t */\n\n\t/** IOR. */\n\tpublic getIOR(): number {\n\t\treturn this.get('ior');\n\t}\n\n\t/** IOR. */\n\tpublic setIOR(ior: number): this {\n\t\treturn this.set('ior', ior);\n\t}\n}\n", "import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IOR } from '../constants.js';\nimport { IOR } from './ior.js';\n\nconst NAME = KHR_MATERIALS_IOR;\n\ninterface IORDef {\n\tior?: number;\n}\n\n/**\n * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)\n * defines index of refraction on a glTF PBR material.\n *\n * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the\n * index of refraction. This is a good fit for many plastics and glass, but not for other materials\n * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of\n * refraction to a certain value.\n *\n * Properties:\n * - {@link IOR}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsIOR, IOR } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iorExtension = document.createExtension(KHRMaterialsIOR);\n *\n * // Create IOR property.\n * const ior = iorExtension.createIOR().setIOR(1.0);\n *\n * // Assign to a Material.\n * material.setExtension('KHR_materials_ior', ior);\n * ```\n */\nexport class KHRMaterialsIOR extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new IOR property for use on a {@link Material}. */\n\tpublic createIOR(): IOR {\n\t\treturn new IOR(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst ior = this.createIOR();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, ior);\n\n\t\t\t\tconst iorDef = materialDef.extensions[NAME] as IORDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iorDef.ior !== undefined) {\n\t\t\t\t\tior.setIOR(iorDef.ior);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst ior = material.getExtension<IOR>(NAME);\n\t\t\t\tif (ior) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tmaterialDef.extensions[NAME] = {\n\t\t\t\t\t\tior: ior.getIOR(),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants.js';\n\ninterface IIridescence extends IProperty {\n\tiridescenceFactor: number;\n\tiridescenceTexture: Texture;\n\tiridescenceTextureInfo: TextureInfo;\n\tiridescenceIOR: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: Texture;\n\tiridescenceThicknessTextureInfo: TextureInfo;\n}\n\nconst { R, G } = TextureChannel;\n\n/**\n * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link KHRMaterialsIridescence}.\n */\nexport class Iridescence extends ExtensionProperty<IIridescence> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare extensionName: typeof KHR_MATERIALS_IRIDESCENCE;\n\tpublic declare propertyType: 'Iridescence';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_IRIDESCENCE;\n\t\tthis.propertyType = 'Iridescence';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IIridescence> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tiridescenceFactor: 0.0,\n\t\t\tiridescenceTexture: null,\n\t\t\tiridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),\n\t\t\tiridescenceIOR: 1.3,\n\t\t\tiridescenceThicknessMinimum: 100,\n\t\t\tiridescenceThicknessMaximum: 400,\n\t\t\tiridescenceThicknessTexture: null,\n\t\t\tiridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence.\n\t */\n\n\t/** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n\tpublic getIridescenceFactor(): number {\n\t\treturn this.get('iridescenceFactor');\n\t}\n\n\t/** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n\tpublic setIridescenceFactor(factor: number): this {\n\t\treturn this.set('iridescenceFactor', factor);\n\t}\n\n\t/**\n\t * Iridescence intensity.\n\t *\n\t * Only the red (R) channel is used for iridescence intensity, but this texture may optionally\n\t * be packed with additional data in the other channels.\n\t */\n\tpublic getIridescenceTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;\n\t}\n\n\t/** Iridescence intensity. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */\n\tpublic setIridescenceTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceTexture', texture, { channels: R });\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence IOR.\n\t */\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic getIridescenceIOR(): number {\n\t\treturn this.get('iridescenceIOR');\n\t}\n\n\t/** Index of refraction of the dielectric thin-film layer. */\n\tpublic setIridescenceIOR(ior: number): this {\n\t\treturn this.set('iridescenceIOR', ior);\n\t}\n\n\t/**********************************************************************************************\n\t * Iridescence thickness.\n\t */\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMinimum(): number {\n\t\treturn this.get('iridescenceThicknessMinimum');\n\t}\n\n\t/** Minimum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMinimum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMinimum', thickness);\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic getIridescenceThicknessMaximum(): number {\n\t\treturn this.get('iridescenceThicknessMaximum');\n\t}\n\n\t/** Maximum thickness of the thin-film layer, in nanometers (nm). */\n\tpublic setIridescenceThicknessMaximum(thickness: number): this {\n\t\treturn this.set('iridescenceThicknessMaximum', thickness);\n\t}\n\n\t/**\n\t * The green channel of this texture defines the thickness of the\n\t * thin-film layer by blending between the minimum and maximum thickness.\n\t */\n\tpublic getIridescenceThicknessTexture(): Texture | null {\n\t\treturn this.getRef('iridescenceThicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its iridescence thickness texture.\n\t * If no texture is attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getIridescenceThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets iridescence thickness texture.\n\t * See {@link Iridescence.getIridescenceThicknessTexture getIridescenceThicknessTexture}.\n\t */\n\tpublic setIridescenceThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('iridescenceThicknessTexture', texture, { channels: G });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_IRIDESCENCE } from '../constants.js';\nimport { Iridescence } from './iridescence.js';\n\nconst NAME = KHR_MATERIALS_IRIDESCENCE;\n\ninterface IridescenceDef {\n\tiridescenceFactor: number;\n\tiridescenceTexture: GLTF.ITextureInfo;\n\tiridescenceIor: number;\n\tiridescenceThicknessMinimum: number;\n\tiridescenceThicknessMaximum: number;\n\tiridescenceThicknessTexture: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)\n * defines iridescence (thin film interference) on a PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-iridescence.png)\n *\n * > _**Figure:** Varying levels of iridescence IOR values.\n * > Source: [Khronos Group](https://github.com/KhronosGroup/gltf/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence)._\n *\n * Iridescence describes an effect where hue varies depending on the viewing\n * angle and illumination angle: A thin-film of a semi-transparent layer\n * results in inter-reflections and due to thin-film interference, certain\n * wavelengths get absorbed or amplified. Iridescence can be seen on soap\n * bubbles, oil films, or on the wings of many insects. With this extension,\n * thickness and index of refraction (IOR) of the thin-film can be specified,\n * enabling iridescent materials.\n *\n * Properties:\n * - {@link Iridescence}\n *\n * ### Example\n *\n * The `KHRMaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsIridescence, Iridescence } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const iridescenceExtension = document.createExtension(KHRMaterialsIridescence);\n *\n * // Create an Iridescence property.\n * const iridescence = iridescenceExtension.createIridescence()\n * \t.setIridescenceFactor(1.0)\n * \t.setIridescenceIOR(1.8);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_iridescence', iridescence);\n * ```\n */\nexport class KHRMaterialsIridescence extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Iridescence property for use on a {@link Material}. */\n\tpublic createIridescence(): Iridescence {\n\t\treturn new Iridescence(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst iridescence = this.createIridescence();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, iridescence);\n\n\t\t\t\tconst iridescenceDef = materialDef.extensions[NAME] as IridescenceDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (iridescenceDef.iridescenceFactor !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceIor !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMinimum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessMaximum !== undefined) {\n\t\t\t\t\tiridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (iridescenceDef.iridescenceTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (iridescenceDef.iridescenceThicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = iridescenceDef.iridescenceThicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tiridescence.setIridescenceThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst iridescence = material.getExtension<Iridescence>(NAME);\n\t\t\t\tif (iridescence) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst iridescenceDef = (materialDef.extensions[NAME] = {} as IridescenceDef);\n\n\t\t\t\t\tif (iridescence.getIridescenceFactor() > 0) {\n\t\t\t\t\t\tiridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceIOR() !== 1.3) {\n\t\t\t\t\t\tiridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMinimum() !== 100) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessMaximum() !== 400) {\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (iridescence.getIridescenceTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (iridescence.getIridescenceThicknessTexture()) {\n\t\t\t\t\t\tconst texture = iridescence.getIridescenceThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = iridescence.getIridescenceThicknessTextureInfo()!;\n\t\t\t\t\t\tiridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants.js';\n\ninterface IPBRSpecularGlossiness extends IProperty {\n\tdiffuseFactor: vec4;\n\tdiffuseTexture: Texture;\n\tdiffuseTextureInfo: TextureInfo;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tspecularGlossinessTexture: Texture;\n\tspecularGlossinessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * Converts a {@link Material} to a spec/gloss workflow. See {@link KHRMaterialsPBRSpecularGlossiness}.\n */\nexport class PBRSpecularGlossiness extends ExtensionProperty<IPBRSpecularGlossiness> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\tpublic declare propertyType: 'PBRSpecularGlossiness';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\t\tthis.propertyType = 'PBRSpecularGlossiness';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IPBRSpecularGlossiness> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tdiffuseFactor: [1.0, 1.0, 1.0, 1.0] as vec4,\n\t\t\tdiffuseTexture: null,\n\t\t\tdiffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),\n\t\t\tspecularFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tglossinessFactor: 1.0,\n\t\t\tspecularGlossinessTexture: null,\n\t\t\tspecularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Diffuse.\n\t */\n\n\t/** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n\tpublic getDiffuseFactor(): vec4 {\n\t\treturn this.get('diffuseFactor');\n\t}\n\n\t/** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n\tpublic setDiffuseFactor(factor: vec4): this {\n\t\treturn this.set('diffuseFactor', factor);\n\t}\n\n\t/**\n\t * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the\n\t * spec/gloss PBR workflow.\n\t */\n\tpublic getDiffuseTexture(): Texture | null {\n\t\treturn this.getRef('diffuseTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its diffuse texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getDiffuseTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;\n\t}\n\n\t/** Sets diffuse texture. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */\n\tpublic setDiffuseTexture(texture: Texture | null): this {\n\t\treturn this.setRef('diffuseTexture', texture, { channels: R | G | B | A, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. */\n\tpublic getSpecularFactor(): vec3 {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. */\n\tpublic setSpecularFactor(factor: vec3): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Glossiness.\n\t */\n\n\t/** Glossiness; linear multiplier. */\n\tpublic getGlossinessFactor(): number {\n\t\treturn this.get('glossinessFactor');\n\t}\n\n\t/** Glossiness; linear multiplier. */\n\tpublic setGlossinessFactor(factor: number): this {\n\t\treturn this.set('glossinessFactor', factor);\n\t}\n\n\t/**********************************************************************************************\n\t * Specular/Glossiness.\n\t */\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic getSpecularGlossinessTexture(): Texture | null {\n\t\treturn this.getRef('specularGlossinessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularGlossinessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;\n\t}\n\n\t/** Spec/gloss texture; linear multiplier. */\n\tpublic setSpecularGlossinessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularGlossinessTexture', texture, { channels: R | G | B | A });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext, vec3, vec4 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS } from '../constants.js';\nimport { PBRSpecularGlossiness } from './pbr-specular-glossiness.js';\n\nconst NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n\ninterface SpecularGlossinessDef {\n\tdiffuseFactor?: vec4;\n\tspecularFactor: vec3;\n\tglossinessFactor: number;\n\tdiffuseTexture?: GLTF.ITextureInfo;\n\tspecularGlossinessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)\n * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.\n *\n * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,\n * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the\n * > {@link KHRMaterialsSpecular} extension instead, which provides specular data within a metal/rough\n * > workflow._\n *\n * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)\n *\n * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._\n *\n * Properties:\n * - {@link PBRSpecularGlossiness}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specGlossExtension = document.createExtension(KHRMaterialsPBRSpecularGlossiness);\n *\n * // Create a PBRSpecularGlossiness property.\n * const specGloss = specGlossExtension.createPBRSpecularGlossiness()\n * \t.setSpecularFactor(1.0);\n *\n * // // Assign to a Material.\n * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);\n * ```\n */\nexport class KHRMaterialsPBRSpecularGlossiness extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */\n\tpublic createPBRSpecularGlossiness(): PBRSpecularGlossiness {\n\t\treturn new PBRSpecularGlossiness(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specGloss = this.createPBRSpecularGlossiness();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specGloss);\n\n\t\t\t\tconst specGlossDef = materialDef.extensions[NAME] as SpecularGlossinessDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specGlossDef.diffuseFactor !== undefined) {\n\t\t\t\t\tspecGloss.setDiffuseFactor(specGlossDef.diffuseFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularFactor !== undefined) {\n\t\t\t\t\tspecGloss.setSpecularFactor(specGlossDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.glossinessFactor !== undefined) {\n\t\t\t\t\tspecGloss.setGlossinessFactor(specGlossDef.glossinessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specGlossDef.diffuseTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.diffuseTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setDiffuseTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getDiffuseTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specGlossDef.specularGlossinessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specGlossDef.specularGlossinessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecGloss.setSpecularGlossinessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>(NAME);\n\t\t\t\tif (specGloss) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specGlossDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tdiffuseFactor: specGloss.getDiffuseFactor(),\n\t\t\t\t\t\tspecularFactor: specGloss.getSpecularFactor(),\n\t\t\t\t\t\tglossinessFactor: specGloss.getGlossinessFactor(),\n\t\t\t\t\t} as SpecularGlossinessDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specGloss.getDiffuseTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getDiffuseTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getDiffuseTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specGloss.getSpecularGlossinessTexture()) {\n\t\t\t\t\t\tconst texture = specGloss.getSpecularGlossinessTexture()!;\n\t\t\t\t\t\tconst textureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\t\t\tspecGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants.js';\n\ninterface ISheen extends IProperty {\n\tsheenColorFactor: vec3;\n\tsheenColorTexture: Texture;\n\tsheenColorTextureInfo: TextureInfo;\n\tsheenRoughnessFactor: number;\n\tsheenRoughnessTexture: Texture;\n\tsheenRoughnessTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * Defines sheen on a PBR {@link Material}. See {@link KHRMaterialsSheen}.\n */\nexport class Sheen extends ExtensionProperty<ISheen> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SHEEN;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SHEEN;\n\tpublic declare propertyType: 'Sheen';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SHEEN;\n\t\tthis.propertyType = 'Sheen';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISheen> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tsheenColorFactor: [0.0, 0.0, 0.0] as vec3,\n\t\t\tsheenColorTexture: null,\n\t\t\tsheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),\n\t\t\tsheenRoughnessFactor: 0.0,\n\t\t\tsheenRoughnessTexture: null,\n\t\t\tsheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen color.\n\t */\n\n\t/** Sheen; linear multiplier. */\n\tpublic getSheenColorFactor(): vec3 {\n\t\treturn this.get('sheenColorFactor');\n\t}\n\n\t/** Sheen; linear multiplier. */\n\tpublic setSheenColorFactor(factor: vec3): this {\n\t\treturn this.set('sheenColorFactor', factor);\n\t}\n\n\t/**\n\t * Sheen color texture, in sRGB colorspace.\n\t */\n\tpublic getSheenColorTexture(): Texture | null {\n\t\treturn this.getRef('sheenColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen color texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;\n\t}\n\n\t/** Sets sheen color texture. See {@link Sheen.getSheenColorTexture getSheenColorTexture}. */\n\tpublic setSheenColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenColorTexture', texture, { channels: R | G | B, isColor: true });\n\t}\n\n\t/**********************************************************************************************\n\t * Sheen roughness.\n\t */\n\n\t/** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */\n\tpublic getSheenRoughnessFactor(): number {\n\t\treturn this.get('sheenRoughnessFactor');\n\t}\n\n\t/** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */\n\tpublic setSheenRoughnessFactor(factor: number): this {\n\t\treturn this.set('sheenRoughnessFactor', factor);\n\t}\n\n\t/**\n\t * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic getSheenRoughnessTexture(): Texture | null {\n\t\treturn this.getRef('sheenRoughnessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its sheen roughness texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSheenRoughnessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Sets sheen roughness texture.  The `a` channel of this texture specifies\n\t * roughness, independent of the base layer's roughness.\n\t */\n\tpublic setSheenRoughnessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('sheenRoughnessTexture', texture, { channels: A });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext, vec3 } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SHEEN } from '../constants.js';\nimport { Sheen } from './sheen.js';\n\nconst NAME = KHR_MATERIALS_SHEEN;\n\ninterface SheenDef {\n\tsheenColorFactor?: vec3;\n\tsheenRoughnessFactor?: number;\n\tsheenColorTexture?: GLTF.ITextureInfo;\n\tsheenRoughnessTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)\n * defines a velvet-like sheen layered on a glTF PBR material.\n *\n * ![Illustration](/media/extensions/khr-materials-sheen.png)\n *\n * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft\n * > highlights at edges of the material show backscattering from microfibers. Source: Khronos\n * > Group._\n *\n * A sheen layer is a common technique used in Physically-Based Rendering to represent\n * cloth and fabric materials.\n *\n * Properties:\n * - {@link Sheen}\n *\n * ### Example\n *\n * The `KHRMaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsSheen, Sheen } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const sheenExtension = document.createExtension(KHRMaterialsSheen);\n *\n * // Create a Sheen property.\n * const sheen = sheenExtension.createSheen()\n * \t.setSheenColorFactor([1.0, 1.0, 1.0]);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_sheen', sheen);\n * ```\n */\nexport class KHRMaterialsSheen extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Sheen property for use on a {@link Material}. */\n\tpublic createSheen(): Sheen {\n\t\treturn new Sheen(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst sheen = this.createSheen();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, sheen);\n\n\t\t\t\tconst sheenDef = materialDef.extensions[NAME] as SheenDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (sheenDef.sheenColorFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenColorFactor(sheenDef.sheenColorFactor);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessFactor !== undefined) {\n\t\t\t\t\tsheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (sheenDef.sheenColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (sheenDef.sheenRoughnessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = sheenDef.sheenRoughnessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tsheen.setSheenRoughnessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(sheen.getSheenRoughnessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst sheen = material.getExtension<Sheen>(NAME);\n\t\t\t\tif (sheen) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst sheenDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\tsheenColorFactor: sheen.getSheenColorFactor(),\n\t\t\t\t\t\tsheenRoughnessFactor: sheen.getSheenRoughnessFactor(),\n\t\t\t\t\t} as SheenDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (sheen.getSheenColorTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenColorTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (sheen.getSheenRoughnessTexture()) {\n\t\t\t\t\t\tconst texture = sheen.getSheenRoughnessTexture()!;\n\t\t\t\t\t\tconst textureInfo = sheen.getSheenRoughnessTextureInfo()!;\n\t\t\t\t\t\tsheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants.js';\n\ninterface ISpecular extends IProperty {\n\tspecularFactor: number;\n\tspecularTexture: Texture;\n\tspecularTextureInfo: TextureInfo;\n\tspecularColorFactor: vec3;\n\tspecularColorTexture: Texture;\n\tspecularColorTextureInfo: TextureInfo;\n}\n\nconst { R, G, B, A } = TextureChannel;\n\n/**\n * Defines specular reflectivity on a PBR {@link Material}. See {@link KHRMaterialsSpecular}.\n */\nexport class Specular extends ExtensionProperty<ISpecular> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_SPECULAR;\n\tpublic declare extensionName: typeof KHR_MATERIALS_SPECULAR;\n\tpublic declare propertyType: 'Specular';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_SPECULAR;\n\t\tthis.propertyType = 'Specular';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ISpecular> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tspecularFactor: 1.0,\n\t\t\tspecularTexture: null,\n\t\t\tspecularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),\n\t\t\tspecularColorFactor: [1.0, 1.0, 1.0] as vec3,\n\t\t\tspecularColorTexture: null,\n\t\t\tspecularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Specular.\n\t */\n\n\t/** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n\tpublic getSpecularFactor(): number {\n\t\treturn this.get('specularFactor');\n\t}\n\n\t/** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n\tpublic setSpecularFactor(factor: number): this {\n\t\treturn this.set('specularFactor', factor);\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n\tpublic getSpecularColorFactor(): vec3 {\n\t\treturn this.get('specularColorFactor');\n\t}\n\n\t/** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n\tpublic setSpecularColorFactor(factor: vec3): this {\n\t\treturn this.set('specularColorFactor', factor);\n\t}\n\n\t/**\n\t * Specular texture; linear multiplier. Configures the strength of the specular reflection in\n\t * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure\n\t * diffuse material.\n\t *\n\t * Only the alpha (A) channel is used for specular strength, but this texture may optionally\n\t * be packed with specular color (RGB) into a single texture.\n\t */\n\tpublic getSpecularTexture(): Texture | null {\n\t\treturn this.getRef('specularTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;\n\t}\n\n\t/** Sets specular texture. See {@link Specular.getSpecularTexture getSpecularTexture}. */\n\tpublic setSpecularTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularTexture', texture, { channels: A });\n\t}\n\n\t/**\n\t * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection\n\t * (RGB channels, encoded in sRGB) in the the dielectric BRDF.\n\t *\n\t * Only RGB channels are used here, but this texture may optionally be packed with a specular\n\t * factor (A) into a single texture.\n\t */\n\tpublic getSpecularColorTexture(): Texture | null {\n\t\treturn this.getRef('specularColorTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its specular color texture. If no texture is\n\t * attached, {@link TextureInfo} is `null`.\n\t */\n\tpublic getSpecularColorTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;\n\t}\n\n\t/** Sets specular color texture. See {@link Specular.getSpecularColorTexture getSpecularColorTexture}. */\n\tpublic setSpecularColorTexture(texture: Texture | null): this {\n\t\treturn this.setRef('specularColorTexture', texture, { channels: R | G | B, isColor: true });\n\t}\n}\n", "import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_SPECULAR } from '../constants.js';\nimport { Specular } from './specular.js';\n\nconst NAME = KHR_MATERIALS_SPECULAR;\n\ninterface SpecularDef {\n\tspecularFactor?: number;\n\tspecularColorFactor?: vec3;\n\tspecularTexture?: GLTF.ITextureInfo;\n\tspecularColorTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)\n * adjusts the strength of the specular reflection in the dielectric BRDF.\n *\n * KHRMaterialsSpecular is a better alternative to the older\n * {@link KHRMaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and\n * provides specular information while remaining within a metal/rough PBR workflow. A\n * value of zero disables the specular reflection, resulting in a pure diffuse material.\n *\n * Properties:\n * - {@link Specular}\n *\n * ### Example\n *\n * The `KHRMaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,\n * which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsSpecular, Specular } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const specularExtension = document.createExtension(KHRMaterialsSpecular);\n *\n * // Create a Specular property.\n * const specular = specularExtension.createSpecular()\n * \t.setSpecularFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_specular', specular);\n * ```\n */\nexport class KHRMaterialsSpecular extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Specular property for use on a {@link Material}. */\n\tpublic createSpecular(): Specular {\n\t\treturn new Specular(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst specular = this.createSpecular();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, specular);\n\n\t\t\t\tconst specularDef = materialDef.extensions[NAME] as SpecularDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (specularDef.specularFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularFactor(specularDef.specularFactor);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorFactor !== undefined) {\n\t\t\t\t\tspecular.setSpecularColorFactor(specularDef.specularColorFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (specularDef.specularTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t\tif (specularDef.specularColorTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = specularDef.specularColorTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tspecular.setSpecularColorTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(specular.getSpecularColorTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst specular = material.getExtension<Specular>(NAME);\n\t\t\t\tif (specular) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst specularDef = (materialDef.extensions[NAME] = {} as SpecularDef);\n\n\t\t\t\t\tif (specular.getSpecularFactor() !== 1) {\n\t\t\t\t\t\tspecularDef.specularFactor = specular.getSpecularFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {\n\t\t\t\t\t\tspecularDef.specularColorFactor = specular.getSpecularColorFactor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (specular.getSpecularTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t\tif (specular.getSpecularColorTexture()) {\n\t\t\t\t\t\tconst texture = specular.getSpecularColorTexture()!;\n\t\t\t\t\t\tconst textureInfo = specular.getSpecularColorTextureInfo()!;\n\t\t\t\t\t\tspecularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants.js';\n\ninterface ITransmission extends IProperty {\n\ttransmissionFactor: number;\n\ttransmissionTexture: Texture;\n\ttransmissionTextureInfo: TextureInfo;\n}\n\nconst { R } = TextureChannel;\n\n/**\n * Defines optical transmission on a PBR {@link Material}. See {@link KHRMaterialsTransmission}.\n */\nexport class Transmission extends ExtensionProperty<ITransmission> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;\n\tpublic declare extensionName: typeof KHR_MATERIALS_TRANSMISSION;\n\tpublic declare propertyType: 'Transmission';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_TRANSMISSION;\n\t\tthis.propertyType = 'Transmission';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransmission> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\ttransmissionFactor: 0.0,\n\t\t\ttransmissionTexture: null,\n\t\t\ttransmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo'),\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Transmission.\n\t */\n\n\t/** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n\tpublic getTransmissionFactor(): number {\n\t\treturn this.get('transmissionFactor');\n\t}\n\n\t/** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n\tpublic setTransmissionFactor(factor: number): this {\n\t\treturn this.set('transmissionFactor', factor);\n\t}\n\n\t/**\n\t * Transmission texture; linear multiplier. The `r` channel of this texture specifies\n\t * transmission [0-1] of the material's surface. By default this is a thin transparency\n\t * effect, but volume effects (refraction, subsurface scattering) may be introduced with the\n\t * addition of the `KHR_materials_volume` extension.\n\t */\n\tpublic getTransmissionTexture(): Texture | null {\n\t\treturn this.getRef('transmissionTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its transmission texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getTransmissionTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;\n\t}\n\n\t/** Sets transmission texture. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */\n\tpublic setTransmissionTexture(texture: Texture | null): this {\n\t\treturn this.setRef('transmissionTexture', texture, { channels: R });\n\t}\n}\n", "import { Extension, GLTF, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_TRANSMISSION } from '../constants.js';\nimport { Transmission } from './transmission.js';\n\nconst NAME = KHR_MATERIALS_TRANSMISSION;\n\ninterface TransmissionDef {\n\ttransmissionFactor?: number;\n\ttransmissionTexture?: GLTF.ITextureInfo;\n}\n\n/**\n * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)\n * provides a common type of optical transparency: infinitely-thin materials with no refraction,\n * scattering, or dispersion.\n *\n * ![Illustration](/media/extensions/khr-materials-transmission.png)\n *\n * > _**Figure:** Sphere using `KHR_materials_transmission` with varying roughness (0.0, 0.2, 0.4).\n * > Source: Khronos Group._\n *\n * While default PBR materials using alpha blending become invisible as their opacity approaches\n * zero, a transmissive material continues to reflect light in a glass-like manner, even at low\n * transmission values. When combined with {@link KHRMaterialsVolume}, transmission may be used for\n * thicker materials and refractive effects.\n *\n * Properties:\n * - {@link Transmission}\n *\n * ### Example\n *\n * The `KHRMaterialsTransmission` class provides a single {@link ExtensionProperty} type,\n * `Transmission`, which may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsTransmission, Transmission } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transmissionExtension = document.createExtension(KHRMaterialsTransmission);\n *\n * // Create a Transmission property.\n * const transmission = transmissionExtension.createTransmission()\n * \t.setTransmissionFactor(1.0);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_transmission', transmission);\n * ```\n */\nexport class KHRMaterialsTransmission extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Transmission property for use on a {@link Material}. */\n\tpublic createTransmission(): Transmission {\n\t\treturn new Transmission(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst transmission = this.createTransmission();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, transmission);\n\n\t\t\t\tconst transmissionDef = materialDef.extensions[NAME] as TransmissionDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (transmissionDef.transmissionFactor !== undefined) {\n\t\t\t\t\ttransmission.setTransmissionFactor(transmissionDef.transmissionFactor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (transmissionDef.transmissionTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = transmissionDef.transmissionTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\ttransmission.setTransmissionTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(transmission.getTransmissionTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst transmission = material.getExtension<Transmission>(NAME);\n\t\t\t\tif (transmission) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst transmissionDef = (materialDef.extensions[NAME] = {\n\t\t\t\t\t\ttransmissionFactor: transmission.getTransmissionFactor(),\n\t\t\t\t\t} as TransmissionDef);\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (transmission.getTransmissionTexture()) {\n\t\t\t\t\t\tconst texture = transmission.getTransmissionTexture()!;\n\t\t\t\t\t\tconst textureInfo = transmission.getTransmissionTextureInfo()!;\n\t\t\t\t\t\ttransmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants.js';\n\n/**\n * Converts a PBR {@link Material} to an unlit shading model. See {@link KHRMaterialsUnlit}.\n */\nexport class Unlit extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_UNLIT;\n\tpublic declare extensionName: typeof KHR_MATERIALS_UNLIT;\n\tpublic declare propertyType: 'Unlit';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_UNLIT;\n\t\tthis.propertyType = 'Unlit';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n}\n", "import { Extension, PropertyType, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_UNLIT } from '../constants.js';\nimport { Unlit } from './unlit.js';\n\nconst NAME = KHR_MATERIALS_UNLIT;\n\n/**\n * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)\n * defines an unlit shading model for use in glTF 2.0 materials.\n *\n * ![Illustration](/media/extensions/khr-materials-unlit.png)\n *\n * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving\n * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._\n *\n * Unlit (also \"Shadeless\" or \"Constant\") materials provide a simple alternative to the Physically\n * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are\n * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.\n * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic\n * effects like hand painted illustrative styles or baked toon shaders.\n *\n * Properties:\n * - {@link Unlit}\n *\n * ### Example\n *\n * The `KHRMaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may\n * be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsUnlit, Unlit } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const unlitExtension = document.createExtension(KHRMaterialsUnlit);\n *\n * // Create an Unlit property.\n * const unlit = unlitExtension.createUnlit();\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_unlit', unlit);\n * ```\n */\nexport class KHRMaterialsUnlit extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Unlit property for use on a {@link Material}. */\n\tpublic createUnlit(): Unlit {\n\t\treturn new Unlit(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst materialDefs = context.jsonDoc.json.materials || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, this.createUnlit());\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tif (material.getExtension<Unlit>(NAME)) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\t\t\tmaterialDef.extensions[NAME] = {};\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty, IProperty, Material, Nullable, RefSet } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants.js';\nimport type { Variant } from './variant.js';\n\ninterface IMapping extends IProperty {\n\tmaterial: Material;\n\tvariants: RefSet<Variant>;\n}\n\n/**\n * Maps {@link Variant}s to {@link Material}s. See {@link KHRMaterialsVariants}.\n */\nexport class Mapping extends ExtensionProperty<IMapping> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Mapping';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Mapping';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n\n\tprotected getDefaults(): Nullable<IMapping> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { material: null, variants: new RefSet<Variant>() });\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic getMaterial(): Material | null {\n\t\treturn this.getRef('material');\n\t}\n\n\t/** The {@link Material} designated for this {@link Primitive}, under the given variants. */\n\tpublic setMaterial(material: Material | null): this {\n\t\treturn this.setRef('material', material);\n\t}\n\n\t/** Adds a {@link Variant} to this mapping. */\n\tpublic addVariant(variant: Variant): this {\n\t\treturn this.addRef('variants', variant);\n\t}\n\n\t/** Removes a {@link Variant} from this mapping. */\n\tpublic removeVariant(variant: Variant): this {\n\t\treturn this.removeRef('variants', variant);\n\t}\n\n\t/** Lists {@link Variant}s in this mapping. */\n\tpublic listVariants(): Variant[] {\n\t\treturn this.listRefs('variants');\n\t}\n}\n", "import { ExtensionProperty, IProperty, Nullable, PropertyType, RefSet } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants.js';\nimport type { Mapping } from './mapping.js';\n\ninterface IMappingList extends IProperty {\n\tmappings: RefSet<Mapping>;\n}\n\n/**\n * List of material variant {@link Mapping}s. See {@link KHRMaterialsVariants}.\n */\nexport class MappingList extends ExtensionProperty<IMappingList> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'MappingList';\n\tpublic declare parentTypes: [PropertyType.PRIMITIVE];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'MappingList';\n\t\tthis.parentTypes = [PropertyType.PRIMITIVE];\n\t}\n\n\tprotected getDefaults(): Nullable<IMappingList> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, { mappings: new RefSet<Mapping>() });\n\t}\n\n\t/** Adds a {@link Mapping} to this mapping. */\n\tpublic addMapping(mapping: Mapping): this {\n\t\treturn this.addRef('mappings', mapping);\n\t}\n\n\t/** Removes a {@link Mapping} from the list for this {@link Primitive}. */\n\tpublic removeMapping(mapping: Mapping): this {\n\t\treturn this.removeRef('mappings', mapping);\n\t}\n\n\t/** Lists {@link Mapping}s in this {@link Primitive}. */\n\tpublic listMappings(): Mapping[] {\n\t\treturn this.listRefs('mappings');\n\t}\n}\n", "import { ExtensionProperty } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants.js';\n\n/**\n * Defines a variant of a {@link Material}. See {@link KHRMaterialsVariants}.\n */\nexport class Variant extends ExtensionProperty {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VARIANTS;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VARIANTS;\n\tpublic declare propertyType: 'Variant';\n\tpublic declare parentTypes: ['MappingList'];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VARIANTS;\n\t\tthis.propertyType = 'Variant';\n\t\tthis.parentTypes = ['MappingList'];\n\t}\n}\n", "import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VARIANTS } from '../constants.js';\nimport { Mapping } from './mapping.js';\nimport { MappingList } from './mapping-list.js';\nimport { Variant } from './variant.js';\n\nconst NAME = KHR_MATERIALS_VARIANTS;\n\ninterface VariantsRootDef {\n\tvariants: VariantDef[];\n}\n\ninterface VariantDef {\n\tname?: string;\n}\n\ninterface VariantPrimDef {\n\tmappings: VariantMappingDef[];\n}\n\ninterface VariantMappingDef {\n\tmaterial: number;\n\tvariants: number[];\n}\n\n/**\n * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)\n * defines alternate {@link Material} states for any {@link Primitive} in the scene.\n *\n * ![Illustration](/media/extensions/khr-materials-variants.jpg)\n *\n * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._\n *\n * Uses include product configurators, night/day states, healthy/damaged states, etc. The\n * `KHRMaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,\n * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of\n * defining the variants available to an application. Triggering a variant is out of scope of this\n * extension, but could be handled in the application with a UI dropdown, particular game states,\n * and so on.\n *\n * Mesh geometry cannot be changed by this extension, although another extension\n * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.\n *\n * Properties:\n * - {@link Variant}\n * - {@link Mapping}\n * - {@link MappingList}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMaterialsVariants } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const variantExtension = document.createExtension(KHRMaterialsVariants);\n *\n * // Create some Variant states.\n * const healthyVariant = variantExtension.createVariant('Healthy');\n * const damagedVariant = variantExtension.createVariant('Damaged');\n *\n * // Create mappings from a Variant state to a Material.\n * const healthyMapping = variantExtension.createMapping()\n * \t.addVariant(healthyVariant)\n * \t.setMaterial(healthyMat);\n * const damagedMapping = variantExtension.createMapping()\n * \t.addVariant(damagedVariant)\n * \t.setMaterial(damagedMat);\n *\n * // Attach the mappings to a Primitive.\n * primitive.setExtension(\n * \t'KHR_materials_variants',\n * \tvariantExtension.createMappingList()\n * \t\t.addMapping(healthyMapping)\n * \t\t.addMapping(damagedMapping)\n * );\n * ```\n *\n * A few notes about this extension:\n *\n * 1. Viewers that don't recognized this extension will show the default material for each primitive\n * \t instead, so assign that material accordingly. This material can be  but doesn't have to be \n * \t associated with one of the available variants.\n * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active\n * \t Variant will be chosen by the viewer.\n * 3. Variant names are how these states are identified, so choose informative names.\n * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have\n * \t the option of downloading only textures associated with the default state, and lazy-loading\n * \t any textures for inactive Variants only when they are needed.\n */\nexport class KHRMaterialsVariants extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new MappingList property. */\n\tpublic createMappingList(): MappingList {\n\t\treturn new MappingList(this.document.getGraph());\n\t}\n\n\t/** Creates a new Variant property. */\n\tpublic createVariant(name = ''): Variant {\n\t\treturn new Variant(this.document.getGraph(), name);\n\t}\n\n\t/** Creates a new Mapping property. */\n\tpublic createMapping(): Mapping {\n\t\treturn new Mapping(this.document.getGraph());\n\t}\n\n\t/** Lists all Variants on the current Document. */\n\tpublic listVariants(): Variant[] {\n\t\treturn Array.from(this.properties).filter((prop) => prop instanceof Variant) as Variant[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tif (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME]) return this;\n\n\t\t// Read all top-level variant names.\n\t\tconst variantsRootDef = jsonDoc.json.extensions[NAME] as VariantsRootDef;\n\t\tconst variantDefs = variantsRootDef.variants || [];\n\t\tconst variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ''));\n\n\t\t// For each mesh primitive, read its material/variant mappings.\n\t\tconst meshDefs = jsonDoc.json.meshes || [];\n\t\tmeshDefs.forEach((meshDef, meshIndex) => {\n\t\t\tconst mesh = context.meshes[meshIndex];\n\t\t\tconst primDefs = meshDef.primitives || [];\n\n\t\t\tprimDefs.forEach((primDef, primIndex) => {\n\t\t\t\tif (!primDef.extensions || !primDef.extensions[NAME]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst mappingList = this.createMappingList();\n\n\t\t\t\tconst variantPrimDef = primDef.extensions[NAME] as VariantPrimDef;\n\t\t\t\tfor (const mappingDef of variantPrimDef.mappings) {\n\t\t\t\t\tconst mapping = this.createMapping();\n\n\t\t\t\t\tif (mappingDef.material !== undefined) {\n\t\t\t\t\t\tmapping.setMaterial(context.materials[mappingDef.material]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const variantIndex of mappingDef.variants || []) {\n\t\t\t\t\t\tmapping.addVariant(variants[variantIndex]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingList.addMapping(mapping);\n\t\t\t\t}\n\n\t\t\t\tmesh.listPrimitives()[primIndex].setExtension(NAME, mappingList);\n\t\t\t});\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tconst variants = this.listVariants();\n\t\tif (!variants.length) return this;\n\n\t\t// Write all top-level variant names.\n\t\tconst variantDefs = [];\n\t\tconst variantIndexMap = new Map<Variant, number>();\n\t\tfor (const variant of variants) {\n\t\t\tvariantIndexMap.set(variant, variantDefs.length);\n\t\t\tvariantDefs.push(context.createPropertyDef(variant));\n\t\t}\n\n\t\t// For each mesh primitive, write its material/variant mappings.\n\t\tfor (const mesh of this.document.getRoot().listMeshes()) {\n\t\t\tconst meshIndex = context.meshIndexMap.get(mesh)!;\n\n\t\t\tmesh.listPrimitives().forEach((prim, primIndex) => {\n\t\t\t\tconst mappingList = prim.getExtension<MappingList>(NAME);\n\t\t\t\tif (!mappingList) return;\n\n\t\t\t\tconst primDef = context.jsonDoc.json.meshes![meshIndex].primitives[primIndex];\n\n\t\t\t\tconst mappingDefs = mappingList.listMappings().map((mapping) => {\n\t\t\t\t\tconst mappingDef = context.createPropertyDef(mapping) as VariantMappingDef;\n\n\t\t\t\t\tconst material = mapping.getMaterial();\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tmappingDef.material = context.materialIndexMap.get(material)!;\n\t\t\t\t\t}\n\n\t\t\t\t\tmappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant)!);\n\n\t\t\t\t\treturn mappingDef;\n\t\t\t\t});\n\n\t\t\t\tprimDef.extensions = primDef.extensions || {};\n\t\t\t\tprimDef.extensions[NAME] = { mappings: mappingDefs };\n\t\t\t});\n\t\t}\n\n\t\tjsonDoc.json.extensions = jsonDoc.json.extensions || {};\n\t\tjsonDoc.json.extensions[NAME] = { variants: variantDefs };\n\n\t\treturn this;\n\t}\n}\n", "import {\n\tExtensionProperty,\n\tIProperty,\n\tNullable,\n\tPropertyType,\n\tTexture,\n\tTextureChannel,\n\tTextureInfo,\n\tvec3,\n} from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants.js';\n\ninterface IVolume extends IProperty {\n\tthicknessFactor: number;\n\tthicknessTexture: Texture;\n\tthicknessTextureInfo: TextureInfo;\n\tattenuationDistance: number;\n\tattenuationColor: vec3;\n}\n\nconst { G } = TextureChannel;\n\n/**\n * Defines volume on a PBR {@link Material}. See {@link KHRMaterialsVolume}.\n */\nexport class Volume extends ExtensionProperty<IVolume> {\n\tpublic static EXTENSION_NAME = KHR_MATERIALS_VOLUME;\n\tpublic declare extensionName: typeof KHR_MATERIALS_VOLUME;\n\tpublic declare propertyType: 'Volume';\n\tpublic declare parentTypes: [PropertyType.MATERIAL];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_MATERIALS_VOLUME;\n\t\tthis.propertyType = 'Volume';\n\t\tthis.parentTypes = [PropertyType.MATERIAL];\n\t}\n\n\tprotected getDefaults(): Nullable<IVolume> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\tthicknessFactor: 0.0,\n\t\t\tthicknessTexture: null,\n\t\t\tthicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),\n\t\t\tattenuationDistance: Infinity,\n\t\t\tattenuationColor: [1.0, 1.0, 1.0] as vec3,\n\t\t});\n\t}\n\n\t/**********************************************************************************************\n\t * Thickness.\n\t */\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic getThicknessFactor(): number {\n\t\treturn this.get('thicknessFactor');\n\t}\n\n\t/**\n\t * Thickness of the volume beneath the surface in meters in the local coordinate system of the\n\t * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume\n\t * boundary. The doubleSided property has no effect on volume boundaries.\n\t */\n\tpublic setThicknessFactor(factor: number): this {\n\t\treturn this.set('thicknessFactor', factor);\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic getThicknessTexture(): Texture | null {\n\t\treturn this.getRef('thicknessTexture');\n\t}\n\n\t/**\n\t * Settings affecting the material's use of its thickness texture. If no texture is attached,\n\t * {@link TextureInfo} is `null`.\n\t */\n\tpublic getThicknessTextureInfo(): TextureInfo | null {\n\t\treturn this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;\n\t}\n\n\t/**\n\t * Texture that defines the thickness, stored in the G channel. This will be multiplied by\n\t * thicknessFactor.\n\t */\n\tpublic setThicknessTexture(texture: Texture | null): this {\n\t\treturn this.setRef('thicknessTexture', texture, { channels: G });\n\t}\n\n\t/**********************************************************************************************\n\t * Attenuation.\n\t */\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic getAttenuationDistance(): number {\n\t\treturn this.get('attenuationDistance');\n\t}\n\n\t/**\n\t * Density of the medium given as the average distance in meters that light travels in the\n\t * medium before interacting with a particle.\n\t */\n\tpublic setAttenuationDistance(distance: number): this {\n\t\treturn this.set('attenuationDistance', distance);\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic getAttenuationColor(): vec3 {\n\t\treturn this.get('attenuationColor');\n\t}\n\n\t/**\n\t * Color (linear) that white light turns into due to absorption when reaching the attenuation\n\t * distance.\n\t */\n\tpublic setAttenuationColor(color: vec3): this {\n\t\treturn this.set('attenuationColor', color);\n\t}\n}\n", "import { Extension, GLTF, ReaderContext, WriterContext, vec3, MathUtils, PropertyType } from '@gltf-transform/core';\nimport { KHR_MATERIALS_VOLUME } from '../constants.js';\nimport { Volume } from './volume.js';\n\nconst NAME = KHR_MATERIALS_VOLUME;\n\ninterface VolumeDef {\n\tthicknessFactor?: number;\n\tthicknessTexture?: GLTF.ITextureInfo;\n\tattenuationDistance?: number;\n\tattenuationColor?: vec3;\n}\n\n/**\n * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)\n * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or\n * translucency.\n *\n * ![Illustration](/media/extensions/khr-materials-volume.png)\n *\n * > _**Figure:** Base color changes the amount of light passing through the volume boundary\n * > (left). The overall color of the object is the same everywhere, as if the object is covered\n * > with a colored, transparent foil. Absorption changes the amount of light traveling through the\n * > volume (right). The overall color depends on the distance the light traveled through it; at\n * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at\n * > large distances. Source: Khronos Group._\n *\n * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an\n * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume\n * extension makes it possible to turn the surface into an interface between volumes. The mesh to\n * which the material is attached defines the boundaries of an homogeneous medium and therefore must\n * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering\n * effects will require future (TBD) extensions.\n *\n * The volume extension must be combined with {@link KHRMaterialsTransmission} or\n * `KHR_materials_translucency` in order to define entry of light into the volume.\n *\n * Properties:\n * - {@link Volume}\n *\n * ### Example\n *\n * The `KHRMaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which\n * may be attached to any {@link Material} instance. For example:\n *\n * ```typescript\n * import { KHRMaterialsVolume, Volume } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const volumeExtension = document.createExtension(KHRMaterialsVolume);\n *\n * // Create a Volume property.\n * const volume = volumeExtension.createVolume()\n * \t.setThicknessFactor(1.0)\n * \t.setThicknessTexture(texture)\n * \t.setAttenuationDistance(1.0)\n * \t.setAttenuationColorFactor([1, 0.5, 0.5]);\n *\n * // Attach the property to a Material.\n * material.setExtension('KHR_materials_volume', volume);\n * ```\n *\n * A thickness texture is required in most realtime renderers, and can be baked in software such as\n * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.\n */\nexport class KHRMaterialsVolume extends Extension {\n\tpublic static readonly EXTENSION_NAME = NAME;\n\tpublic readonly extensionName = NAME;\n\tpublic readonly prereadTypes = [PropertyType.MESH];\n\tpublic readonly prewriteTypes = [PropertyType.MESH];\n\n\t/** Creates a new Volume property for use on a {@link Material}. */\n\tpublic createVolume(): Volume {\n\t\treturn new Volume(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(_context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(_context: WriterContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\t\tconst materialDefs = jsonDoc.json.materials || [];\n\t\tconst textureDefs = jsonDoc.json.textures || [];\n\t\tmaterialDefs.forEach((materialDef, materialIndex) => {\n\t\t\tif (materialDef.extensions && materialDef.extensions[NAME]) {\n\t\t\t\tconst volume = this.createVolume();\n\t\t\t\tcontext.materials[materialIndex].setExtension(NAME, volume);\n\n\t\t\t\tconst volumeDef = materialDef.extensions[NAME] as VolumeDef;\n\n\t\t\t\t// Factors.\n\n\t\t\t\tif (volumeDef.thicknessFactor !== undefined) {\n\t\t\t\t\tvolume.setThicknessFactor(volumeDef.thicknessFactor);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationDistance !== undefined) {\n\t\t\t\t\tvolume.setAttenuationDistance(volumeDef.attenuationDistance);\n\t\t\t\t}\n\t\t\t\tif (volumeDef.attenuationColor !== undefined) {\n\t\t\t\t\tvolume.setAttenuationColor(volumeDef.attenuationColor);\n\t\t\t\t}\n\n\t\t\t\t// Textures.\n\n\t\t\t\tif (volumeDef.thicknessTexture !== undefined) {\n\t\t\t\t\tconst textureInfoDef = volumeDef.thicknessTexture;\n\t\t\t\t\tconst texture = context.textures[textureDefs[textureInfoDef.index].source!];\n\t\t\t\t\tvolume.setThicknessTexture(texture);\n\t\t\t\t\tcontext.setTextureInfo(volume.getThicknessTextureInfo()!, textureInfoDef);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic prewrite(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tconst volume = material.getExtension<Volume>(NAME);\n\t\t\t\tif (volume) {\n\t\t\t\t\tconst materialIndex = context.materialIndexMap.get(material)!;\n\t\t\t\t\tconst materialDef = jsonDoc.json.materials![materialIndex];\n\t\t\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\n\t\t\t\t\t// Factors.\n\n\t\t\t\t\tconst volumeDef = (materialDef.extensions[NAME] = {} as VolumeDef);\n\n\t\t\t\t\tif (volume.getThicknessFactor() > 0) {\n\t\t\t\t\t\tvolumeDef.thicknessFactor = volume.getThicknessFactor();\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isFinite(volume.getAttenuationDistance())) {\n\t\t\t\t\t\tvolumeDef.attenuationDistance = volume.getAttenuationDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {\n\t\t\t\t\t\tvolumeDef.attenuationColor = volume.getAttenuationColor();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Textures.\n\n\t\t\t\t\tif (volume.getThicknessTexture()) {\n\t\t\t\t\t\tconst texture = volume.getThicknessTexture()!;\n\t\t\t\t\t\tconst textureInfo = volume.getThicknessTextureInfo()!;\n\t\t\t\t\t\tvolumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { Extension, ReaderContext, WriterContext } from '@gltf-transform/core';\nimport { KHR_MESH_QUANTIZATION } from '../constants.js';\n\nconst NAME = KHR_MESH_QUANTIZATION;\n\n/**\n * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)\n * expands allowed component types for vertex attributes to include 16- and 8-bit storage.\n *\n * Quantization provides a memory/precision tradeoff  depending on the application needs, 16-bit or\n * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10\n * mesh might be written to a uint16 {@link Accessor}, with values `065536`, normalized to be\n * interpreted as `01`. With an additional 10x scale on any node {@link Node} instantiating the\n * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and\n * up to 50% file size reduction.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing more flexible use of\n * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data\n * types would yield an invalid glTF document, under the stricter core glTF specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { KHRMeshQuantization } from '@gltf-transform/extensions';\n * import { quantize } from '@gltf-transform/functions';\n *\n * // Create an Extension attached to the Document.\n * const quantizationExtension = document.createExtension(KHRMeshQuantization).setRequired(true);\n *\n * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,\n * // or apply the provided quantize() function to compute quantized accessors automatically:\n * await document.transform(quantize({\n * \tquantizePosition: 16,\n * \tquantizeNormal: 12,\n * \tquantizeTexcoord: 14\n * }));\n * ```\n *\n * For more documentation about automatic quantization, see the {@link quantize} function.\n */\nexport class KHRMeshQuantization extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tread(_: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\twrite(_: WriterContext): this {\n\t\treturn this;\n\t}\n}\n", "import { read as readKTX, KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC } from 'ktx-parse';\nimport {\n\tExtension,\n\tImageUtils,\n\tImageUtilsFormat,\n\tPropertyType,\n\tReaderContext,\n\tWriterContext,\n\tvec2,\n} from '@gltf-transform/core';\nimport { KHR_TEXTURE_BASISU } from '../constants.js';\n\nconst NAME = KHR_TEXTURE_BASISU;\n\ninterface BasisuDef {\n\tsource: number;\n}\n\nclass KTX2ImageUtils implements ImageUtilsFormat {\n\tmatch(array: Uint8Array): boolean {\n\t\treturn (\n\t\t\tarray[0] === 0xab &&\n\t\t\tarray[1] === 0x4b &&\n\t\t\tarray[2] === 0x54 &&\n\t\t\tarray[3] === 0x58 &&\n\t\t\tarray[4] === 0x20 &&\n\t\t\tarray[5] === 0x32 &&\n\t\t\tarray[6] === 0x30 &&\n\t\t\tarray[7] === 0xbb &&\n\t\t\tarray[8] === 0x0d &&\n\t\t\tarray[9] === 0x0a &&\n\t\t\tarray[10] === 0x1a &&\n\t\t\tarray[11] === 0x0a\n\t\t);\n\t}\n\tgetSize(array: Uint8Array): vec2 {\n\t\tconst container = readKTX(array);\n\t\treturn [container.pixelWidth, container.pixelHeight];\n\t}\n\tgetChannels(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\treturn dfd.samples.length === 2 && (dfd.samples[1].channelType & 0xf) === 15 ? 4 : 3;\n\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\treturn (dfd.samples[0].channelType & 0xf) === 3 ? 4 : 3;\n\t\t}\n\t\tthrow new Error(`Unexpected KTX2 colorModel, \"${dfd.colorModel}\".`);\n\t}\n\tgetVRAMByteLength(array: Uint8Array): number {\n\t\tconst container = readKTX(array);\n\t\tconst hasAlpha = this.getChannels(array) > 3;\n\n\t\tlet uncompressedBytes = 0;\n\t\tfor (let i = 0; i < container.levels.length; i++) {\n\t\t\tconst level = container.levels[i];\n\n\t\t\t// Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.\n\t\t\tif (level.uncompressedByteLength) {\n\t\t\t\tuncompressedBytes += level.uncompressedByteLength;\n\t\t\t} else {\n\t\t\t\tconst levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));\n\t\t\t\tconst levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));\n\t\t\t\tconst blockSize = hasAlpha ? 16 : 8;\n\t\t\t\tuncompressedBytes += (levelWidth / 4) * (levelHeight / 4) * blockSize;\n\t\t\t}\n\t\t}\n\n\t\treturn uncompressedBytes;\n\t}\n}\n\n/**\n * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)\n * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.\n *\n * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a\n * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In\n * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not\n * guaranteed. GPU textures often require more careful tuning during compression to maintain image\n * quality, but this extra effort is worthwhile for applications that need to maintain a smooth\n * framerate while uploading images, or where GPU memory is limited.\n *\n * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the\n * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type\n * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the\n * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF\n * specification.\n *\n * Properties:\n * - N/A\n *\n * ### Example\n *\n * ```typescript\n * import { KHRTextureBasisu } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const basisuExtension = document.createExtension(KHRTextureBasisu)\n * \t.setRequired(true);\n * document.createTexture('MyCompressedTexture')\n * \t.setMimeType('image/ktx2')\n * \t.setImage(fs.readFileSync('my-texture.ktx2'));\n * ```\n *\n * Compression is not done automatically when adding the extension as shown above  you must\n * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The\n * glTF Transform CLI has functions to help with this, or any similar KTX2-capable\n * utility will work.\n *\n * When the `KHR_texture_basisu` extension is added to a file by glTF Transform, the extension\n * should always be required. This tool does not support writing assets that \"fall back\" to optional\n * PNG or JPEG image data.\n *\n * > _**NOTICE:** Compressing some textures  particularly 3-component (RGB) normal maps, and\n * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.\n * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the\n * > texture before compressing it.\n * >\n * > For best results when authoring new textures, use\n * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize\n * > prominent UV seams._\n */\nexport class KHRTextureBasisu extends Extension {\n\tpublic readonly extensionName = NAME;\n\t/** @hidden */\n\tpublic readonly prereadTypes = [PropertyType.TEXTURE];\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** @hidden */\n\tpublic static register(): void {\n\t\tImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());\n\t}\n\n\t/** @hidden */\n\tpublic preread(context: ReaderContext): this {\n\t\tcontext.jsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\tif (textureDef.extensions && textureDef.extensions[NAME]) {\n\t\t\t\tconst basisuDef = textureDef.extensions[NAME] as BasisuDef;\n\t\t\t\ttextureDef.source = basisuDef.source;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpublic read(context: ReaderContext): this {\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst jsonDoc = context.jsonDoc;\n\n\t\tthis.document\n\t\t\t.getRoot()\n\t\t\t.listTextures()\n\t\t\t.forEach((texture) => {\n\t\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\t\tconst imageIndex = context.imageIndexMap.get(texture);\n\t\t\t\t\tjsonDoc.json.textures!.forEach((textureDef) => {\n\t\t\t\t\t\tif (textureDef.source === imageIndex) {\n\t\t\t\t\t\t\ttextureDef.extensions = textureDef.extensions || {};\n\t\t\t\t\t\t\ttextureDef.extensions[NAME] = { source: textureDef.source };\n\t\t\t\t\t\t\tdelete textureDef.source;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn this;\n\t}\n}\n", "import { ExtensionProperty, IProperty, Nullable, vec2 } from '@gltf-transform/core';\nimport { PropertyType } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants.js';\n\ninterface ITransform extends IProperty {\n\toffset: vec2;\n\trotation: number;\n\tscale: vec2;\n\ttexCoord: number | null; // null  do not override TextureInfo.\n}\n\n/**\n * Defines UV transform for a {@link TextureInfo}. See {@link KHRTextureTransform}.\n */\nexport class Transform extends ExtensionProperty<ITransform> {\n\tpublic static EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;\n\tpublic declare extensionName: typeof KHR_TEXTURE_TRANSFORM;\n\tpublic declare propertyType: 'Transform';\n\tpublic declare parentTypes: [PropertyType.TEXTURE_INFO];\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_TEXTURE_TRANSFORM;\n\t\tthis.propertyType = 'Transform';\n\t\tthis.parentTypes = [PropertyType.TEXTURE_INFO];\n\t}\n\n\tprotected getDefaults(): Nullable<ITransform> {\n\t\treturn Object.assign(super.getDefaults() as IProperty, {\n\t\t\toffset: [0.0, 0.0] as vec2,\n\t\t\trotation: 0,\n\t\t\tscale: [1.0, 1.0] as vec2,\n\t\t\ttexCoord: null,\n\t\t});\n\t}\n\n\tpublic getOffset(): vec2 {\n\t\treturn this.get('offset');\n\t}\n\tpublic setOffset(offset: vec2): this {\n\t\treturn this.set('offset', offset);\n\t}\n\n\tpublic getRotation(): number {\n\t\treturn this.get('rotation');\n\t}\n\tpublic setRotation(rotation: number): this {\n\t\treturn this.set('rotation', rotation);\n\t}\n\n\tpublic getScale(): vec2 {\n\t\treturn this.get('scale');\n\t}\n\tpublic setScale(scale: vec2): this {\n\t\treturn this.set('scale', scale);\n\t}\n\n\tpublic getTexCoord(): number | null {\n\t\treturn this.get('texCoord');\n\t}\n\tpublic setTexCoord(texCoord: number | null): this {\n\t\treturn this.set('texCoord', texCoord);\n\t}\n}\n", "import { Extension, MathUtils, ReaderContext, WriterContext, vec2 } from '@gltf-transform/core';\nimport { KHR_TEXTURE_TRANSFORM } from '../constants.js';\nimport { Transform } from './transform.js';\n\nconst NAME = KHR_TEXTURE_TRANSFORM;\n\ninterface TransformDef {\n\toffset?: vec2;\n\trotation?: number;\n\tscale?: vec2;\n\ttexCoord?: number;\n}\n\n/**\n * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)\n * adds offset, rotation, and scale to {@link TextureInfo} properties.\n *\n * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving\n * performance when used in techniques like texture atlases. UV transforms cannot be animated at\n * this time.\n *\n * Properties:\n * - {@link Transform}\n *\n * ### Example\n *\n * The `KHRTextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which\n * may be attached to any {@link TextureInfo} instance. For example:\n *\n * ```typescript\n * import { KHRTextureTransform } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const transformExtension = document.createExtension(KHRTextureTransform)\n * \t.setRequired(true);\n *\n * // Create a reusable Transform.\n * const transform = transformExtension.createTransform()\n * \t.setScale([100, 100]);\n *\n * // Apply the Transform to a Material's baseColorTexture.\n * document.createMaterial()\n * \t.setBaseColorTexture(myTexture)\n * \t.getBaseColorTextureInfo()\n * \t.setExtension('KHR_texture_transform', transform);\n * ```\n */\nexport class KHRTextureTransform extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new Transform property for use on a {@link TextureInfo}. */\n\tpublic createTransform(): Transform {\n\t\treturn new Transform(this.document.getGraph());\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tfor (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {\n\t\t\tif (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME]) continue;\n\n\t\t\tconst transform = this.createTransform();\n\t\t\tconst transformDef = textureInfoDef.extensions[NAME] as TransformDef;\n\n\t\t\tif (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);\n\t\t\tif (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);\n\t\t\tif (transformDef.scale !== undefined) transform.setScale(transformDef.scale);\n\t\t\tif (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);\n\n\t\t\ttextureInfo.setExtension(NAME, transform);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst textureInfoEntries = Array.from(context.textureInfoDefMap.entries());\n\t\tfor (const [textureInfo, textureInfoDef] of textureInfoEntries) {\n\t\t\tconst transform = textureInfo.getExtension<Transform>(NAME);\n\t\t\tif (!transform) continue;\n\n\t\t\ttextureInfoDef.extensions = textureInfoDef.extensions || {};\n\t\t\tconst transformDef = {} as TransformDef;\n\n\t\t\tconst eq = MathUtils.eq;\n\t\t\tif (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();\n\t\t\tif (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();\n\t\t\tif (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();\n\t\t\tif (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord()!;\n\n\t\t\ttextureInfoDef.extensions[NAME] = transformDef;\n\t\t}\n\t\treturn this;\n\t}\n}\n", "import { Nullable, PropertyType, ExtensionProperty, IProperty } from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants.js';\n\ntype Term = string;\ntype TermDefinition = string | Record<string, string>;\n\ntype Value = string | number | boolean;\n\nconst PARENT_TYPES = [\n\tPropertyType.ROOT,\n\tPropertyType.SCENE,\n\tPropertyType.NODE,\n\tPropertyType.MESH,\n\tPropertyType.MATERIAL,\n\tPropertyType.TEXTURE,\n\tPropertyType.ANIMATION,\n];\n\ninterface IPacket extends IProperty {\n\t// https://json-ld.org/spec/latest/json-ld/#the-context\n\tcontext: Record<Term, TermDefinition>;\n\tproperties: Record<string, Value | Record<string, unknown>>;\n}\n\n/**\n * Defines an XMP packet associated with a Document or Property. See {@link KHRXMP}.\n */\nexport class Packet extends ExtensionProperty<IPacket> {\n\tpublic declare propertyType: 'Packet';\n\tpublic declare parentTypes: typeof PARENT_TYPES;\n\tpublic declare extensionName: typeof KHR_XMP_JSON_LD;\n\tpublic static EXTENSION_NAME = KHR_XMP_JSON_LD;\n\n\tprotected init(): void {\n\t\tthis.extensionName = KHR_XMP_JSON_LD;\n\t\tthis.propertyType = 'Packet';\n\t\tthis.parentTypes = PARENT_TYPES;\n\t}\n\n\tprotected getDefaults(): Nullable<IPacket> {\n\t\treturn Object.assign(super.getDefaults(), { context: {}, properties: {} });\n\t}\n\n\t/**********************************************************************************************\n\t * Context.\n\t */\n\n\t/**\n\t * Returns the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t */\n\tpublic getContext(): Record<Term, TermDefinition> {\n\t\treturn this.get('context');\n\t}\n\n\t/**\n\t * Sets the XMP context definition URL for the given term.\n\t * See: https://json-ld.org/spec/latest/json-ld/#the-context\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setContext({\n\t *   dc: 'http://purl.org/dc/elements/1.1/',\n\t *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',\n\t * });\n\t * ```\n\t *\n\t * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.\n\t * @param definition URI for XMP namespace.\n\t */\n\tpublic setContext(context: Record<Term, TermDefinition>): this {\n\t\treturn this.set('context', { ...context });\n\t}\n\n\t/**********************************************************************************************\n\t * Properties.\n\t */\n\n\t/**\n\t * Lists properties defined in this packet.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.listProperties(); //  ['dc:Language', 'dc:Creator', 'xmp:CreateDate']\n\t * ```\n\t */\n\tpublic listProperties(): string[] {\n\t\treturn Object.keys(this.get('properties'));\n\t}\n\n\t/**\n\t * Returns the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.getProperty('dc:Creator'); //  {\"@list\": [\"Acme, Inc.\"]}\n\t * packet.getProperty('dc:Title'); //  {\"@type\": \"rdf:Alt\", \"rdf:_1\": {\"@language\": \"en-US\", \"@value\": \"Lamp\"}}\n\t * packet.getProperty('xmp:CreateDate'); //  \"2022-01-01\"\n\t * ```\n\t */\n\tpublic getProperty(name: string): Value | Record<string, unknown> | null {\n\t\tconst properties = this.get('properties');\n\t\treturn name in properties ? properties[name] : null;\n\t}\n\n\t/**\n\t * Sets the value of a property, as a literal or JSONLD object.\n\t *\n\t * Example:\n\t *\n\t * ```typescript\n\t * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});\n\t * packet.setProperty('dc:Title', {\n\t * \t'@type': 'rdf:Alt',\n\t * \t'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}\n\t * });\n\t * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});\n\t * ```\n\t */\n\tpublic setProperty(name: string, value: Value | Record<string, unknown>): this {\n\t\tthis._assertContext(name);\n\n\t\tconst properties = { ...this.get('properties') };\n\t\tif (value) {\n\t\t\tproperties[name] = value;\n\t\t} else {\n\t\t\tdelete properties[name];\n\t\t}\n\t\treturn this.set('properties', properties);\n\t}\n\n\t/**********************************************************************************************\n\t * Serialize / Deserialize.\n\t */\n\n\t/**\n\t * Serializes the packet context and properties to a JSONLD object.\n\t */\n\tpublic toJSONLD(): Record<string, unknown> {\n\t\tconst context = copyJSON(this.get('context'));\n\t\tconst properties = copyJSON(this.get('properties'));\n\t\treturn { '@context': context, ...properties };\n\t}\n\n\t/**\n\t * Deserializes a JSONLD packet, then overwrites existing context and properties with\n\t * the new values.\n\t */\n\tpublic fromJSONLD(jsonld: Record<string, unknown>): this {\n\t\tjsonld = copyJSON(jsonld);\n\n\t\t// Context.\n\t\tconst context = jsonld['@context'] as Record<Term, TermDefinition>;\n\t\tif (context) this.set('context', context);\n\t\tdelete jsonld['@context'];\n\n\t\t// Properties.\n\t\treturn this.set('properties', jsonld as Record<string, string | Record<string, unknown>>);\n\t}\n\n\t/**********************************************************************************************\n\t * Validation.\n\t */\n\n\t/** @hidden */\n\tprivate _assertContext(name: string) {\n\t\tconst prefix = name.split(':')[0];\n\t\tif (!(prefix in this.get('context'))) {\n\t\t\tthrow new Error(`${KHR_XMP_JSON_LD}: Missing context for term, \"${name}\".`);\n\t\t}\n\t}\n}\n\nfunction copyJSON<T>(object: T): T {\n\treturn JSON.parse(JSON.stringify(object));\n}\n", "import {\n\tAnimation,\n\tExtension,\n\tGLTF,\n\tMaterial,\n\tMesh,\n\tNode,\n\tPropertyType,\n\tReaderContext,\n\tScene,\n\tTexture,\n\tWriterContext,\n} from '@gltf-transform/core';\nimport { KHR_XMP_JSON_LD } from '../constants.js';\nimport { Packet } from './packet.js';\n\nconst NAME = KHR_XMP_JSON_LD;\n\ntype XMPPacketDef = Record<string, unknown>;\n\ntype XMPParentDef =\n\t| GLTF.IAsset\n\t| GLTF.IScene\n\t| GLTF.INode\n\t| GLTF.IMesh\n\t| GLTF.IMaterial\n\t| GLTF.ITexture\n\t| GLTF.IAnimation;\n\ninterface XMPPropertyDef {\n\tpacket: number;\n}\n\ninterface XMPRootDef {\n\tpackets?: XMPPacketDef[];\n}\n\n/**\n * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)\n * defines XMP metadata associated with a glTF asset.\n *\n * XMP metadata provides standardized fields describing the content, provenance, usage\n * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the\n * parsing or runtime behavior of the content  for that, use custom extensions, custom vertex\n * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred\n * for binary content like mesh data, animations, or textures.\n *\n * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}\n * to the document {@link Root}. In less common cases where metadata must be associated with\n * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},\n * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.\n *\n * Within each packet, XMP properties become available when an\n * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered\n * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not\n * registered as context. While not all XMP namespaces are relevant to 3D assets, some common\n * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`\n * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)\n * orientation data.\n *\n * Common XMP contexts for 3D models include:\n *\n * | Prefix      | URI                                         | Name                           |\n * |:------------|:--------------------------------------------|:-------------------------------|\n * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |\n * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |\n * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |\n * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |\n * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |\n *\n * Only the XMP contexts required for a packet should be assigned, and different packets\n * in the same asset may use different contexts. For greater detail on available XMP\n * contexts and how to use them in glTF assets, see the\n * [3DC Metadata Recommendations](https://github.com/KhronosGroup/3DC-Metadata-Recommendations/blob/main/model3d.md).\n *\n * Properties:\n * - {@link Packet}\n *\n * ### Example\n *\n * ```typescript\n * import { KHRXMP, Packet } from '@gltf-transform/extensions';\n *\n * // Create an Extension attached to the Document.\n * const xmpExtension = document.createExtension(KHRXMP);\n *\n * // Create Packet property.\n * const packet = xmpExtension.createPacket()\n * \t.setContext({\n * \t\tdc: 'http://purl.org/dc/elements/1.1/',\n * \t})\n *\t.setProperty('dc:Creator', {\"@list\": [\"Acme, Inc.\"]});\n *\n * // Option 1: Assign to Document Root.\n * document.getRoot().setExtension('KHR_xmp_json_ld', packet);\n *\n * // Option 2: Assign to a specific Property.\n * texture.setExtension('KHR_xmp_json_ld', packet);\n * ```\n */\nexport class KHRXMP extends Extension {\n\tpublic readonly extensionName = NAME;\n\tpublic static readonly EXTENSION_NAME = NAME;\n\n\t/** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */\n\tpublic createPacket(): Packet {\n\t\treturn new Packet(this.document.getGraph());\n\t}\n\n\t/** Lists XMP packets currently defined in a {@link Document}. */\n\tpublic listPackets(): Packet[] {\n\t\treturn Array.from(this.properties) as Packet[];\n\t}\n\n\t/** @hidden */\n\tpublic read(context: ReaderContext): this {\n\t\tconst extensionDef = context.jsonDoc.json.extensions?.[NAME] as XMPRootDef | undefined;\n\t\tif (!extensionDef || !extensionDef.packets) return this;\n\n\t\t// Deserialize packets.\n\t\tconst json = context.jsonDoc.json;\n\t\tconst root = this.document.getRoot();\n\t\tconst packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));\n\n\t\tconst defLists = [\n\t\t\t[json.asset],\n\t\t\tjson.scenes,\n\t\t\tjson.nodes,\n\t\t\tjson.meshes,\n\t\t\tjson.materials,\n\t\t\tjson.images,\n\t\t\tjson.animations,\n\t\t];\n\n\t\tconst propertyLists = [\n\t\t\t[root],\n\t\t\troot.listScenes(),\n\t\t\troot.listNodes(),\n\t\t\troot.listMeshes(),\n\t\t\troot.listMaterials(),\n\t\t\troot.listTextures(),\n\t\t\troot.listAnimations(),\n\t\t];\n\n\t\t// Assign packets.\n\t\tfor (let i = 0; i < defLists.length; i++) {\n\t\t\tconst defs = defLists[i] || [];\n\t\t\tfor (let j = 0; j < defs.length; j++) {\n\t\t\t\tconst def = defs[j];\n\t\t\t\tif (def.extensions && def.extensions[NAME]) {\n\t\t\t\t\tconst xmpDef = def.extensions[NAME] as XMPPropertyDef;\n\t\t\t\t\tpropertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/** @hidden */\n\tpublic write(context: WriterContext): this {\n\t\tconst { json } = context.jsonDoc;\n\n\t\tconst packetDefs = [];\n\n\t\tfor (const packet of this.properties as Set<Packet>) {\n\t\t\t// Serialize packets.\n\t\t\tpacketDefs.push(packet.toJSONLD());\n\n\t\t\t// Assign packets.\n\n\t\t\tfor (const parent of packet.listParents()) {\n\t\t\t\tlet parentDef: XMPParentDef | null;\n\n\t\t\t\tswitch (parent.propertyType) {\n\t\t\t\t\tcase PropertyType.ROOT:\n\t\t\t\t\t\tparentDef = json.asset;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.SCENE:\n\t\t\t\t\t\tparentDef = json.scenes![context.sceneIndexMap.get(parent as Scene)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.NODE:\n\t\t\t\t\t\tparentDef = json.nodes![context.nodeIndexMap.get(parent as Node)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MESH:\n\t\t\t\t\t\tparentDef = json.meshes![context.meshIndexMap.get(parent as Mesh)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.MATERIAL:\n\t\t\t\t\t\tparentDef = json.materials![context.materialIndexMap.get(parent as Material)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.TEXTURE:\n\t\t\t\t\t\tparentDef = json.images![context.imageIndexMap.get(parent as Texture)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PropertyType.ANIMATION:\n\t\t\t\t\t\tparentDef = json.animations![context.animationIndexMap.get(parent as Animation)!];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tparentDef = null;\n\t\t\t\t\t\tthis.document\n\t\t\t\t\t\t\t.getLogger()\n\t\t\t\t\t\t\t.warn(`[${NAME}]: Unsupported parent property, \"${parent.propertyType}\"`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!parentDef) continue;\n\n\t\t\t\tparentDef.extensions = parentDef.extensions || {};\n\t\t\t\tparentDef.extensions[NAME] = { packet: packetDefs.length - 1 };\n\t\t\t}\n\t\t}\n\n\t\tif (packetDefs.length > 0) {\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[NAME] = { packets: packetDefs };\n\t\t}\n\n\t\treturn this;\n\t}\n}\n", "import { EXTMeshGPUInstancing } from './ext-mesh-gpu-instancing/index.js';\nimport { EXTMeshoptCompression } from './ext-meshopt-compression/index.js';\nimport { EXTTextureAVIF } from './ext-texture-avif/index.js';\nimport { EXTTextureWebP } from './ext-texture-webp/index.js';\nimport { KHRDracoMeshCompression } from './khr-draco-mesh-compression/index.js';\nimport { KHRLightsPunctual } from './khr-lights-punctual/index.js';\nimport { KHRMaterialsAnisotropy } from './khr-materials-anisotropy/index.js';\nimport { KHRMaterialsClearcoat } from './khr-materials-clearcoat/index.js';\nimport { KHRMaterialsDiffuseTransmission } from './khr-materials-diffuse-transmission/materials-diffuse-transmission.js';\nimport { KHRMaterialsDispersion } from './khr-materials-dispersion/index.js';\nimport { KHRMaterialsEmissiveStrength } from './khr-materials-emissive-strength/index.js';\nimport { KHRMaterialsIOR } from './khr-materials-ior/index.js';\nimport { KHRMaterialsIridescence } from './khr-materials-iridescence/index.js';\nimport { KHRMaterialsPBRSpecularGlossiness } from './khr-materials-pbr-specular-glossiness/index.js';\nimport { KHRMaterialsSheen } from './khr-materials-sheen/index.js';\nimport { KHRMaterialsSpecular } from './khr-materials-specular/index.js';\nimport { KHRMaterialsTransmission } from './khr-materials-transmission/index.js';\nimport { KHRMaterialsUnlit } from './khr-materials-unlit/index.js';\nimport { KHRMaterialsVariants } from './khr-materials-variants/index.js';\nimport { KHRMaterialsVolume } from './khr-materials-volume/index.js';\nimport { KHRMeshQuantization } from './khr-mesh-quantization/index.js';\nimport { KHRTextureBasisu } from './khr-texture-basisu/index.js';\nimport { KHRTextureTransform } from './khr-texture-transform/index.js';\nimport { KHRXMP } from './khr-xmp-json-ld/index.js';\n\nexport const KHRONOS_EXTENSIONS = [\n\tKHRDracoMeshCompression,\n\tKHRLightsPunctual,\n\tKHRMaterialsAnisotropy,\n\tKHRMaterialsClearcoat,\n\tKHRMaterialsDiffuseTransmission,\n\tKHRMaterialsDispersion,\n\tKHRMaterialsEmissiveStrength,\n\tKHRMaterialsIOR,\n\tKHRMaterialsIridescence,\n\tKHRMaterialsPBRSpecularGlossiness,\n\tKHRMaterialsSpecular,\n\tKHRMaterialsSheen,\n\tKHRMaterialsTransmission,\n\tKHRMaterialsUnlit,\n\tKHRMaterialsVariants,\n\tKHRMaterialsVolume,\n\tKHRMeshQuantization,\n\tKHRTextureBasisu,\n\tKHRTextureTransform,\n\tKHRXMP,\n];\n\nexport const ALL_EXTENSIONS = [\n\tEXTMeshGPUInstancing,\n\tEXTMeshoptCompression,\n\tEXTTextureAVIF,\n\tEXTTextureWebP,\n\t...KHRONOS_EXTENSIONS,\n];\n\nexport * from './ext-mesh-gpu-instancing/index.js';\nexport * from './ext-meshopt-compression/index.js';\nexport * from './ext-texture-avif/index.js';\nexport * from './ext-texture-webp/index.js';\nexport * from './khr-draco-mesh-compression/index.js';\nexport * from './khr-lights-punctual/index.js';\nexport * from './khr-materials-anisotropy/index.js';\nexport * from './khr-materials-clearcoat/index.js';\nexport * from './khr-materials-diffuse-transmission/index.js';\nexport * from './khr-materials-dispersion/index.js';\nexport * from './khr-materials-emissive-strength/index.js';\nexport * from './khr-materials-ior/index.js';\nexport * from './khr-materials-iridescence/index.js';\nexport * from './khr-materials-sheen/index.js';\nexport * from './khr-materials-specular/index.js';\nexport * from './khr-materials-pbr-specular-glossiness/index.js';\nexport * from './khr-materials-transmission/index.js';\nexport * from './khr-materials-unlit/index.js';\nexport * from './khr-materials-variants/index.js';\nexport * from './khr-materials-volume/index.js';\nexport * from './khr-mesh-quantization/index.js';\nexport * from './khr-texture-basisu/index.js';\nexport * from './khr-texture-transform/index.js';\nexport * from './khr-xmp-json-ld/index.js';\n", "export type TypedArrayConstructor = Int8ArrayConstructor | Int16ArrayConstructor | Int32ArrayConstructor |\n\tUint8ArrayConstructor | Uint8ClampedArrayConstructor | Uint16ArrayConstructor |\n\tUint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor\n\nconst filterValue = ( x: number, a: 2 | 3 ) => {\n\tif ( x <= -a || x >= a ) return 0\n\n\t// appears to do nothing?\n\tif ( x > -1.19209290e-07 && x < 1.19209290e-07 ) return 1\n\n\tconst xPi = x * Math.PI\n\n\treturn ( Math.sin( xPi ) / xPi ) * Math.sin( xPi / a ) / ( xPi / a )\n}\n\nexport const filters = (\n\tsrcSize: number,\n\tdestSize: number,\n\tscale: number,\n\toffset: number,\n\tuse2: boolean,\n\tfloatType: TypedArrayConstructor,\n\tintType: TypedArrayConstructor,\n\tfixedFracBits: number\n) => {\n\tconst mul = (2 ** fixedFracBits) - 1\n\tconst toFixedPoint = (value: number) => Math.round(value * mul)\n\n\tconst a = use2 ? 2 : 3\n\tconst scaleInverted = 1 / scale\n\tconst scaleClamped = Math.min( 1, scale ) // For upscale\n\n\t// Filter window (averaging interval), scaled to src image\n\tconst srcWindow = a / scaleClamped\n\n\tconst maxFilterElementSize = Math.floor( ( srcWindow + 1 ) * 2 )\n\tconst packedFilter = new intType( ( maxFilterElementSize + 2 ) * destSize )\n\tlet packedFilterPtr = 0\n\n\t// For each destination pixel calculate source range and built filter values\n\tfor ( let destPixel = 0; destPixel < destSize; destPixel++ ) {\n\n\t\t// Scaling should be done relative to central pixel point\n\t\tconst sourcePixel = ( destPixel + 0.5 ) * scaleInverted + offset\n\t\tconst sourceFirst = Math.max( 0, Math.floor( sourcePixel - srcWindow ) )\n\t\tconst sourceLast = Math.min( srcSize - 1, Math.ceil( sourcePixel + srcWindow ) )\n\n\t\tconst filterElementSize = sourceLast - sourceFirst + 1\n\t\tconst floatFilter = new floatType( filterElementSize )\n\t\tconst fxpFilter = new intType( filterElementSize )\n\n\t\tlet total = 0\n\n\t\t// Fill filter values for calculated range\n\t\tlet index = 0\n\t\tfor ( let pixel = sourceFirst; pixel <= sourceLast; pixel++ ) {\n\t\t\tconst floatValue = filterValue( ( ( pixel + 0.5 ) - sourcePixel ) * scaleClamped, a )\n\n\t\t\ttotal += floatValue\n\t\t\tfloatFilter[ index ] = floatValue\n\n\t\t\tindex++\n\t\t}\n\n\t\t// Normalize filter, convert to fixed point and accumulate conversion error\n\t\tlet filterTotal = 0\n\n\t\tfor ( let index = 0; index < floatFilter.length; index++ ) {\n\t\t\tconst filterValue = floatFilter[ index ] / total\n\n\t\t\tfilterTotal += filterValue\n\t\t\tfxpFilter[ index ] = toFixedPoint( filterValue )\n\t\t}\n\n\t\t// Compensate normalization error, to minimize brightness drift\n\t\tfxpFilter[ destSize >> 1 ] += toFixedPoint( 1 - filterTotal )\n\n\t\t//\n\t\t// Now pack filter to useable form\n\t\t//\n\t\t// 1. Trim heading and tailing zero values, and compensate shitf/length\n\t\t// 2. Put all to single array in this format:\n\t\t//\n\t\t//    [ pos shift, data length, value1, value2, value3, ... ]\n\t\t//\n\t\tlet leftNotEmpty = 0\n\t\twhile ( leftNotEmpty < fxpFilter.length && fxpFilter[ leftNotEmpty ] === 0 ) {\n\t\t\tleftNotEmpty++\n\t\t}\n\n\t\tlet rightNotEmpty = fxpFilter.length - 1\n\t\twhile ( rightNotEmpty > 0 && fxpFilter[ rightNotEmpty ] === 0 ) {\n\t\t\trightNotEmpty--\n\t\t}\n\n\t\tconst filterShift = sourceFirst + leftNotEmpty\n\t\tconst filterSize = rightNotEmpty - leftNotEmpty + 1\n\n\t\tpackedFilter[ packedFilterPtr++ ] = filterShift // shift\n\t\tpackedFilter[ packedFilterPtr++ ] = filterSize // size\n\n\t\tpackedFilter.set( fxpFilter.subarray( leftNotEmpty, rightNotEmpty + 1 ), packedFilterPtr )\n\t\tpackedFilterPtr += filterSize\n\t}\n\n\treturn packedFilter\n}\n", "import type { NdArray, TypedArray } from 'ndarray';\n\nexport const convolve = (src: NdArray<TypedArray | number[]>, dst: NdArray<TypedArray>, filters: TypedArray, fixedFracBits: number) => {\n\tconst [_, srcHeight] = src.shape;\n\tconst [dstWidth] = dst.shape;\n\n\tconst maxValue = 2 ** (dst.data.BYTES_PER_ELEMENT * 8) - 1;\n\tconst clamp = (v: number): number => v < 0 ? 0 : (v > maxValue ? maxValue : v);\n\tconst fixedFracMul = 2 ** (fixedFracBits - 1);\n\tconst fixedFracMul2 = 2 * fixedFracMul;\n\n\t// For each row\n\tfor (let srcY = 0; srcY < srcHeight; srcY++) {\n\t\tconst dstY = srcY;\n\n\t\t// Apply precomputed filters to each destination row point\n\t\tlet filterPtr = 0;\n\t\tfor (let dstX = 0; dstX < dstWidth; dstX++) {\n\t\t\t// Get the filter that determines the current output pixel.\n\t\t\tlet srcX = filters[filterPtr++];\n\n\t\t\tlet r = 0;\n\t\t\tlet g = 0;\n\t\t\tlet b = 0;\n\t\t\tlet a = 0;\n\n\t\t\t// Apply the filter to the row to get the destination pixel r, g, b, a\n\t\t\tfor (let filterSize = filters[filterPtr++]; filterSize > 0; filterSize--) {\n\t\t\t\tconst filterValue = filters[filterPtr++];\n\n\t\t\t\tr = ( r + filterValue * src.get(srcX, srcY, 0) );\n\t\t\t\tg = ( g + filterValue * src.get(srcX, srcY, 1) );\n\t\t\t\tb = ( b + filterValue * src.get(srcX, srcY, 2) );\n\t\t\t\ta = ( a + filterValue * src.get(srcX, srcY, 3) );\n\n\t\t\t\tsrcX++;\n\t\t\t}\n\n\t\t\t// Bring this value back in range. All of the filter scaling factors\n\t\t\t// are in fixed point with fixedFracBits bits of fractional part.\n\t\t\t//\n\t\t\t// (!) Add 1/2 of value before clamping to get proper rounding. In other\n\t\t\t// case brightness loss will be noticeable if you resize image with white\n\t\t\t// border and place it on white background.\n\t\t\tdst.set(dstX, dstY, 0, clamp( ( r + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 1, clamp( ( g + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 2, clamp( ( b + fixedFracMul ) / fixedFracMul2 ) );\n\t\t\tdst.set(dstX, dstY, 3, clamp( ( a + fixedFracMul ) / fixedFracMul2 ) );\n\t\t}\n\t}\n}\n", "import ndarray, { NdArray } from 'ndarray';\nimport { filters, TypedArrayConstructor } from '../vendor/filters.js';\nimport { convolve } from './convolve.js';\n\nenum Method {\n\tLANCZOS_3 = 3,\n\tLANCZOS_2 = 2,\n}\n\nexport type SupportedTypes = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array\n\nfunction resize(\n\tsrc: NdArray<SupportedTypes | number[]>,\n\tdst: NdArray<SupportedTypes>, method: Method\n): void {\n\tif (src.shape.length !== 3 || dst.shape.length !== 3)\n\t\tthrow new TypeError\n\t\t\t('Input and output must have exactly 3 dimensions (width, height and colorspace)');\n\n\tconst [srcWidth, srcHeight] = src.shape;\n\tconst [dstWidth, dstHeight] = dst.shape;\n\n\tconst ratioX = dstWidth / srcWidth;\n\tconst ratioY = dstHeight / srcHeight;\n\n\tlet floatType, intType;\n\tswitch (dst.dtype) {\n\t\tcase 'uint8_clamped':\n\t\tcase 'uint8':\n\t\t\tfloatType = Float32Array;\n\t\t\tintType = Int16Array;\n\t\t\tbreak;\n\t\tcase 'uint16':\n\t\tcase 'uint32':\n\t\t\tfloatType = Float64Array;\n\t\t\tintType = Int32Array;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow TypeError(`Unsupported data type ${dst.dtype}`);\n\t}\n\tconst fixedFracBits = intType.BYTES_PER_ELEMENT * 7;\n\n\tconst filtersX = filters(srcWidth, dstWidth, ratioX, 0, method === Method.LANCZOS_2,\n\t\tfloatType, intType, fixedFracBits);\n\tconst filtersY = filters(srcHeight, dstHeight, ratioY, 0, method === Method.LANCZOS_2,\n\t\tfloatType, intType, fixedFracBits);\n\n\tconst constructor = dst.data.constructor as TypedArrayConstructor;\n\tconst tmp = ndarray(new constructor(dstWidth * srcHeight * 4), [srcHeight, dstWidth, 4]);\n\tconst tmpTranspose = tmp.transpose(1, 0);\n\tconst dstTranspose = dst.transpose(1, 0);\n\n\tconvolve(src, tmpTranspose, filtersX, fixedFracBits);\n\tconvolve(tmp, dstTranspose, filtersY, fixedFracBits);\n}\n\nexport function lanczos3(src: NdArray<SupportedTypes | number[]>, dst: NdArray<SupportedTypes>): void {\n\tresize(src, dst, Method.LANCZOS_3);\n}\n\nexport function lanczos2(src: NdArray<SupportedTypes | number[]>, dst: NdArray<SupportedTypes>): void {\n\tresize(src, dst, Method.LANCZOS_2);\n}\n", "import type { NdArray } from 'ndarray';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport {\n\tAccessor,\n\tDocument,\n\tGLTF,\n\tPrimitive,\n\tProperty,\n\tPropertyType,\n\tTexture,\n\tTransform,\n\tTransformContext,\n\tvec2,\n} from '@gltf-transform/core';\n\nconst { POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Prepares a function used in an {@link Document#transform} pipeline. Use of this wrapper is\n * optional, and plain functions may be used in transform pipelines just as well. The wrapper is\n * used internally so earlier pipeline stages can detect and optimize based on later stages.\n * @hidden\n */\nexport function createTransform(name: string, fn: Transform): Transform {\n\tObject.defineProperty(fn, 'name', { value: name });\n\treturn fn;\n}\n\n/** @hidden */\nexport function isTransformPending(context: TransformContext | undefined, initial: string, pending: string): boolean {\n\tif (!context) return false;\n\tconst initialIndex = context.stack.lastIndexOf(initial);\n\tconst pendingIndex = context.stack.lastIndexOf(pending);\n\treturn initialIndex < pendingIndex;\n}\n\n/**\n * Performs a shallow merge on an 'options' object and a 'defaults' object.\n * Equivalent to `{...defaults, ...options}` _except_ that `undefined` values\n * in the 'options' object are ignored.\n *\n * @hidden\n */\nexport function assignDefaults<Defaults, Options>(defaults: Defaults, options: Options): Defaults & Options {\n\tconst result = { ...defaults } as Defaults & Partial<Options>;\n\tfor (const key in options) {\n\t\tif (options[key] !== undefined) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tresult[key] = options[key] as any;\n\t\t}\n\t}\n\treturn result as Defaults & Options;\n}\n\n/**\n * Maps pixels from source to target textures, with a per-pixel callback.\n * @hidden\n */\nexport async function rewriteTexture(\n\tsource: Texture,\n\ttarget: Texture,\n\tfn: (pixels: NdArray, i: number, j: number) => void,\n): Promise<Texture | null> {\n\tif (!source) return null;\n\n\tconst srcImage = source.getImage();\n\tif (!srcImage) return null;\n\n\tconst pixels = await getPixels(srcImage, source.getMimeType());\n\n\tfor (let i = 0; i < pixels.shape[0]; ++i) {\n\t\tfor (let j = 0; j < pixels.shape[1]; ++j) {\n\t\t\tfn(pixels, i, j);\n\t\t}\n\t}\n\n\tconst dstImage = await savePixels(pixels, 'image/png');\n\treturn target.setImage(dstImage).setMimeType('image/png');\n}\n\n/** @hidden */\nexport function getGLPrimitiveCount(prim: Primitive): number {\n\tconst indices = prim.getIndices();\n\tconst position = prim.getAttribute('POSITION')!;\n\n\t// Reference: https://www.khronos.org/opengl/wiki/Primitive\n\tswitch (prim.getMode()) {\n\t\tcase Primitive.Mode.POINTS:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase Primitive.Mode.LINES:\n\t\t\treturn indices ? indices.getCount() / 2 : position.getCount() / 2;\n\t\tcase Primitive.Mode.LINE_LOOP:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase Primitive.Mode.LINE_STRIP:\n\t\t\treturn indices ? indices.getCount() - 1 : position.getCount() - 1;\n\t\tcase Primitive.Mode.TRIANGLES:\n\t\t\treturn indices ? indices.getCount() / 3 : position.getCount() / 3;\n\t\tcase Primitive.Mode.TRIANGLE_STRIP:\n\t\tcase Primitive.Mode.TRIANGLE_FAN:\n\t\t\treturn indices ? indices.getCount() - 2 : position.getCount() - 2;\n\t\tdefault:\n\t\t\tthrow new Error('Unexpected mode: ' + prim.getMode());\n\t}\n}\n\n/** @hidden */\nexport class SetMap<K, V> {\n\tprivate _map = new Map<K, Set<V>>();\n\tpublic get size(): number {\n\t\treturn this._map.size;\n\t}\n\tpublic has(k: K): boolean {\n\t\treturn this._map.has(k);\n\t}\n\tpublic add(k: K, v: V): this {\n\t\tlet entry = this._map.get(k);\n\t\tif (!entry) {\n\t\t\tentry = new Set();\n\t\t\tthis._map.set(k, entry);\n\t\t}\n\t\tentry.add(v);\n\t\treturn this;\n\t}\n\tpublic get(k: K): Set<V> {\n\t\treturn this._map.get(k) || new Set();\n\t}\n\tpublic keys(): Iterable<K> {\n\t\treturn this._map.keys();\n\t}\n}\n\n/** @hidden */\nexport function formatBytes(bytes: number, decimals = 2): string {\n\tif (bytes === 0) return '0 Bytes';\n\n\tconst k = 1000;\n\tconst dm = decimals < 0 ? 0 : decimals;\n\tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\n\treturn parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\n/** @hidden */\nexport function formatLong(x: number): string {\n\treturn x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n}\n\n/** @hidden */\nexport function formatDelta(a: number, b: number, decimals = 2): string {\n\tconst prefix = a > b ? '' : '+';\n\tconst suffix = '%';\n\treturn prefix + ((Math.abs(a - b) / a) * 100).toFixed(decimals) + suffix;\n}\n\n/** @hidden */\nexport function formatDeltaOp(a: number, b: number) {\n\treturn `${formatLong(a)}  ${formatLong(b)} (${formatDelta(a, b)})`;\n}\n\n/**\n * Returns a list of all unique vertex attributes on the given primitive and\n * its morph targets.\n * @hidden\n */\nexport function deepListAttributes(prim: Primitive): Accessor[] {\n\tconst accessors: Accessor[] = [];\n\n\tfor (const attribute of prim.listAttributes()) {\n\t\taccessors.push(attribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const attribute of target.listAttributes()) {\n\t\t\taccessors.push(attribute);\n\t\t}\n\t}\n\n\treturn Array.from(new Set(accessors));\n}\n\n/** @hidden */\nexport function deepSwapAttribute(prim: Primitive, src: Accessor, dst: Accessor): void {\n\tprim.swap(src, dst);\n\tfor (const target of prim.listTargets()) {\n\t\ttarget.swap(src, dst);\n\t}\n}\n\n/** @hidden */\nexport function shallowEqualsArray(a: ArrayLike<unknown> | null, b: ArrayLike<unknown> | null) {\n\tif (a == null && b == null) return true;\n\tif (a == null || b == null) return false;\n\tif (a.length !== b.length) return false;\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) return false;\n\t}\n\treturn true;\n}\n\n/** Clones an {@link Accessor} without creating a copy of its underlying TypedArray data. */\nexport function shallowCloneAccessor(document: Document, accessor: Accessor): Accessor {\n\treturn document\n\t\t.createAccessor(accessor.getName())\n\t\t.setArray(accessor.getArray())\n\t\t.setType(accessor.getType())\n\t\t.setBuffer(accessor.getBuffer())\n\t\t.setNormalized(accessor.getNormalized())\n\t\t.setSparse(accessor.getSparse());\n}\n\n/** @hidden */\nexport function createIndices(count: number, maxIndex = count): Uint16Array | Uint32Array {\n\tconst array = createIndicesEmpty(count, maxIndex);\n\tfor (let i = 0; i < array.length; i++) array[i] = i;\n\treturn array;\n}\n\n/** @hidden */\nexport function createIndicesEmpty(count: number, maxIndex = count): Uint16Array | Uint32Array {\n\treturn maxIndex <= 65534 ? new Uint16Array(count) : new Uint32Array(count);\n}\n\n/** @hidden */\nexport function isUsed(prop: Property): boolean {\n\treturn prop.listParents().some((parent) => parent.propertyType !== PropertyType.ROOT);\n}\n\n/** @hidden */\nexport function isEmptyObject(object: Record<string, unknown>): boolean {\n\tfor (const key in object) return false;\n\treturn true;\n}\n\n/**\n * Creates a unique key associated with the structure and draw call characteristics of\n * a {@link Primitive}, independent of its vertex content. Helper method, used to\n * identify candidate Primitives for joining.\n * @hidden\n */\nexport function createPrimGroupKey(prim: Primitive): string {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\tconst material = prim.getMaterial();\n\tconst materialIndex = document.getRoot().listMaterials().indexOf(material!);\n\tconst mode = BASIC_MODE_MAPPING[prim.getMode()];\n\tconst indices = !!prim.getIndices();\n\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.sort()\n\t\t.map((semantic) => {\n\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\tconst componentType = attribute.getComponentType();\n\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t})\n\t\t.join('+');\n\n\tconst targets = prim\n\t\t.listTargets()\n\t\t.map((target) => {\n\t\t\treturn target\n\t\t\t\t.listSemantics()\n\t\t\t\t.sort()\n\t\t\t\t.map((semantic) => {\n\t\t\t\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\t\t\t\tconst elementSize = attribute.getElementSize();\n\t\t\t\t\tconst componentType = attribute.getComponentType();\n\t\t\t\t\treturn `${semantic}:${elementSize}:${componentType}`;\n\t\t\t\t})\n\t\t\t\t.join('+');\n\t\t})\n\t\t.join('~');\n\n\treturn `${materialIndex}|${mode}|${indices}|${attributes}|${targets}`;\n}\n\n/**\n * Scales `size` NxN dimensions to fit within `limit` NxN dimensions, without\n * changing aspect ratio. If `size` <= `limit` in all dimensions, returns `size`.\n * @hidden\n */\nexport function fitWithin(size: vec2, limit: vec2): vec2 {\n\tconst [maxWidth, maxHeight] = limit;\n\tconst [srcWidth, srcHeight] = size;\n\n\tif (srcWidth <= maxWidth && srcHeight <= maxHeight) return size;\n\n\tlet dstWidth = srcWidth;\n\tlet dstHeight = srcHeight;\n\n\tif (dstWidth > maxWidth) {\n\t\tdstHeight = Math.floor(dstHeight * (maxWidth / dstWidth));\n\t\tdstWidth = maxWidth;\n\t}\n\n\tif (dstHeight > maxHeight) {\n\t\tdstWidth = Math.floor(dstWidth * (maxHeight / dstHeight));\n\t\tdstHeight = maxHeight;\n\t}\n\n\treturn [dstWidth, dstHeight];\n}\n\ntype ResizePreset = 'nearest-pot' | 'ceil-pot' | 'floor-pot';\n\n/**\n * Scales `size` NxN dimensions to the specified power of two.\n * @hidden\n */\nexport function fitPowerOfTwo(size: vec2, method: ResizePreset): vec2 {\n\tif (isPowerOfTwo(size[0]) && isPowerOfTwo(size[1])) {\n\t\treturn size;\n\t}\n\n\tswitch (method) {\n\t\tcase 'nearest-pot':\n\t\t\treturn size.map(nearestPowerOfTwo) as vec2;\n\t\tcase 'ceil-pot':\n\t\t\treturn size.map(ceilPowerOfTwo) as vec2;\n\t\tcase 'floor-pot':\n\t\t\treturn size.map(floorPowerOfTwo) as vec2;\n\t}\n}\n\nfunction isPowerOfTwo(value: number): boolean {\n\tif (value <= 2) return true;\n\treturn (value & (value - 1)) === 0 && value !== 0;\n}\n\nfunction nearestPowerOfTwo(value: number): number {\n\tif (value <= 4) return 4;\n\n\tconst lo = floorPowerOfTwo(value);\n\tconst hi = ceilPowerOfTwo(value);\n\n\tif (hi - value > value - lo) return lo;\n\treturn hi;\n}\n\nexport function floorPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nexport function ceilPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\n/**\n * Mapping from any glTF primitive mode to its equivalent basic mode, as returned by\n * {@link convertPrimitiveMode}.\n * @hidden\n */\nexport const BASIC_MODE_MAPPING = {\n\t[POINTS]: POINTS,\n\t[LINES]: LINES,\n\t[LINE_STRIP]: LINES,\n\t[LINE_LOOP]: LINES,\n\t[TRIANGLES]: TRIANGLES,\n\t[TRIANGLE_STRIP]: TRIANGLES,\n\t[TRIANGLE_FAN]: TRIANGLES,\n} as Record<GLTF.MeshPrimitiveMode, GLTF.MeshPrimitiveMode>;\n", "import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { getBounds } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'center';\n\n/** Options for the {@link center} function. */\nexport interface CenterOptions {\n\t/** Location on the model to be considered the pivot, and recentered at the origin. */\n\tpivot?: 'center' | 'above' | 'below' | vec3;\n}\n\nconst CENTER_DEFAULTS: Required<CenterOptions> = { pivot: 'center' };\n\n/**\n * Centers the {@link Scene} at the origin, or above/below it. Transformations from animation,\n * skinning, and morph targets are not taken into account.\n *\n * Example:\n *\n * ```ts\n * await document.transform(center({pivot: 'below'}));\n * ```\n *\n * @category Transforms\n */\nexport function center(_options: CenterOptions = CENTER_DEFAULTS): Transform {\n\tconst options = assignDefaults(CENTER_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst isAnimated = root.listAnimations().length > 0 || root.listSkins().length > 0;\n\n\t\tdoc.getRoot()\n\t\t\t.listScenes()\n\t\t\t.forEach((scene, index) => {\n\t\t\t\tlogger.debug(`${NAME}: Scene ${index + 1} / ${root.listScenes().length}.`);\n\n\t\t\t\tlet pivot: vec3;\n\t\t\t\tif (typeof options.pivot === 'string') {\n\t\t\t\t\tconst bbox = getBounds(scene);\n\t\t\t\t\tpivot = [\n\t\t\t\t\t\t(bbox.max[0] - bbox.min[0]) / 2 + bbox.min[0],\n\t\t\t\t\t\t(bbox.max[1] - bbox.min[1]) / 2 + bbox.min[1],\n\t\t\t\t\t\t(bbox.max[2] - bbox.min[2]) / 2 + bbox.min[2],\n\t\t\t\t\t];\n\t\t\t\t\tif (options.pivot === 'above') pivot[1] = bbox.max[1];\n\t\t\t\t\tif (options.pivot === 'below') pivot[1] = bbox.min[1];\n\t\t\t\t} else {\n\t\t\t\t\tpivot = options.pivot as vec3;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(`${NAME}: Pivot \"${pivot.join(', ')}\".`);\n\n\t\t\t\tconst offset: vec3 = [-1 * pivot[0], -1 * pivot[1], -1 * pivot[2]];\n\n\t\t\t\tif (isAnimated) {\n\t\t\t\t\tlogger.debug(`${NAME}: Model contains animation or skin. Adding a wrapper node.`);\n\t\t\t\t\tconst offsetNode = doc.createNode('Pivot').setTranslation(offset);\n\t\t\t\t\tscene.listChildren().forEach((child) => offsetNode.addChild(child));\n\t\t\t\t\tscene.addChild(offsetNode);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping wrapper, offsetting all root nodes.`);\n\t\t\t\t\tscene.listChildren().forEach((child) => {\n\t\t\t\t\t\tconst t = child.getTranslation();\n\t\t\t\t\t\tchild.setTranslation([t[0] + offset[0], t[1] + offset[1], t[2] + offset[2]]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { Node, Scene } from '@gltf-transform/core';\n\n/**\n * Finds the parent {@link Scene Scenes} associated with the given {@link Node}.\n * In most cases a Node is associated with only one Scene, but it is possible\n * for a Node to be located in two or more Scenes, or none at all.\n *\n * Example:\n *\n * ```typescript\n * import { listNodeScenes } from '@gltf-transform/functions';\n *\n * const node = document.getRoot().listNodes()\n *  .find((node) => node.getName() === 'MyNode');\n *\n * const scenes = listNodeScenes(node);\n * ```\n */\nexport function listNodeScenes(node: Node): Scene[] {\n\tconst visited = new Set<Node>();\n\n\tlet child = node;\n\tlet parent: Node | null;\n\n\twhile ((parent = child.getParentNode() as Node | null)) {\n\t\tif (visited.has(parent)) {\n\t\t\tthrow new Error('Circular dependency in scene graph.');\n\t\t}\n\t\tvisited.add(parent);\n\t\tchild = parent;\n\t}\n\n\treturn child.listParents().filter((parent) => parent instanceof Scene) as Scene[];\n}\n", "import type { Node } from '@gltf-transform/core';\nimport { listNodeScenes } from './list-node-scenes.js';\n\n/**\n * Clears the parent of the given {@link Node}, leaving it attached\n * directly to its {@link Scene}. Inherited transforms will be applied\n * to the Node. This operation changes the Node's local transform,\n * but leaves its world transform unchanged.\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeParent } from '@gltf-transform/functions';\n *\n * scene.traverse((node) => { ... }); // Scene    Node\n *\n * clearNodeParent(node);\n *\n * scene.traverse((node) => { ... }); // Scene  Node\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeParent(node: Node): Node {\n\tconst scenes = listNodeScenes(node);\n\tconst parent = node.getParentNode();\n\n\tif (!parent) return node;\n\n\t// Apply inherited transforms to local matrix. Skinned meshes are not affected\n\t// by the node parent's transform, and can be ignored. Updates to IBMs and TRS\n\t// animations are out of scope in this context.\n\tnode.setMatrix(node.getWorldMatrix());\n\n\t// Add to Scene roots.\n\tparent.removeChild(node);\n\tfor (const scene of scenes) scene.addChild(node);\n\n\treturn node;\n}\n", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\n\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\n\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\n\nexport function translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\n\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\n\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "import {\n\tAccessor,\n\tBufferUtils,\n\tDocument,\n\tMaterial,\n\tMesh,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tSkin,\n\tTexture,\n\tTransform,\n} from '@gltf-transform/core';\nimport { assignDefaults, createTransform, shallowEqualsArray } from './utils.js';\n\nconst NAME = 'dedup';\n\nexport interface DedupOptions {\n\t/** Keep properties with unique names, even if they are duplicates. */\n\tkeepUniqueNames?: boolean;\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n}\n\nconst DEDUP_DEFAULTS: Required<DedupOptions> = {\n\tkeepUniqueNames: false,\n\tpropertyTypes: [\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.MESH,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.SKIN,\n\t],\n};\n\n/**\n * Removes duplicate {@link Accessor}, {@link Mesh}, {@link Texture}, and {@link Material}\n * properties. Partially based on a\n * [gist by mattdesl](https://gist.github.com/mattdesl/aea40285e2d73916b6b9101b36d84da8). Only\n * accessors in mesh primitives, morph targets, and animation samplers are processed.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listMeshes(); //  [Mesh, Mesh, Mesh]\n *\n * await document.transform(dedup({propertyTypes: [PropertyType.MESH]}));\n *\n * document.getRoot().listMeshes(); //  [Mesh]\n * ```\n *\n * @category Transforms\n */\nexport function dedup(_options: DedupOptions = DEDUP_DEFAULTS): Transform {\n\tconst options = assignDefaults(DEDUP_DEFAULTS, _options);\n\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tfor (const propertyType of options.propertyTypes) {\n\t\tif (!DEDUP_DEFAULTS.propertyTypes.includes(propertyType)) {\n\t\t\tthrow new Error(`${NAME}: Unsupported deduplication on type \"${propertyType}\".`);\n\t\t}\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst logger = document.getLogger();\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) dedupAccessors(document);\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) dedupImages(document, options);\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) dedupMaterials(document, options);\n\t\tif (propertyTypes.has(PropertyType.MESH)) dedupMeshes(document, options);\n\t\tif (propertyTypes.has(PropertyType.SKIN)) dedupSkins(document, options);\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction dedupAccessors(document: Document): void {\n\tconst logger = document.getLogger();\n\n\t// Find all accessors used for mesh and animation data.\n\tconst indicesMap = new Map<string, Set<Accessor>>();\n\tconst attributeMap = new Map<string, Set<Accessor>>();\n\tconst inputMap = new Map<string, Set<Accessor>>();\n\tconst outputMap = new Map<string, Set<Accessor>>();\n\n\tconst meshes = document.getRoot().listMeshes();\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => hashAccessor(accessor, attributeMap));\n\t\t\thashAccessor(primitive.getIndices(), indicesMap);\n\t\t});\n\t});\n\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\thashAccessor(sampler.getInput(), inputMap);\n\t\t\thashAccessor(sampler.getOutput(), outputMap);\n\t\t}\n\t}\n\n\t// Add accessor to the appropriate hash group. Hashes are _non-unique_,\n\t// intended to quickly compare everything accept the underlying array.\n\tfunction hashAccessor(accessor: Accessor | null, group: Map<string, Set<Accessor>>): void {\n\t\tif (!accessor) return;\n\n\t\tconst hash = [\n\t\t\taccessor.getCount(),\n\t\t\taccessor.getType(),\n\t\t\taccessor.getComponentType(),\n\t\t\taccessor.getNormalized(),\n\t\t\taccessor.getSparse(),\n\t\t].join(':');\n\n\t\tlet hashSet = group.get(hash);\n\t\tif (!hashSet) group.set(hash, (hashSet = new Set<Accessor>()));\n\t\thashSet.add(accessor);\n\t}\n\n\t// Find duplicate accessors of a given type.\n\tfunction detectDuplicates(accessors: Accessor[], duplicates: Map<Accessor, Accessor>): void {\n\t\tfor (let i = 0; i < accessors.length; i++) {\n\t\t\tconst a = accessors[i];\n\t\t\tconst aData = BufferUtils.toView(a.getArray()!);\n\n\t\t\tif (duplicates.has(a)) continue;\n\n\t\t\tfor (let j = i + 1; j < accessors.length; j++) {\n\t\t\t\tconst b = accessors[j];\n\n\t\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t\t// Just compare the arrays  everything else was covered by the\n\t\t\t\t// hash. Comparing uint8 views is faster than comparing the\n\t\t\t\t// original typed arrays.\n\t\t\t\tif (BufferUtils.equals(aData, BufferUtils.toView(b.getArray()!))) {\n\t\t\t\t\tduplicates.set(b, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet total = 0;\n\tconst duplicates = new Map<Accessor, Accessor>();\n\tfor (const group of [attributeMap, indicesMap, inputMap, outputMap]) {\n\t\tfor (const hashGroup of group.values()) {\n\t\t\ttotal += hashGroup.size;\n\t\t\tdetectDuplicates(Array.from(hashGroup), duplicates);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${total} accessors.`);\n\n\t// Dissolve duplicate vertex attributes and indices.\n\tmeshes.forEach((mesh) => {\n\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\tprimitive.listAttributes().forEach((accessor) => {\n\t\t\t\tif (duplicates.has(accessor)) {\n\t\t\t\t\tprimitive.swap(accessor, duplicates.get(accessor) as Accessor);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst indices = primitive.getIndices();\n\t\t\tif (indices && duplicates.has(indices)) {\n\t\t\t\tprimitive.swap(indices, duplicates.get(indices) as Accessor);\n\t\t\t}\n\t\t});\n\t});\n\n\t// Dissolve duplicate animation sampler inputs and outputs.\n\tfor (const animation of document.getRoot().listAnimations()) {\n\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\tconst input = sampler.getInput();\n\t\t\tconst output = sampler.getOutput();\n\t\t\tif (input && duplicates.has(input)) {\n\t\t\t\tsampler.swap(input, duplicates.get(input) as Accessor);\n\t\t\t}\n\t\t\tif (output && duplicates.has(output)) {\n\t\t\t\tsampler.swap(output, duplicates.get(output) as Accessor);\n\t\t\t}\n\t\t}\n\t}\n\n\tArray.from(duplicates.keys()).forEach((accessor) => accessor.dispose());\n}\n\nfunction dedupMeshes(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\n\t// Create Reference -> ID lookup table.\n\tconst refs = new Map<Accessor | Material, number>();\n\troot.listAccessors().forEach((accessor, index) => refs.set(accessor, index));\n\troot.listMaterials().forEach((material, index) => refs.set(material, index));\n\n\t// For each mesh, create a hashkey.\n\tconst numMeshes = root.listMeshes().length;\n\tconst uniqueMeshes = new Map<string, Mesh>();\n\tfor (const src of root.listMeshes()) {\n\t\t// For each mesh, create a hashkey.\n\t\tconst srcKeyItems = [];\n\t\tfor (const prim of src.listPrimitives()) {\n\t\t\tsrcKeyItems.push(createPrimitiveKey(prim, refs));\n\t\t}\n\n\t\t// If another mesh exists with the same key, replace all instances with that, and dispose\n\t\t// of the duplicate. If not, just cache it.\n\t\tlet meshKey = '';\n\t\tif (options.keepUniqueNames) meshKey += src.getName() + ';';\n\t\tmeshKey += srcKeyItems.join(';');\n\n\t\tif (uniqueMeshes.has(meshKey)) {\n\t\t\tconst targetMesh = uniqueMeshes.get(meshKey)!;\n\t\t\tsrc.listParents().forEach((parent) => {\n\t\t\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\t\t\tparent.swap(src, targetMesh);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsrc.dispose();\n\t\t} else {\n\t\t\tuniqueMeshes.set(meshKey, src);\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${numMeshes - uniqueMeshes.size} of ${numMeshes} meshes.`);\n}\n\nfunction dedupImages(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst textures = root.listTextures();\n\tconst duplicates: Map<Texture, Texture> = new Map();\n\n\t// Compare each texture to every other texture  O(n)  and mark duplicates for replacement.\n\tfor (let i = 0; i < textures.length; i++) {\n\t\tconst a = textures[i];\n\t\tconst aData = a.getImage();\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < textures.length; j++) {\n\t\t\tconst b = textures[j];\n\t\t\tconst bData = b.getImage();\n\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// URIs are intentionally not compared.\n\t\t\tif (a.getMimeType() !== b.getMimeType()) continue;\n\t\t\tif (options.keepUniqueNames && a.getName() !== b.getName()) continue;\n\n\t\t\tconst aSize = a.getSize();\n\t\t\tconst bSize = b.getSize();\n\t\t\tif (!aSize || !bSize) continue;\n\t\t\tif (aSize[0] !== bSize[0]) continue;\n\t\t\tif (aSize[1] !== bSize[1]) continue;\n\t\t\tif (!aData || !bData) continue;\n\t\t\tif (BufferUtils.equals(aData, bData)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${root.listTextures().length} textures.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupMaterials(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst materials = root.listMaterials();\n\tconst duplicates = new Map<Material, Material>();\n\tconst modifierCache = new Map<Material, boolean>();\n\tconst skip = new Set<string>();\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\t// Compare each material to every other material  O(n)  and mark duplicates for replacement.\n\tfor (let i = 0; i < materials.length; i++) {\n\t\tconst a = materials[i];\n\n\t\tif (duplicates.has(a)) continue;\n\t\tif (hasModifier(a, modifierCache)) continue;\n\n\t\tfor (let j = i + 1; j < materials.length; j++) {\n\t\t\tconst b = materials[j];\n\n\t\t\tif (duplicates.has(b)) continue;\n\t\t\tif (hasModifier(b, modifierCache)) continue;\n\n\t\t\tif (a.equals(b, skip)) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${materials.length} materials.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\nfunction dedupSkins(document: Document, options: Required<DedupOptions>): void {\n\tconst logger = document.getLogger();\n\tconst root = document.getRoot();\n\tconst skins = root.listSkins();\n\tconst duplicates = new Map<Skin, Skin>();\n\tconst skip = new Set(['joints']);\n\n\tif (!options.keepUniqueNames) {\n\t\tskip.add('name');\n\t}\n\n\tfor (let i = 0; i < skins.length; i++) {\n\t\tconst a = skins[i];\n\n\t\tif (duplicates.has(a)) continue;\n\n\t\tfor (let j = i + 1; j < skins.length; j++) {\n\t\t\tconst b = skins[j];\n\t\t\tif (duplicates.has(b)) continue;\n\n\t\t\t// Check joints with shallow equality, not deep equality.\n\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/RecursiveSkeletons\n\t\t\tif (a.equals(b, skip) && shallowEqualsArray(a.listJoints(), b.listJoints())) {\n\t\t\t\tduplicates.set(b, a);\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: Merged ${duplicates.size} of ${skins.length} skins.`);\n\n\tArray.from(duplicates.entries()).forEach(([src, dst]) => {\n\t\tsrc.listParents().forEach((property) => {\n\t\t\tif (!(property instanceof Root)) property.swap(src, dst);\n\t\t});\n\t\tsrc.dispose();\n\t});\n}\n\n/** Generates a key unique to the content of a primitive or target. */\nfunction createPrimitiveKey(prim: Primitive | PrimitiveTarget, refs: Map<Accessor | Material, number>): string {\n\tconst primKeyItems = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute(semantic)!;\n\t\tprimKeyItems.push(semantic + ':' + refs.get(attribute));\n\t}\n\tif (prim instanceof Primitive) {\n\t\tconst indices = prim.getIndices();\n\t\tif (indices) {\n\t\t\tprimKeyItems.push('indices:' + refs.get(indices));\n\t\t}\n\t\tconst material = prim.getMaterial();\n\t\tif (material) {\n\t\t\tprimKeyItems.push('material:' + refs.get(material));\n\t\t}\n\t\tprimKeyItems.push('mode:' + prim.getMode());\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tprimKeyItems.push('target:' + createPrimitiveKey(target, refs));\n\t\t}\n\t}\n\treturn primKeyItems.join(',');\n}\n\n/**\n * Detects dependencies modified by a parent reference, to conservatively prevent merging. When\n * implementing extensions like KHR_animation_pointer, the 'modifyChild' attribute should be added\n * to graph edges connecting the animation channel to the animated target property.\n *\n * NOTICE: Implementation is conservative, and could prevent merging two materials sharing the\n * same animated \"Clearcoat\" ExtensionProperty. While that scenario is possible for an in-memory\n * glTF Transform graph, valid glTF input files do not have that risk.\n */\nfunction hasModifier(prop: Property, cache: Map<Property, boolean>): boolean {\n\tif (cache.has(prop)) return cache.get(prop)!;\n\n\tconst graph = prop.getGraph();\n\tconst visitedNodes = new Set<Property>();\n\tconst edgeQueue = graph.listParentEdges(prop);\n\n\t// Search dependency subtree for 'modifyChild' attribute.\n\twhile (edgeQueue.length > 0) {\n\t\tconst edge = edgeQueue.pop()!;\n\t\tif (edge.getAttributes().modifyChild === true) {\n\t\t\tcache.set(prop, true);\n\t\t\treturn true;\n\t\t}\n\n\t\tconst child = edge.getChild();\n\t\tif (visitedNodes.has(child)) continue;\n\n\t\tfor (const childEdge of graph.listChildEdges(child)) {\n\t\t\tedgeQueue.push(childEdge);\n\t\t}\n\t}\n\n\tcache.set(prop, false);\n\treturn false;\n}\n", "import * as glMatrix from \"./common.js\";\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} result the receiving vector\n * @param {ReadonlyVec4} U the first vector\n * @param {ReadonlyVec4} V the second vector\n * @param {ReadonlyVec4} W the third vector\n * @returns {vec4} result\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec4} out\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec4.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();", "import { Texture } from '@gltf-transform/core';\n\nconst SRGB_PATTERN = /color|emissive|diffuse/i;\n\n/**\n * Returns the color space (if any) implied by the {@link Material} slots to\n * which a texture is assigned, or null for non-color textures. If the texture\n * is not connected to any {@link Material}, this function will also return\n * null  any metadata in the image file will be ignored.\n *\n * Under current glTF specifications, only 'srgb' and non-color (null) textures\n * are used.\n *\n * Example:\n *\n * ```typescript\n * import { getTextureColorSpace } from '@gltf-transform/functions';\n *\n * const baseColorTexture = material.getBaseColorTexture();\n * const normalTexture = material.getNormalTexture();\n *\n * getTextureColorSpace(baseColorTexture); //  'srgb'\n * getTextureColorSpace(normalTexture); //  null\n * ```\n */\nexport function getTextureColorSpace(texture: Texture): string | null {\n\tconst graph = texture.getGraph();\n\tconst edges = graph.listParentEdges(texture);\n\tconst isSRGB = edges.some((edge) => {\n\t\treturn edge.getAttributes().isColor || SRGB_PATTERN.test(edge.getName());\n\t});\n\treturn isSRGB ? 'srgb' : null;\n}\n", "import { ExtensionProperty, Material, Property, Texture, TextureInfo } from '@gltf-transform/core';\n\n/**\n * Lists all {@link TextureInfo} definitions associated with a given\n * {@link Texture}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * // Find TextureInfo instances associated with the texture.\n * const results = listTextureInfo(texture);\n *\n * // Find which UV sets (TEXCOORD_0, TEXCOORD_1, ...) are required.\n * const texCoords = results.map((info) => info.getTexCoord());\n * //  [0, 1]\n * ```\n */\nexport function listTextureInfo(texture: Texture): TextureInfo[] {\n\tconst graph = texture.getGraph();\n\tconst results = new Set<TextureInfo>();\n\n\tfor (const textureEdge of graph.listParentEdges(texture)) {\n\t\tconst parent = textureEdge.getParent();\n\t\tconst name = textureEdge.getName() + 'Info';\n\n\t\tfor (const edge of graph.listChildEdges(parent)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (child instanceof TextureInfo && edge.getName() === name) {\n\t\t\t\tresults.add(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Array.from(results);\n}\n\n/**\n * Lists all {@link TextureInfo} definitions associated with any {@link Texture}\n * on the given {@link Material}. May be used to determine which UV transforms\n * and texCoord indices are applied to the material, without explicitly\n * checking the material properties and extensions.\n *\n * Example:\n *\n * ```typescript\n * const results = listTextureInfoByMaterial(material);\n *\n * const texCoords = results.map((info) => info.getTexCoord());\n * //  [0, 1]\n * ```\n */\nexport function listTextureInfoByMaterial(material: Material): TextureInfo[] {\n\tconst graph = material.getGraph();\n\tconst visited = new Set<Property>();\n\tconst results = new Set<TextureInfo>();\n\n\tfunction traverse(prop: Material | ExtensionProperty) {\n\t\tconst textureInfoNames = new Set<string>();\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tif (edge.getChild() instanceof Texture) {\n\t\t\t\ttextureInfoNames.add(edge.getName() + 'Info');\n\t\t\t}\n\t\t}\n\n\t\tfor (const edge of graph.listChildEdges(prop)) {\n\t\t\tconst child = edge.getChild();\n\t\t\tif (visited.has(child)) continue;\n\t\t\tvisited.add(child);\n\n\t\t\tif (child instanceof TextureInfo && textureInfoNames.has(edge.getName())) {\n\t\t\t\tresults.add(child);\n\t\t\t} else if (child instanceof ExtensionProperty) {\n\t\t\t\ttraverse(child);\n\t\t\t}\n\t\t}\n\t}\n\n\ttraverse(material);\n\treturn Array.from(results);\n}\n", "import { Document, Texture } from '@gltf-transform/core';\n\n/**\n * Returns names of all texture slots using the given texture.\n *\n * Example:\n *\n * ```js\n * const slots = listTextureSlots(texture);\n * //  ['occlusionTexture', 'metallicRoughnesTexture']\n * ```\n */\nexport function listTextureSlots(texture: Texture): string[] {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tconst root = document.getRoot();\n\tconst slots = texture\n\t\t.getGraph()\n\t\t.listParentEdges(texture)\n\t\t.filter((edge) => edge.getParent() !== root)\n\t\t.map((edge) => edge.getName());\n\treturn Array.from(new Set(slots));\n}\n", "import {\n\tAnimationChannel,\n\tColorUtils,\n\tDocument,\n\tExtensionProperty,\n\tGraph,\n\tILogger,\n\tMaterial,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tProperty,\n\tPropertyType,\n\tRoot,\n\tScene,\n\tTexture,\n\tTextureInfo,\n\tTransform,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { mul as mulVec3 } from 'gl-matrix/vec3';\nimport { add, create, len, mul, scale, sub } from 'gl-matrix/vec4';\nimport { NdArray } from 'ndarray';\nimport { getPixels } from 'ndarray-pixels';\nimport { getTextureColorSpace } from './get-texture-color-space.js';\nimport { listTextureInfoByMaterial } from './list-texture-info.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport { assignDefaults, createTransform, isEmptyObject } from './utils.js';\n\nconst NAME = 'prune';\n\nconst EPS = 3 / 255;\n\nexport interface PruneOptions {\n\t/** List of {@link PropertyType} identifiers to be de-duplicated.*/\n\tpropertyTypes?: string[];\n\t/** Whether to keep empty leaf nodes. */\n\tkeepLeaves?: boolean;\n\t/** Whether to keep unused vertex attributes, such as UVs without an assigned texture. */\n\tkeepAttributes?: boolean;\n\t/** Whether to keep redundant mesh indices, where vertex count equals index count. */\n\tkeepIndices?: boolean;\n\t/** Whether to keep single-color textures that can be converted to material factors. */\n\tkeepSolidTextures?: boolean;\n\t/** Whether custom extras should prevent pruning a property. */\n\tkeepExtras?: boolean;\n}\n\nexport const PRUNE_DEFAULTS: Required<PruneOptions> = {\n\tpropertyTypes: [\n\t\tPropertyType.NODE,\n\t\tPropertyType.SKIN,\n\t\tPropertyType.MESH,\n\t\tPropertyType.CAMERA,\n\t\tPropertyType.PRIMITIVE,\n\t\tPropertyType.PRIMITIVE_TARGET,\n\t\tPropertyType.ANIMATION,\n\t\tPropertyType.MATERIAL,\n\t\tPropertyType.TEXTURE,\n\t\tPropertyType.ACCESSOR,\n\t\tPropertyType.BUFFER,\n\t],\n\tkeepLeaves: false,\n\tkeepAttributes: false,\n\tkeepIndices: false,\n\tkeepSolidTextures: false,\n\tkeepExtras: false,\n};\n\n/**\n * Removes properties from the file if they are not referenced by a {@link Scene}. Commonly helpful\n * for cleaning up after other operations, e.g. allowing a node to be detached and any unused\n * meshes, materials, or other resources to be removed automatically.\n *\n * Example:\n *\n * ```javascript\n * import { PropertyType } from '@gltf-transform/core';\n * import { prune } from '@gltf-transform/functions';\n *\n * document.getRoot().listMaterials(); //  [Material, Material]\n *\n * await document.transform(\n * \tprune({\n * \t\tpropertyTypes: [PropertyType.MATERIAL],\n * \t\tkeepExtras: true\n * \t})\n * );\n *\n * document.getRoot().listMaterials(); //  [Material]\n * ```\n *\n * By default, pruning will aggressively remove most unused resources. Use\n * {@link PruneOptions} to limit what is considered for pruning.\n *\n * @category Transforms\n */\nexport function prune(_options: PruneOptions = PRUNE_DEFAULTS): Transform {\n\tconst options = assignDefaults(PRUNE_DEFAULTS, _options);\n\tconst propertyTypes = new Set(options.propertyTypes);\n\tconst keepExtras = options.keepExtras;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\t\tconst graph = document.getGraph();\n\n\t\tconst counter = new DisposeCounter();\n\n\t\tconst onDispose = (event: { target: Property }) => counter.dispose(event.target);\n\t\t// TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tgraph.addEventListener('node:dispose', onDispose as any);\n\n\t\t// Prune top-down, so that low-level properties like accessors can be removed if the\n\t\t// properties referencing them are removed.\n\n\t\t// Prune empty Meshes.\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tif (mesh.listPrimitives().length > 0) continue;\n\t\t\t\tmesh.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.NODE)) {\n\t\t\tif (!options.keepLeaves) {\n\t\t\t\tfor (const scene of root.listScenes()) {\n\t\t\t\t\tnodeTreeShake(graph, scene, keepExtras);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const node of root.listNodes()) {\n\t\t\t\ttreeShake(node, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.SKIN)) {\n\t\t\tfor (const skin of root.listSkins()) {\n\t\t\t\ttreeShake(skin, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MESH)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\ttreeShake(mesh, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.CAMERA)) {\n\t\t\tfor (const camera of root.listCameras()) {\n\t\t\t\ttreeShake(camera, keepExtras);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE, keepExtras);\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.PRIMITIVE_TARGET)) {\n\t\t\tindirectTreeShake(graph, PropertyType.PRIMITIVE_TARGET, keepExtras);\n\t\t}\n\n\t\t// Prune unused vertex attributes.\n\t\tif (!options.keepAttributes && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tconst materialPrims = new Map<Material, Set<Primitive>>();\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\t\tif (!material) continue;\n\n\t\t\t\t\tconst required = listRequiredSemantics(document, prim, material);\n\t\t\t\t\tconst unused = listUnusedSemantics(prim, required);\n\t\t\t\t\tpruneAttributes(prim, unused);\n\t\t\t\t\tprim.listTargets().forEach((target) => pruneAttributes(target, unused));\n\t\t\t\t\tmaterialPrims.has(material)\n\t\t\t\t\t\t? materialPrims.get(material)!.add(prim)\n\t\t\t\t\t\t: materialPrims.set(material, new Set([prim]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [material, prims] of materialPrims) {\n\t\t\t\tshiftTexCoords(material, Array.from(prims));\n\t\t\t}\n\t\t}\n\n\t\t// Prune unused mesh indices.\n\t\tif (!options.keepIndices && propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\tfor (const mesh of root.listMeshes()) {\n\t\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\t\tpruneIndices(prim);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Pruning animations is a bit more complicated:\n\t\t// (1) Remove channels without target nodes.\n\t\t// (2) Remove animations without channels.\n\t\t// (3) Remove samplers orphaned in the process.\n\t\tif (propertyTypes.has(PropertyType.ANIMATION)) {\n\t\t\tfor (const anim of root.listAnimations()) {\n\t\t\t\tfor (const channel of anim.listChannels()) {\n\t\t\t\t\tif (!channel.getTargetNode()) {\n\t\t\t\t\t\tchannel.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!anim.listChannels().length) {\n\t\t\t\t\tconst samplers = anim.listSamplers();\n\t\t\t\t\ttreeShake(anim, keepExtras);\n\t\t\t\t\tsamplers.forEach((sampler) => treeShake(sampler, keepExtras));\n\t\t\t\t} else {\n\t\t\t\t\tanim.listSamplers().forEach((sampler) => treeShake(sampler, keepExtras));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.MATERIAL)) {\n\t\t\troot.listMaterials().forEach((material) => treeShake(material, keepExtras));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.TEXTURE)) {\n\t\t\troot.listTextures().forEach((texture) => treeShake(texture, keepExtras));\n\t\t\tif (!options.keepSolidTextures) {\n\t\t\t\tawait pruneSolidTextures(document);\n\t\t\t}\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.ACCESSOR)) {\n\t\t\troot.listAccessors().forEach((accessor) => treeShake(accessor, keepExtras));\n\t\t}\n\n\t\tif (propertyTypes.has(PropertyType.BUFFER)) {\n\t\t\troot.listBuffers().forEach((buffer) => treeShake(buffer, keepExtras));\n\t\t}\n\n\t\t// TODO(bug): This process does not identify unused ExtensionProperty instances. That could\n\t\t// be a future enhancement, either tracking unlinked properties as if they were connected\n\t\t// to the Graph, or iterating over a property list provided by the Extension. Properties in\n\t\t// use by an Extension are correctly preserved, in the meantime.\n\n\t\t// TODO(cleanup): Publish GraphEvent / GraphEventListener types from 'property-graph'.\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tgraph.removeEventListener('node:dispose', onDispose as any);\n\n\t\tif (!counter.empty()) {\n\t\t\tconst str = counter\n\t\t\t\t.entries()\n\t\t\t\t.map(([type, count]) => `${type} (${count})`)\n\t\t\t\t.join(', ');\n\t\t\tlogger.info(`${NAME}: Removed types... ${str}`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: No unused properties found.`);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**********************************************************************************************\n * Utility for disposing properties and reporting statistics afterward.\n */\n\nclass DisposeCounter {\n\tpublic readonly disposed: Record<string, number> = {};\n\n\tempty(): boolean {\n\t\tfor (const key in this.disposed) return false;\n\t\treturn true;\n\t}\n\n\tentries(): [string, number][] {\n\t\treturn Object.entries(this.disposed);\n\t}\n\n\t/** Records properties disposed by type. */\n\tdispose(prop: Property): void {\n\t\tthis.disposed[prop.propertyType] = this.disposed[prop.propertyType] || 0;\n\t\tthis.disposed[prop.propertyType]++;\n\t}\n}\n\n/**********************************************************************************************\n * Helper functions for the {@link prune} transform.\n *\n * IMPORTANT: These functions were previously declared in function scope, but\n * broke in the CommonJS build due to a buggy Babel transform. See:\n * https://github.com/donmccurdy/glTF-Transform/issues/1140\n */\n\n/** Disposes of the given property if it is unused. */\nfunction treeShake(prop: Property, keepExtras: boolean): void {\n\t// Consider a property unused if it has no references from another property, excluding\n\t// types Root and AnimationChannel.\n\tconst parents = prop.listParents().filter((p) => !(p instanceof Root || p instanceof AnimationChannel));\n\tconst needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n\tif (!parents.length && !needsExtras) {\n\t\tprop.dispose();\n\t}\n}\n\n/**\n * For property types the Root does not maintain references to, we'll need to search the\n * graph. It's possible that objects may have been constructed without any outbound links,\n * but since they're not on the graph they don't need to be tree-shaken.\n */\nfunction indirectTreeShake(graph: Graph<Property>, propertyType: string, keepExtras: boolean): void {\n\tfor (const edge of graph.listEdges()) {\n\t\tconst parent = edge.getParent();\n\t\tif (parent.propertyType === propertyType) {\n\t\t\ttreeShake(parent, keepExtras);\n\t\t}\n\t}\n}\n\n/** Iteratively prunes leaf Nodes without contents. */\nfunction nodeTreeShake(graph: Graph<Property>, prop: Node | Scene, keepExtras: boolean): void {\n\tprop.listChildren().forEach((child) => nodeTreeShake(graph, child, keepExtras));\n\n\tif (prop instanceof Scene) return;\n\n\tconst isUsed = graph.listParentEdges(prop).some((e) => {\n\t\tconst ptype = e.getParent().propertyType;\n\t\treturn ptype !== PropertyType.ROOT && ptype !== PropertyType.SCENE && ptype !== PropertyType.NODE;\n\t});\n\tconst isEmpty = graph.listChildren(prop).length === 0;\n\tconst needsExtras = keepExtras && !isEmptyObject(prop.getExtras());\n\tif (isEmpty && !isUsed && !needsExtras) {\n\t\tprop.dispose();\n\t}\n}\n\nfunction pruneAttributes(prim: Primitive | PrimitiveTarget, unused: string[]) {\n\tfor (const semantic of unused) {\n\t\tprim.setAttribute(semantic, null);\n\t}\n}\n\nfunction pruneIndices(prim: Primitive) {\n\tconst indices = prim.getIndices();\n\tconst indicesArray = indices && indices.getArray();\n\tconst attribute = prim.listAttributes()[0];\n\n\tif (!indicesArray || !attribute) {\n\t\treturn;\n\t}\n\n\tif (indices.getCount() !== attribute.getCount()) {\n\t\treturn;\n\t}\n\n\tfor (let i = 0, il = indicesArray.length; i < il; i++) {\n\t\tif (i !== indicesArray[i]) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprim.setIndices(null);\n}\n\n/**\n * Lists vertex attribute semantics that are unused when rendering a given primitive.\n */\nfunction listUnusedSemantics(prim: Primitive | PrimitiveTarget, required: Set<string>): string[] {\n\tconst unused = [];\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (semantic === 'NORMAL' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic === 'TANGENT' && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('TEXCOORD_') && !required.has(semantic)) {\n\t\t\tunused.push(semantic);\n\t\t} else if (semantic.startsWith('COLOR_') && semantic !== 'COLOR_0') {\n\t\t\tunused.push(semantic);\n\t\t}\n\t}\n\treturn unused;\n}\n\n/**\n * Lists vertex attribute semantics required by a material. Does not include\n * attributes that would be used unconditionally, like POSITION or NORMAL.\n */\nfunction listRequiredSemantics(\n\tdocument: Document,\n\tprim: Primitive,\n\tmaterial: Material | ExtensionProperty,\n\tsemantics = new Set<string>(),\n): Set<string> {\n\tconst graph = document.getGraph();\n\n\tconst edges = graph.listChildEdges(material);\n\tconst textureNames = new Set<string>();\n\n\tfor (const edge of edges) {\n\t\tif (edge.getChild() instanceof Texture) {\n\t\t\ttextureNames.add(edge.getName());\n\t\t}\n\t}\n\n\tfor (const edge of edges) {\n\t\tconst name = edge.getName();\n\t\tconst child = edge.getChild();\n\n\t\tif (child instanceof TextureInfo) {\n\t\t\tif (textureNames.has(name.replace(/Info$/, ''))) {\n\t\t\t\tsemantics.add(`TEXCOORD_${child.getTexCoord()}`);\n\t\t\t}\n\t\t}\n\n\t\tif (child instanceof Texture && name.match(/normalTexture/i)) {\n\t\t\tsemantics.add('TANGENT');\n\t\t}\n\n\t\tif (child instanceof ExtensionProperty) {\n\t\t\tlistRequiredSemantics(document, prim, child, semantics);\n\t\t}\n\n\t\t// TODO(#748): Does KHR_materials_anisotropy imply required vertex attributes?\n\t}\n\n\tconst isLit = material instanceof Material && !material.getExtension('KHR_materials_unlit');\n\tconst isPoints = prim.getMode() === Primitive.Mode.POINTS;\n\tif (isLit && !isPoints) {\n\t\tsemantics.add('NORMAL');\n\t}\n\n\treturn semantics;\n}\n\n/**\n * Shifts texCoord indices on the given material and primitives assigned to\n * that material, such that indices start at zero and ascend without gaps.\n * Prior to calling this function, the implementation must ensure that:\n * - All TEXCOORD_n attributes on these prims are used by the material.\n * - Material does not require any unavailable TEXCOORD_n attributes.\n *\n * TEXCOORD_n attributes on morph targets are shifted alongside the parent\n * prim, but gaps may remain in their semantic lists.\n */\nfunction shiftTexCoords(material: Material, prims: Primitive[]) {\n\t// Create map from srcTexCoord  dstTexCoord.\n\tconst textureInfoList = listTextureInfoByMaterial(material);\n\tconst texCoordSet = new Set(textureInfoList.map((info: TextureInfo) => info.getTexCoord()));\n\tconst texCoordList = Array.from(texCoordSet).sort();\n\tconst texCoordMap = new Map(texCoordList.map((texCoord, index) => [texCoord, index]));\n\tconst semanticMap = new Map(texCoordList.map((texCoord, index) => [`TEXCOORD_${texCoord}`, `TEXCOORD_${index}`]));\n\n\t// Update material.\n\tfor (const textureInfo of textureInfoList) {\n\t\tconst texCoord = textureInfo.getTexCoord();\n\t\ttextureInfo.setTexCoord(texCoordMap.get(texCoord)!);\n\t}\n\n\t// Update prims.\n\tfor (const prim of prims) {\n\t\tconst semantics = prim\n\t\t\t.listSemantics()\n\t\t\t.filter((semantic) => semantic.startsWith('TEXCOORD_'))\n\t\t\t.sort();\n\t\tupdatePrim(prim, semantics);\n\t\tprim.listTargets().forEach((target) => updatePrim(target, semantics));\n\t}\n\n\tfunction updatePrim(prim: Primitive | PrimitiveTarget, srcSemantics: string[]) {\n\t\tfor (const srcSemantic of srcSemantics) {\n\t\t\tconst uv = prim.getAttribute(srcSemantic);\n\t\t\tif (!uv) continue;\n\n\t\t\tconst dstSemantic = semanticMap.get(srcSemantic)!;\n\t\t\tif (dstSemantic === srcSemantic) continue;\n\n\t\t\tprim.setAttribute(dstSemantic, uv);\n\t\t\tprim.setAttribute(srcSemantic, null);\n\t\t}\n\t}\n}\n\n/**********************************************************************************************\n * Prune solid (single-color) textures.\n */\n\nasync function pruneSolidTextures(document: Document): Promise<void> {\n\tconst root = document.getRoot();\n\tconst graph = document.getGraph();\n\tconst logger = document.getLogger();\n\tconst textures = root.listTextures();\n\n\tconst pending = textures.map(async (texture) => {\n\t\tconst factor = await getTextureFactor(texture);\n\t\tif (!factor) return;\n\n\t\tif (getTextureColorSpace(texture) === 'srgb') {\n\t\t\tColorUtils.convertSRGBToLinear(factor, factor);\n\t\t}\n\n\t\tconst name = texture.getName() || texture.getURI();\n\t\tconst size = texture.getSize()?.join('x');\n\t\tconst slots = listTextureSlots(texture);\n\n\t\tfor (const edge of graph.listParentEdges(texture)) {\n\t\t\tconst parent = edge.getParent();\n\t\t\tif (parent !== root && applyMaterialFactor(parent as Material, factor, edge.getName(), logger)) {\n\t\t\t\tedge.dispose();\n\t\t\t}\n\t\t}\n\n\t\tif (texture.listParents().length === 1) {\n\t\t\ttexture.dispose();\n\t\t\tlogger.debug(`${NAME}: Removed solid-color texture \"${name}\" (${size}px ${slots.join(', ')})`);\n\t\t}\n\t});\n\n\tawait Promise.all(pending);\n}\n\nfunction applyMaterialFactor(\n\tmaterial: Material | ExtensionProperty,\n\tfactor: vec4,\n\tslot: string,\n\tlogger: ILogger,\n): boolean {\n\tif (material instanceof Material) {\n\t\tswitch (slot) {\n\t\t\tcase 'baseColorTexture':\n\t\t\t\tmaterial.setBaseColorFactor(mul(factor, factor, material.getBaseColorFactor()) as vec4);\n\t\t\t\treturn true;\n\t\t\tcase 'emissiveTexture':\n\t\t\t\tmaterial.setEmissiveFactor(\n\t\t\t\t\tmulVec3([0, 0, 0], factor.slice(0, 3) as vec3, material.getEmissiveFactor()) as vec3,\n\t\t\t\t);\n\t\t\t\treturn true;\n\t\t\tcase 'occlusionTexture':\n\t\t\t\treturn Math.abs(factor[0] - 1) <= EPS;\n\t\t\tcase 'metallicRoughnessTexture':\n\t\t\t\tmaterial.setRoughnessFactor(factor[1] * material.getRoughnessFactor());\n\t\t\t\tmaterial.setMetallicFactor(factor[2] * material.getMetallicFactor());\n\t\t\t\treturn true;\n\t\t\tcase 'normalTexture':\n\t\t\t\treturn len(sub(create(), factor, [0.5, 0.5, 1, 1])) <= EPS;\n\t\t}\n\t}\n\n\tlogger.warn(`${NAME}: Detected single-color ${slot} texture. Pruning ${slot} not yet supported.`);\n\treturn false;\n}\n\nasync function getTextureFactor(texture: Texture): Promise<vec4 | null> {\n\tconst pixels = await maybeGetPixels(texture);\n\tif (!pixels) return null;\n\n\tconst min: vec4 = [Infinity, Infinity, Infinity, Infinity];\n\tconst max: vec4 = [-Infinity, -Infinity, -Infinity, -Infinity];\n\tconst target: vec4 = [0, 0, 0, 0];\n\n\tconst [width, height] = pixels.shape;\n\n\tfor (let i = 0; i < width; i++) {\n\t\tfor (let j = 0; j < height; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tmin[k] = Math.min(min[k], pixels.get(i, j, k));\n\t\t\t\tmax[k] = Math.max(max[k], pixels.get(i, j, k));\n\t\t\t}\n\t\t}\n\n\t\tif (len(sub(target, max, min)) / 255 > EPS) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn scale(target, add(target, max, min), 0.5 / 255) as vec4;\n}\n\nasync function maybeGetPixels(texture: Texture): Promise<NdArray<Uint8Array> | null> {\n\ttry {\n\t\treturn await getPixels(texture.getImage()!, texture.getMimeType());\n\t} catch (e) {\n\t\treturn null;\n\t}\n}\n", "import { Accessor, BufferUtils, Primitive } from '@gltf-transform/core';\nimport { deepListAttributes } from './utils.js';\n\n/** Flags 'empty' values in a Uint32Array index. */\nexport const EMPTY_U32 = 2 ** 32 - 1;\n\nexport class VertexStream {\n\tprivate attributes: { u8: Uint8Array; byteStride: number; paddedByteStride: number }[] = [];\n\n\t/** Temporary vertex views in 4-byte-aligned memory. */\n\tprivate u8: Uint8Array;\n\tprivate u32: Uint32Array;\n\n\tconstructor(prim: Primitive) {\n\t\tlet byteStride = 0;\n\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\tbyteStride += this._initAttribute(attribute);\n\t\t}\n\t\tthis.u8 = new Uint8Array(byteStride);\n\t\tthis.u32 = new Uint32Array(this.u8.buffer);\n\t}\n\n\tprivate _initAttribute(attribute: Accessor): number {\n\t\tconst array = attribute.getArray()!;\n\t\tconst u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\t\tconst byteStride = attribute.getElementSize() * attribute.getComponentSize();\n\t\tconst paddedByteStride = BufferUtils.padNumber(byteStride);\n\t\tthis.attributes.push({ u8, byteStride, paddedByteStride });\n\t\treturn paddedByteStride;\n\t}\n\n\thash(index: number): number {\n\t\t// Load vertex into 4-byte-aligned view.\n\t\tlet byteOffset = 0;\n\t\tfor (const { u8, byteStride, paddedByteStride } of this.attributes) {\n\t\t\tfor (let i = 0; i < paddedByteStride; i++) {\n\t\t\t\tif (i < byteStride) {\n\t\t\t\t\tthis.u8[byteOffset + i] = u8[index * byteStride + i];\n\t\t\t\t} else {\n\t\t\t\t\tthis.u8[byteOffset + i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyteOffset += paddedByteStride;\n\t\t}\n\n\t\t// Compute hash.\n\t\treturn murmurHash2(0, this.u32);\n\t}\n\n\tequal(a: number, b: number): boolean {\n\t\tfor (const { u8, byteStride } of this.attributes) {\n\t\t\tfor (let j = 0; j < byteStride; j++) {\n\t\t\t\tif (u8[a * byteStride + j] !== u8[b * byteStride + j]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n/**\n * References:\n * - https://github.com/mikolalysenko/murmurhash-js/blob/f19136e9f9c17f8cddc216ca3d44ec7c5c502f60/murmurhash2_gc.js#L14\n * - https://github.com/zeux/meshoptimizer/blob/e47e1be6d3d9513153188216455bdbed40a206ef/src/indexgenerator.cpp#L12\n */\nfunction murmurHash2(h: number, key: Uint32Array): number {\n\t// MurmurHash2\n\tconst m = 0x5bd1e995;\n\tconst r = 24;\n\n\tfor (let i = 0, il = key.length; i < il; i++) {\n\t\tlet k = key[i];\n\n\t\tk = Math.imul(k, m) >>> 0;\n\t\tk = (k ^ (k >> r)) >>> 0;\n\t\tk = Math.imul(k, m) >>> 0;\n\n\t\th = Math.imul(h, m) >>> 0;\n\t\th = (h ^ k) >>> 0;\n\t}\n\n\treturn h;\n}\n\nexport function hashLookup(\n\ttable: Uint32Array,\n\tbuckets: number,\n\tstream: VertexStream,\n\tkey: number,\n\tempty = EMPTY_U32,\n): number {\n\tconst hashmod = buckets - 1;\n\tconst hashval = stream.hash(key);\n\tlet bucket = hashval & hashmod;\n\n\tfor (let probe = 0; probe <= hashmod; probe++) {\n\t\tconst item = table[bucket];\n\n\t\tif (item === empty || stream.equal(item, key)) {\n\t\t\treturn bucket;\n\t\t}\n\n\t\tbucket = (bucket + probe + 1) & hashmod; // Hash collision.\n\t}\n\n\tthrow new Error('Hash table full.');\n}\n", "import { Scene, Node, Mesh, Primitive, Accessor } from '@gltf-transform/core';\nimport { InstancedMesh } from '@gltf-transform/extensions';\n\n/**\n * Various methods of estimating a vertex count. For some background on why\n * multiple definitions of a vertex count should exist, see [_Vertex Count\n * Higher in Engine than in 3D Software_](https://shahriyarshahrabi.medium.com/vertex-count-higher-in-engine-than-in-3d-software-badc348ada66).\n * Totals for a {@link Scene}, {@link Node}, or {@link Mesh} will not\n * necessarily match the sum of the totals for each {@link Primitive}. Choose\n * the appropriate method for a relevant total or estimate:\n *\n * - {@link getSceneVertexCount}\n * - {@link getNodeVertexCount}\n * - {@link getMeshVertexCount}\n * - {@link getPrimitiveVertexCount}\n *\n * Many rendering features, such as volumetric transmission, may lead\n * to additional passes over some or all vertices. These tradeoffs are\n * implementation-dependent, and not considered here.\n */\nexport enum VertexCountMethod {\n\t/**\n\t * Expected number of vertices processed by the vertex shader for one render\n\t * pass, without considering the vertex cache.\n\t */\n\tRENDER = 'render',\n\n\t/**\n\t * Expected number of vertices processed by the vertex shader for one render\n\t * pass, assuming an Average Transform to Vertex Ratio (ATVR) of 1. Approaching\n\t * this result requires optimizing for locality of vertex references (see\n\t * {@link reorder}).\n\t *\n\t * References:\n\t * - [ACMR and ATVR](https://www.realtimerendering.com/blog/acmr-and-atvr/), Real-Time Rendering\n\t */\n\tRENDER_CACHED = 'render-cached',\n\n\t/**\n\t * Expected number of vertices uploaded to the GPU, assuming that a client\n\t * uploads each unique {@link Accessor} only once. Unless glTF vertex\n\t * attributes are pre-processed to a known buffer layout, and the client is\n\t * optimized for that buffer layout, this total will be optimistic.\n\t */\n\tUPLOAD = 'upload',\n\n\t/**\n\t * Expected number of vertices uploaded to the GPU, assuming that a client\n\t * uploads each unique {@link Primitive} individually, duplicating vertex\n\t * attribute {@link Accessor Accessors} shared by multiple primitives, but\n\t * never uploading the same Mesh or Primitive to GPU memory more than once.\n\t */\n\tUPLOAD_NAIVE = 'upload-naive',\n\n\t/**\n\t * Total number of unique vertices represented, considering all attributes of\n\t * each vertex, and removing any duplicates. Has no direct relationship to\n\t * runtime characteristics, but may be helpful in identifying asset\n\t * optimization opportunities.\n\t *\n\t * @hidden TODO(feat): Not yet implemented.\n\t * @internal\n\t */\n\tDISTINCT = 'distinct',\n\n\t/**\n\t * Total number of unique vertices represented, considering only vertex\n\t * positions, and removing any duplicates. Has no direct relationship to\n\t * runtime characteristics, but may be helpful in identifying asset\n\t * optimization opportunities.\n\t *\n\t * @hidden TODO(feat): Not yet implemented.\n\t * @internal\n\t */\n\tDISTINCT_POSITION = 'distinct-position',\n\n\t/**\n\t * Number of vertex positions never used by any {@link Primitive}. If all\n\t * vertices are unused, this total will match `UPLOAD`.\n\t */\n\tUNUSED = 'unused',\n}\n\n/**\n * Computes total number of vertices in a {@link Scene}, by the\n * specified method. Totals for the Scene will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getSceneVertexCount(scene: Scene, method: VertexCountMethod): number {\n\treturn _getSubtreeVertexCount(scene, method);\n}\n\n/**\n * Computes total number of vertices in a {@link Node}, by the\n * specified method. Totals for the node will not necessarily match the sum\n * of the totals for each {@link Mesh} or {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getNodeVertexCount(node: Node | Scene, method: VertexCountMethod): number {\n\treturn _getSubtreeVertexCount(node, method);\n}\n\nfunction _getSubtreeVertexCount(node: Node | Scene, method: VertexCountMethod): number {\n\tconst instancedMeshes: [number, Mesh][] = [];\n\tconst nonInstancedMeshes: Mesh[] = [];\n\tconst meshes: Mesh[] = [];\n\n\tnode.traverse((node) => {\n\t\tconst mesh = node.getMesh();\n\t\tconst batch = node.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\tif (batch && mesh) {\n\t\t\tmeshes.push(mesh);\n\t\t\tinstancedMeshes.push([batch.listAttributes()[0]!.getCount(), mesh]);\n\t\t} else if (mesh) {\n\t\t\tmeshes.push(mesh);\n\t\t\tnonInstancedMeshes.push(mesh);\n\t\t}\n\t});\n\n\tconst prims = meshes.flatMap((mesh) => mesh.listPrimitives());\n\tconst positions = prims.map((prim) => prim.getAttribute('POSITION')!);\n\tconst uniquePositions = Array.from(new Set(positions));\n\tconst uniqueMeshes = Array.from(new Set(meshes));\n\tconst uniquePrims = Array.from(new Set(uniqueMeshes.flatMap((mesh) => mesh.listPrimitives())));\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\t\treturn (\n\t\t\t\t_sum(nonInstancedMeshes.map((mesh) => getMeshVertexCount(mesh, method))) +\n\t\t\t\t_sum(instancedMeshes.map(([batch, mesh]) => batch * getMeshVertexCount(mesh, method)))\n\t\t\t);\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\t\treturn _sum(uniqueMeshes.map((mesh) => getMeshVertexCount(mesh, method)));\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn _sum(uniquePositions.map((attribute) => attribute.getCount()));\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn _sumUnused(uniquePrims);\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\n/**\n * Computes total number of vertices in a {@link Mesh}, by the\n * specified method. Totals for the Mesh will not necessarily match the sum\n * of the totals for each {@link Primitive} within it. See\n * {@link VertexCountMethod} for available methods.\n */\nexport function getMeshVertexCount(mesh: Mesh, method: VertexCountMethod): number {\n\tconst prims = mesh.listPrimitives();\n\tconst uniquePrims = Array.from(new Set(prims));\n\tconst uniquePositions = Array.from(new Set(uniquePrims.map((prim) => prim.getAttribute('POSITION')!)));\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\t\treturn _sum(prims.map((prim) => getPrimitiveVertexCount(prim, method)));\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn _sum(uniquePositions.map((attribute) => attribute.getCount()));\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn _sumUnused(uniquePrims);\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\n/**\n * Computes total number of vertices in a {@link Primitive}, by the\n * specified method. See {@link VertexCountMethod} for available methods.\n */\nexport function getPrimitiveVertexCount(prim: Primitive, method: VertexCountMethod): number {\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst indices = prim.getIndices();\n\n\tswitch (method) {\n\t\tcase VertexCountMethod.RENDER:\n\t\t\treturn indices ? indices.getCount() : position.getCount();\n\t\tcase VertexCountMethod.RENDER_CACHED:\n\t\t\treturn indices ? new Set(indices.getArray()).size : position.getCount();\n\t\tcase VertexCountMethod.UPLOAD_NAIVE:\n\t\tcase VertexCountMethod.UPLOAD:\n\t\t\treturn position.getCount();\n\t\tcase VertexCountMethod.DISTINCT:\n\t\tcase VertexCountMethod.DISTINCT_POSITION:\n\t\t\treturn _assertNotImplemented(method);\n\t\tcase VertexCountMethod.UNUSED:\n\t\t\treturn indices ? position.getCount() - new Set(indices.getArray()).size : 0;\n\t\tdefault:\n\t\t\treturn _assertUnreachable(method);\n\t}\n}\n\nfunction _sum(values: number[]): number {\n\tlet total = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\ttotal += values[i];\n\t}\n\treturn total;\n}\n\nfunction _sumUnused(prims: Primitive[]) {\n\tconst attributeIndexMap = new Map<Accessor, Set<Accessor | null>>();\n\tfor (const prim of prims) {\n\t\tconst position = prim.getAttribute('POSITION')!;\n\t\tconst indices = prim.getIndices();\n\t\tconst indicesSet = attributeIndexMap.get(position) || new Set();\n\t\tindicesSet.add(indices);\n\t\tattributeIndexMap.set(position, indicesSet);\n\t}\n\n\tlet unused = 0;\n\tfor (const [position, indicesSet] of attributeIndexMap) {\n\t\tif (indicesSet.has(null)) continue;\n\n\t\tconst usedIndices = new Uint8Array(position.getCount());\n\t\tfor (const indices of indicesSet as Set<Accessor>) {\n\t\t\tconst indicesArray = indices.getArray()!;\n\t\t\tfor (let i = 0, il = indicesArray.length; i < il; i++) {\n\t\t\t\tusedIndices[indicesArray[i]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, il = position.getCount(); i < il; i++) {\n\t\t\tif (usedIndices[i] === 0) unused++;\n\t\t}\n\t}\n\n\treturn unused;\n}\n\nfunction _assertNotImplemented<T>(x: unknown): T {\n\tthrow new Error(`Not implemented: ${x}`);\n}\n\nfunction _assertUnreachable<T>(x: never): T {\n\tthrow new Error(`Unexpected value: ${x}`);\n}\n", "import { Accessor, Document, Primitive, TypedArray, TypedArrayConstructor } from '@gltf-transform/core';\nimport { createIndices, createIndicesEmpty, deepListAttributes, shallowCloneAccessor } from './utils.js';\nimport { VertexCountMethod, getPrimitiveVertexCount } from './get-vertex-count.js';\nimport { EMPTY_U32 } from './hash-table.js';\n\n/**\n * Rewrites a {@link Primitive} such that all unused vertices in its vertex\n * attributes are removed. When multiple Primitives share vertex attributes,\n * each indexing only a few, compaction can be used to produce Primitives\n * each having smaller, independent vertex streams instead.\n *\n * Regardless of whether the Primitive is indexed or contains unused vertices,\n * compaction will clone every {@link Accessor}. The resulting Primitive will\n * share no Accessors with other Primitives, allowing later changes to\n * the vertex stream to be applied in isolation.\n *\n * Example:\n *\n * ```javascript\n * import { compactPrimitive, transformMesh } from '@gltf-transform/functions';\n * import { fromTranslation } from 'gl-matrix/mat4';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n * const prim = mesh.listPrimitives().find((prim) => { ... });\n *\n * // Compact primitive, removing unused vertices and detaching shared vertex\n * // attributes. Without compaction, `transformPrimitive` might affect other\n * // primitives sharing the same vertex attributes.\n * compactPrimitive(prim);\n *\n * // Transform primitive vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * Parameters 'remap' and 'dstVertexCount' are optional. When either is\n * provided, the other must be provided as well. If one or both are missing,\n * both will be computed from the mesh indices.\n *\n * @param remap - Mapping. Array index represents vertex index in the source\n *\t\tattributes, array value represents index in the resulting compacted\n *\t\tprimitive. When omitted, calculated from indices.\n * @param dstVertexcount - Number of unique vertices in compacted primitive.\n *\t\tWhen omitted, calculated from indices.\n */\n// TODO(cleanup): Additional signatures currently break greendoc/parse.\n// export function compactPrimitive(prim: Primitive): Primitive;\n// export function compactPrimitive(prim: Primitive, remap: TypedArray, dstVertexCount: number): Primitive;\nexport function compactPrimitive(prim: Primitive, remap?: TypedArray, dstVertexCount?: number): Primitive {\n\tconst document = Document.fromGraph(prim.getGraph())!;\n\n\tif (!remap || !dstVertexCount) {\n\t\t[remap, dstVertexCount] = createCompactPlan(prim);\n\t}\n\n\t// Remap indices.\n\n\tconst srcIndices = prim.getIndices();\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcIndicesCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\n\tconst dstIndices = document.createAccessor();\n\tconst dstIndicesCount = srcIndicesCount; // primitive count does not change.\n\tconst dstIndicesArray = createIndicesEmpty(dstIndicesCount, dstVertexCount);\n\n\tfor (let i = 0; i < dstIndicesCount; i++) {\n\t\tdstIndicesArray[i] = remap[srcIndicesArray ? srcIndicesArray[i] : i];\n\t}\n\n\tprim.setIndices(dstIndices.setArray(dstIndicesArray));\n\n\t// Remap vertices.\n\n\tconst srcAttributesPrev = deepListAttributes(prim);\n\n\tfor (const srcAttribute of prim.listAttributes()) {\n\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n\t\tprim.swap(srcAttribute, dstAttribute);\n\t}\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, dstVertexCount);\n\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t}\n\t}\n\n\t// Clean up accessors.\n\n\tif (srcIndices && srcIndices.listParents().length === 1) {\n\t\tsrcIndices.dispose();\n\t}\n\tfor (const srcAttribute of srcAttributesPrev) {\n\t\tif (srcAttribute.listParents().length === 1) {\n\t\t\tsrcAttribute.dispose();\n\t\t}\n\t}\n\n\treturn prim;\n}\n\n/**\n * Copies srcAttribute to dstAttribute, using the given indices and remap (srcIndex -> dstIndex).\n * Any existing array in dstAttribute is replaced. Vertices not used by the index are eliminated,\n * leaving a compact attribute.\n * @hidden\n * @internal\n */\nexport function compactAttribute(\n\tsrcAttribute: Accessor,\n\tsrcIndices: Accessor | null,\n\tremap: TypedArray,\n\tdstAttribute: Accessor,\n\tdstVertexCount: number,\n): Accessor {\n\tconst elementSize = srcAttribute.getElementSize();\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcAttribute.getCount();\n\tconst dstArray = new (srcArray.constructor as TypedArrayConstructor)(dstVertexCount * elementSize);\n\tconst dstDone = new Uint8Array(dstVertexCount);\n\n\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tconst dstIndex = remap[srcIndex];\n\t\tif (dstDone[dstIndex]) continue;\n\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n\t\t}\n\n\t\tdstDone[dstIndex] = 1;\n\t}\n\n\treturn dstAttribute.setArray(dstArray);\n}\n\n/**\n * Creates a 'remap' and 'dstVertexCount' plan for indexed primitives,\n * such that they can be rewritten with {@link compactPrimitive} removing\n * any non-rendered vertices.\n * @hidden\n * @internal\n */\nfunction createCompactPlan(prim: Primitive): [Uint32Array, number] {\n\tconst srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\n\tconst indices = prim.getIndices();\n\tconst indicesArray = indices ? indices.getArray() : null;\n\tif (!indices || !indicesArray) {\n\t\treturn [createIndices(srcVertexCount, 1_000_000) as Uint32Array, srcVertexCount];\n\t}\n\n\tconst remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32);\n\n\tlet dstVertexCount = 0;\n\n\tfor (let i = 0; i < indicesArray.length; i++) {\n\t\tconst srcIndex = indicesArray[i];\n\t\tif (remap[srcIndex] === EMPTY_U32) {\n\t\t\tremap[srcIndex] = dstVertexCount++;\n\t\t}\n\t}\n\n\treturn [remap, dstVertexCount];\n}\n", "import { Document, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { dedup } from './dedup.js';\nimport { prune } from './prune.js';\nimport { EMPTY_U32, VertexStream, hashLookup } from './hash-table.js';\nimport { assignDefaults, ceilPowerOfTwo, createTransform, formatDeltaOp } from './utils.js';\nimport { compactPrimitive } from './compact-primitive.js';\nimport { VertexCountMethod, getPrimitiveVertexCount } from './get-vertex-count.js';\n\n/**\n * CONTRIBUTOR NOTES\n *\n * Ideally a weld() implementation should be fast, robust, and tunable. The\n * writeup below tracks my attempts to solve for these constraints.\n *\n * (Approach #1) Follow the mergeVertices() implementation of three.js,\n * hashing vertices with a string concatenation of all vertex attributes.\n * The approach does not allow per-attribute tolerance in local units.\n *\n * (Approach #2) Sort points along the X axis, then make cheaper\n * searches up/down the sorted list for merge candidates. While this allows\n * simpler comparison based on specified tolerance, it's much slower, even\n * for cases where choice of the X vs. Y or Z axes is reasonable.\n *\n * (Approach #3) Attempted a Delaunay triangulation in three dimensions,\n * expecting it would be an n * log(n) algorithm, but the only implementation\n * I found (with delaunay-triangulate) appeared to be much slower than that,\n * and was notably slower than the sort-based approach, just building the\n * Delaunay triangulation alone.\n *\n * (Approach #4) Hybrid of (1) and (2), assigning vertices to a spatial\n * grid, then searching the local neighborhood (27 cells) for weld candidates.\n *\n * (Approach #5) Based on Meshoptimizer's implementation, when tolerance=0\n * use a hashtable to find bitwise-equal vertices quickly. Vastly faster than\n * previous approaches, but without tolerance options.\n *\n * RESULTS: For the \"Lovecraftian\" sample model linked below, after joining,\n * a primitive with 873,000 vertices can be welded down to 230,000 vertices.\n * https://sketchfab.com/3d-models/sculpt-january-day-19-lovecraftian-34ad2501108e4fceb9394f5b816b9f42\n *\n * - (1) Not tested, but prior results suggest not robust enough.\n * - (2) 30s\n * - (3) 660s\n * - (4) 5s exhaustive, 1.5s non-exhaustive\n * - (5) 0.2s\n *\n * As of April 2024, the lossy weld was removed, leaving only approach #5. An\n * upcoming Meshoptimizer release will include a simplifyWithAttributes\n * function allowing simplification with weighted consideration of vertex\n * attributes, which I hope to support. With that, weld() may remain faster,\n * simpler, and more maintainable.\n */\n\nconst NAME = 'weld';\n\n/** Options for the {@link weld} function. */\nexport interface WeldOptions {\n\t/** Whether to overwrite existing indices. */\n\toverwrite?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const WELD_DEFAULTS: Required<WeldOptions> = {\n\toverwrite: true,\n\tcleanup: true,\n};\n\n/**\n * Welds {@link Primitive Primitives}, merging bitwise identical vertices. When\n * merged and indexed, data is shared more efficiently between vertices. File size\n * can be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weld, getSceneVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const scene = document.getDefaultScene();\n * const srcVertexCount = getSceneVertexCount(scene, VertexCountMethod.GPU);\n * await document.transform(weld());\n * const dstVertexCount = getSceneVertexCount(scene, VertexCountMethod.GPU);\n * ```\n *\n * @category Transforms\n */\nexport function weld(_options: WeldOptions = WELD_DEFAULTS): Transform {\n\tconst options = assignDefaults(WELD_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tweldPrimitive(prim, options);\n\n\t\t\t\tif (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n\t\t\t\t\tprim.dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\t// Welding removes degenerate meshes; prune leaf nodes afterward.\n\t\tif (options.cleanup) {\n\t\t\tawait doc.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.NODE],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: false,\n\t\t\t\t}),\n\t\t\t\tdedup({ propertyTypes: [PropertyType.ACCESSOR] }),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Welds a {@link Primitive}, merging bitwise identical vertices. When merged\n * and indexed, data is shared more efficiently between vertices. File size can\n * be reduced, and the GPU uses the vertex cache more efficiently.\n *\n * Example:\n *\n * ```javascript\n * import { weldPrimitive, getMeshVertexCount, VertexCountMethod } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes()\n * \t.find((mesh) => mesh.getName() === 'Gizmo');\n *\n * const srcVertexCount = getMeshVertexCount(mesh, VertexCountMethod.GPU);\n *\n * for (const prim of mesh.listPrimitives()) {\n *   weldPrimitive(prim);\n * }\n *\n * const dstVertexCount = getMeshVertexCount(mesh, VertexCountMethod.GPU);\n * ```\n */\nexport function weldPrimitive(prim: Primitive, _options: WeldOptions = WELD_DEFAULTS): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\tconst options = { ...WELD_DEFAULTS, ..._options };\n\n\tif (prim.getIndices() && !options.overwrite) return;\n\tif (prim.getMode() === Primitive.Mode.POINTS) return;\n\n\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst srcIndices = prim.getIndices();\n\tconst srcIndicesArray = srcIndices?.getArray();\n\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n\n\tconst stream = new VertexStream(prim);\n\tconst tableSize = ceilPowerOfTwo(srcVertexCount + srcVertexCount / 4);\n\tconst table = new Uint32Array(tableSize).fill(EMPTY_U32);\n\tconst writeMap = new Uint32Array(srcVertexCount).fill(EMPTY_U32); // oldIndex  newIndex\n\n\t// (1) Compare and identify indices to weld.\n\n\tlet dstVertexCount = 0;\n\n\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tif (writeMap[srcIndex] !== EMPTY_U32) continue;\n\n\t\tconst hashIndex = hashLookup(table, tableSize, stream, srcIndex, EMPTY_U32);\n\t\tconst dstIndex = table[hashIndex];\n\n\t\tif (dstIndex === EMPTY_U32) {\n\t\t\ttable[hashIndex] = srcIndex;\n\t\t\twriteMap[srcIndex] = dstVertexCount++;\n\t\t} else {\n\t\t\twriteMap[srcIndex] = writeMap[dstIndex];\n\t\t}\n\t}\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\tcompactPrimitive(prim, writeMap, dstVertexCount);\n}\n", "import { vec3, mat4, Accessor, Primitive, MathUtils } from '@gltf-transform/core';\nimport { create as createMat3, fromMat4, invert, transpose } from 'gl-matrix/mat3';\nimport { create as createVec3, normalize as normalizeVec3, transformMat3, transformMat4 } from 'gl-matrix/vec3';\nimport { weldPrimitive } from './weld.js';\nimport { determinant } from 'gl-matrix/mat4';\n\nconst { FLOAT } = Accessor.ComponentType;\n\n/**\n * Applies a transform matrix to a {@link Primitive}.\n *\n * All vertex attributes on the Primitive and its\n * {@link PrimitiveTarget PrimitiveTargets} are modified in place. If vertex\n * streams are shared with other Primitives, and overwriting the shared vertex\n * attributes is not desired, use {@link compactPrimitive} to pre-process\n * the Primitive or call {@link transformMesh} instead.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformPrimitive } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformPrimitive(prim, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param prim\n * @param matrix\n */\nexport function transformPrimitive(prim: Primitive, matrix: mat4): void {\n\t// Apply transform to base attributes.\n\tconst position = prim.getAttribute('POSITION');\n\tif (position) {\n\t\tapplyMatrix(matrix, position);\n\t}\n\n\tconst normal = prim.getAttribute('NORMAL');\n\tif (normal) {\n\t\tapplyNormalMatrix(matrix, normal);\n\t}\n\n\tconst tangent = prim.getAttribute('TANGENT');\n\tif (tangent) {\n\t\tapplyTangentMatrix(matrix, tangent);\n\t}\n\n\t// Apply transform to morph attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tconst position = target.getAttribute('POSITION');\n\t\tif (position) {\n\t\t\tapplyMatrix(matrix, position);\n\t\t}\n\n\t\tconst normal = target.getAttribute('NORMAL');\n\t\tif (normal) {\n\t\t\tapplyNormalMatrix(matrix, normal);\n\t\t}\n\n\t\tconst tangent = target.getAttribute('TANGENT');\n\t\tif (tangent) {\n\t\t\tapplyTangentMatrix(matrix, tangent);\n\t\t}\n\t}\n\n\t// Reverse winding order if scale is negative.\n\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/NegativeScaleTest\n\tif (determinant(matrix) < 0) {\n\t\treversePrimitiveWindingOrder(prim);\n\t}\n}\n\nfunction applyMatrix(matrix: mat4, attribute: Accessor) {\n\tconst componentType = attribute.getComponentType();\n\tconst normalized = attribute.getNormalized();\n\tconst srcArray = attribute.getArray()!;\n\tconst dstArray = componentType === FLOAT ? srcArray : new Float32Array(srcArray.length);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tvector[0] = MathUtils.decodeNormalizedInt(srcArray[i * 3], componentType);\n\t\t\tvector[1] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 1], componentType);\n\t\t\tvector[2] = MathUtils.decodeNormalizedInt(srcArray[i * 3 + 2], componentType);\n\t\t} else {\n\t\t\tvector[0] = srcArray[i * 3];\n\t\t\tvector[1] = srcArray[i * 3 + 1];\n\t\t\tvector[2] = srcArray[i * 3 + 2];\n\t\t}\n\n\t\ttransformMat4(vector, vector, matrix);\n\n\t\tdstArray[i * 3] = vector[0];\n\t\tdstArray[i * 3 + 1] = vector[1];\n\t\tdstArray[i * 3 + 2] = vector[2];\n\t}\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nfunction applyNormalMatrix(matrix: mat4, attribute: Accessor) {\n\tconst array = attribute.getArray()!;\n\tconst normalized = attribute.getNormalized();\n\tconst componentType = attribute.getComponentType();\n\n\tconst normalMatrix = createMat3();\n\tfromMat4(normalMatrix, matrix);\n\tinvert(normalMatrix, normalMatrix);\n\ttranspose(normalMatrix, normalMatrix);\n\n\tconst vector = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tvector[0] = MathUtils.decodeNormalizedInt(array[i * 3], componentType);\n\t\t\tvector[1] = MathUtils.decodeNormalizedInt(array[i * 3 + 1], componentType);\n\t\t\tvector[2] = MathUtils.decodeNormalizedInt(array[i * 3 + 2], componentType);\n\t\t} else {\n\t\t\tvector[0] = array[i * 3];\n\t\t\tvector[1] = array[i * 3 + 1];\n\t\t\tvector[2] = array[i * 3 + 2];\n\t\t}\n\n\t\ttransformMat3(vector, vector, normalMatrix);\n\t\tnormalizeVec3(vector, vector);\n\n\t\tif (normalized) {\n\t\t\tarray[i * 3] = MathUtils.decodeNormalizedInt(vector[0], componentType);\n\t\t\tarray[i * 3 + 1] = MathUtils.decodeNormalizedInt(vector[1], componentType);\n\t\t\tarray[i * 3 + 2] = MathUtils.decodeNormalizedInt(vector[2], componentType);\n\t\t} else {\n\t\t\tarray[i * 3] = vector[0];\n\t\t\tarray[i * 3 + 1] = vector[1];\n\t\t\tarray[i * 3 + 2] = vector[2];\n\t\t}\n\t}\n}\n\nfunction applyTangentMatrix(matrix: mat4, attribute: Accessor) {\n\tconst array = attribute.getArray()!;\n\tconst normalized = attribute.getNormalized();\n\tconst componentType = attribute.getComponentType();\n\n\tconst v3 = createVec3() as vec3;\n\tfor (let i = 0, il = attribute.getCount(); i < il; i++) {\n\t\tif (normalized) {\n\t\t\tv3[0] = MathUtils.decodeNormalizedInt(array[i * 4], componentType);\n\t\t\tv3[1] = MathUtils.decodeNormalizedInt(array[i * 4 + 1], componentType);\n\t\t\tv3[2] = MathUtils.decodeNormalizedInt(array[i * 4 + 2], componentType);\n\t\t} else {\n\t\t\tv3[0] = array[i * 4];\n\t\t\tv3[1] = array[i * 4 + 1];\n\t\t\tv3[2] = array[i * 4 + 2];\n\t\t}\n\n\t\t// mat4 affine matrix applied to vector, vector interpreted as a direction.\n\t\t// Reference: https://github.com/mrdoob/three.js/blob/9f4de99828c05e71c47e6de0beb4c6e7652e486a/src/math/Vector3.js#L286-L300\n\t\tv3[0] = matrix[0] * v3[0] + matrix[4] * v3[1] + matrix[8] * v3[2];\n\t\tv3[1] = matrix[1] * v3[0] + matrix[5] * v3[1] + matrix[9] * v3[2];\n\t\tv3[2] = matrix[2] * v3[0] + matrix[6] * v3[1] + matrix[10] * v3[2];\n\t\tnormalizeVec3(v3, v3);\n\n\t\tif (normalized) {\n\t\t\tarray[i * 4] = MathUtils.decodeNormalizedInt(v3[0], componentType);\n\t\t\tarray[i * 4 + 1] = MathUtils.decodeNormalizedInt(v3[1], componentType);\n\t\t\tarray[i * 4 + 2] = MathUtils.decodeNormalizedInt(v3[2], componentType);\n\t\t} else {\n\t\t\tarray[i * 4] = v3[0];\n\t\t\tarray[i * 4 + 1] = v3[1];\n\t\t\tarray[i * 4 + 2] = v3[2];\n\t\t}\n\t}\n}\n\nfunction reversePrimitiveWindingOrder(prim: Primitive) {\n\tif (prim.getMode() !== Primitive.Mode.TRIANGLES) return;\n\tif (!prim.getIndices()) weldPrimitive(prim);\n\n\tconst indices = prim.getIndices()!;\n\tfor (let i = 0, il = indices.getCount(); i < il; i += 3) {\n\t\tconst a = indices.getScalar(i);\n\t\tconst c = indices.getScalar(i + 2);\n\t\tindices.setScalar(i, c);\n\t\tindices.setScalar(i + 2, a);\n\t}\n}\n", "import { mat4, Mesh, Primitive } from '@gltf-transform/core';\nimport { transformPrimitive } from './transform-primitive.js';\nimport { compactPrimitive } from './compact-primitive.js';\n\n/**\n * Applies a transform matrix to every {@link Primitive} in the given {@link Mesh}.\n *\n * For every Primitive in the Mesh, the operation first applies\n * {@link compactPrimitive} to isolate vertex streams, then calls\n * {@link transformPrimitive}. Transformed Mesh will no longer share vertex\n * attributes with any other Meshes  attributes are cloned before\n * transformation.\n *\n * Example:\n *\n * ```javascript\n * import { fromTranslation } from 'gl-matrix/mat4';\n * import { transformMesh } from '@gltf-transform/functions';\n *\n * // offset vertices, y += 10.\n * transformMesh(mesh, fromTranslation([], [0, 10, 0]));\n * ```\n *\n * @param mesh\n * @param matrix\n */\nexport function transformMesh(mesh: Mesh, matrix: mat4): void {\n\t// If primitives or morph targets are shared by other meshes, detach them.\n\tfor (const srcPrim of mesh.listPrimitives()) {\n\t\tconst dstPrim = shallowClonePrimitive(srcPrim, mesh);\n\t\tif (srcPrim !== dstPrim) {\n\t\t\tmesh.removePrimitive(srcPrim).addPrimitive(dstPrim);\n\t\t}\n\t}\n\n\t// Isolate vertex streams, remove unused vertices, and transform.\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tcompactPrimitive(prim);\n\t\ttransformPrimitive(prim, matrix);\n\t}\n}\n\n/**\n * Conditionally clones a {@link Primitive} and its\n * {@link PrimitiveTarget PrimitiveTargets}, if any are shared with other\n * parents. If nothing is shared, nothing is cloned. Accessors and materials\n * are not cloned.\n *\n * @hidden\n * @internal\n */\nfunction shallowClonePrimitive(prim: Primitive, parentMesh: Mesh): Primitive {\n\tconst isSharedPrimitive = prim.listParents().some((parent) => parent instanceof Mesh && parent !== parentMesh);\n\tif (isSharedPrimitive) {\n\t\tprim = prim.clone();\n\t}\n\n\tfor (const target of prim.listTargets()) {\n\t\tconst isSharedTarget = target.listParents().some((parent) => parent instanceof Primitive && parent !== prim);\n\t\tif (isSharedTarget) {\n\t\t\tprim.removeTarget(target).addTarget(target.clone());\n\t\t}\n\t}\n\n\treturn prim;\n}\n", "import { mat4, MathUtils, Node } from '@gltf-transform/core';\nimport { multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { transformMesh } from './transform-mesh.js';\n\n// prettier-ignore\nconst IDENTITY: mat4 = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1\n];\n\n/**\n * Clears local transform of the {@link Node}, applying the transform to children and meshes.\n *\n * - Applies transform to children\n * - Applies transform to {@link Mesh mesh}\n * - Resets {@link Light lights}, {@link Camera cameras}, and other attachments to the origin\n *\n * Example:\n *\n * ```typescript\n * import { clearNodeTransform } from '@gltf-transform/functions';\n *\n * node.getTranslation(); //  [ 5, 0, 0 ]\n * node.getMesh(); //  vertex data centered at origin\n *\n * clearNodeTransform(node);\n *\n * node.getTranslation(); //  [ 0, 0, 0 ]\n * node.getMesh(); //  vertex data centered at [ 5, 0, 0 ]\n * ```\n *\n * To clear _all_ transforms of a Node, first clear its inherited transforms with\n * {@link clearNodeParent}, then clear the local transform with {@link clearNodeTransform}.\n */\nexport function clearNodeTransform(node: Node): Node {\n\tconst mesh = node.getMesh();\n\tconst localMatrix = node.getMatrix();\n\n\tif (mesh && !MathUtils.eq(localMatrix, IDENTITY)) {\n\t\ttransformMesh(mesh, localMatrix);\n\t}\n\n\tfor (const child of node.listChildren()) {\n\t\tconst matrix = child.getMatrix();\n\t\tmultiplyMat4(matrix, matrix, localMatrix);\n\t\tchild.setMatrix(matrix);\n\t}\n\n\treturn node.setMatrix(IDENTITY);\n}\n", "import { ComponentTypeToTypedArray, Document, Primitive } from '@gltf-transform/core';\nimport { getGLPrimitiveCount, shallowCloneAccessor } from './utils.js';\nimport { weldPrimitive } from './weld.js';\n\nconst { LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Converts a LINE_STRIP or LINE_LOOP {@link Primitive} to LINES, which is\n * more widely supported. Any other topology given as input (points or\n * triangles) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToLines } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 2 (LINE_LOOP)\n * convertPrimitiveToLines(prim);\n * console.log(prim.getMode()); // 1 (LINES)\n * ```\n */\nexport function convertPrimitiveToLines(prim: Primitive): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\n\t// Ensure indexed primitive.\n\tif (!prim.getIndices()) {\n\t\tweldPrimitive(prim);\n\t}\n\n\t// Allocate indices new GL primitives.\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcIndicesArray = srcIndices.getArray()!;\n\tconst dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n\tconst IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n\tconst dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 2);\n\n\t// Generate GL primitives.\n\tconst srcMode = prim.getMode();\n\tif (srcMode === LINE_STRIP) {\n\t\t// https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n\t\t}\n\t} else if (srcMode === LINE_LOOP) {\n\t\t// https://glasnost.itcarlow.ie/~powerk/opengl/primitives/primitives.htm\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tif (i < dstGLPrimitiveCount - 1) {\n\t\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[i + 1];\n\t\t\t} else {\n\t\t\t\tdstIndicesArray[i * 2] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 2 + 1] = srcIndicesArray[0];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthrow new Error('Only LINE_STRIP and LINE_LOOP may be converted to LINES.');\n\t}\n\n\t// Update prim mode and indices.\n\tprim.setMode(LINES);\n\tconst root = document.getRoot();\n\tif (srcIndices.listParents().some((parent) => parent !== root && parent !== prim)) {\n\t\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\t} else {\n\t\tsrcIndices.setArray(dstIndicesArray);\n\t}\n}\n\n/**\n * Converts a TRIANGLE_STRIP or TRIANGLE_LOOP {@link Primitive} to TRIANGLES,\n * which is more widely supported. Any other topology given as input (points or\n * lines) will throw an error.\n *\n * Example:\n *\n * ```javascript\n * import { convertPrimitiveToTriangles } from '@gltf-transform/functions';\n *\n * console.log(prim.getMode()); // 5 (TRIANGLE_STRIP)\n * convertPrimitiveToTriangles(prim);\n * console.log(prim.getMode()); // 4 (TRIANGLES)\n * ```\n */\nexport function convertPrimitiveToTriangles(prim: Primitive): void {\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\n\t// Ensure indexed primitive.\n\tif (!prim.getIndices()) {\n\t\tweldPrimitive(prim);\n\t}\n\n\t// Allocate indices new GL primitives.\n\tconst srcIndices = prim.getIndices()!;\n\tconst srcIndicesArray = srcIndices.getArray()!;\n\tconst dstGLPrimitiveCount = getGLPrimitiveCount(prim);\n\tconst IndicesArray = ComponentTypeToTypedArray[srcIndices.getComponentType()];\n\tconst dstIndicesArray = new IndicesArray(dstGLPrimitiveCount * 3);\n\n\t// Generate GL primitives.\n\tconst srcMode = prim.getMode();\n\tif (srcMode === TRIANGLE_STRIP) {\n\t\t// https://en.wikipedia.org/wiki/Triangle_strip\n\t\tfor (let i = 0, il = srcIndicesArray.length; i < il - 2; i++) {\n\t\t\tif (i % 2) {\n\t\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[i + 1];\n\t\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t\t} else {\n\t\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[i];\n\t\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n\t\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t\t}\n\t\t}\n\t} else if (srcMode === TRIANGLE_FAN) {\n\t\t// https://en.wikipedia.org/wiki/Triangle_fan\n\t\tfor (let i = 0; i < dstGLPrimitiveCount; i++) {\n\t\t\tdstIndicesArray[i * 3] = srcIndicesArray[0];\n\t\t\tdstIndicesArray[i * 3 + 1] = srcIndicesArray[i + 1];\n\t\t\tdstIndicesArray[i * 3 + 2] = srcIndicesArray[i + 2];\n\t\t}\n\t} else {\n\t\tthrow new Error('Only TRIANGLE_STRIP and TRIANGLE_FAN may be converted to TRIANGLES.');\n\t}\n\n\t// Update prim mode and indices.\n\tprim.setMode(TRIANGLES);\n\tconst root = document.getRoot();\n\tif (srcIndices.listParents().some((parent) => parent !== root && parent !== prim)) {\n\t\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\t} else {\n\t\tsrcIndices.setArray(dstIndicesArray);\n\t}\n}\n", "import {\n\tMathUtils,\n\ttype Accessor,\n\ttype Document,\n\ttype GLTF,\n\ttype Primitive,\n\ttype Transform,\n\tTypedArray,\n} from '@gltf-transform/core';\nimport { KHRMeshQuantization } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'dequantize';\n\n/** Options for the {@link dequantize} function. */\nexport interface DequantizeOptions {\n\t/**\n\t * Pattern (regex) used to filter vertex attribute semantics for quantization.\n\t * Default: `/^((?!JOINTS_).)*$/`.\n\t */\n\tpattern?: RegExp;\n}\n\nconst DEQUANTIZE_DEFAULTS: Required<DequantizeOptions> = {\n\tpattern: /^((?!JOINTS_).)*$/,\n};\n\n/**\n * Dequantize {@link Primitive Primitives}, removing {@link KHRMeshQuantization `KHR_mesh_quantization`}\n * if present. Dequantization will increase the size of the mesh on disk and in memory, but may be\n * necessary for compatibility with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * await document.transform(dequantize());\n * ```\n *\n * @category Transforms\n */\nexport function dequantize(_options: DequantizeOptions = DEQUANTIZE_DEFAULTS): Transform {\n\tconst options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tdequantizePrimitive(prim, options);\n\t\t\t}\n\t\t}\n\t\tdoc.createExtension(KHRMeshQuantization).dispose();\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Dequantize a single {@link Primitive}, converting all vertex attributes to float32. Dequantization\n * will increase the size of the mesh on disk and in memory, but may be necessary for compatibility\n * with applications that don't support quantization.\n *\n * Example:\n *\n * ```javascript\n * import { dequantizePrimitive } from '@gltf-transform/functions';\n *\n * const mesh = document.getRoot().listMeshes().find((mesh) => mesh.getName() === 'MyMesh');\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tdequantizePrimitive(prim);\n * }\n * ```\n */\nexport function dequantizePrimitive(prim: Primitive, _options = DEQUANTIZE_DEFAULTS): void {\n\tconst options = assignDefaults(DEQUANTIZE_DEFAULTS, _options);\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (options.pattern.test(semantic)) {\n\t\t\tdequantizeAttribute(prim.getAttribute(semantic)!);\n\t\t}\n\t}\n\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const semantic of target.listSemantics()) {\n\t\t\tif (options.pattern.test(semantic)) {\n\t\t\t\tdequantizeAttribute(target.getAttribute(semantic)!);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function dequantizeAttribute(attribute: Accessor): void {\n\tconst srcArray = attribute.getArray();\n\tif (!srcArray) return;\n\n\tconst dstArray = dequantizeAttributeArray(srcArray, attribute.getComponentType(), attribute.getNormalized());\n\n\tattribute.setArray(dstArray).setNormalized(false);\n}\n\nexport function dequantizeAttributeArray(\n\tsrcArray: TypedArray,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): Float32Array {\n\tconst dstArray = new Float32Array(srcArray.length);\n\n\tfor (let i = 0, il = srcArray.length; i < il; i++) {\n\t\tif (normalized) {\n\t\t\tdstArray[i] = MathUtils.decodeNormalizedInt(srcArray[i], componentType);\n\t\t} else {\n\t\t\tdstArray[i] = srcArray[i];\n\t\t}\n\t}\n\n\treturn dstArray;\n}\n", "import { Document, Extension, Graph, Property, PropertyResolver, PropertyType } from '@gltf-transform/core';\n\nconst { TEXTURE_INFO, ROOT } = PropertyType;\ntype PropertyConstructor = new (g: Graph<Property>) => Property;\n\nconst NO_TRANSFER_TYPES = new Set<string>([TEXTURE_INFO, ROOT]);\n\n/**\n * Clones source {@link Document}, copying all properties and extensions within\n * it. Source document remains unchanged, and the two may be modified\n * independently after cloning.\n *\n * Example:\n *\n * ```javascript\n *\timport { cloneDocument } from '@gltf-transform/functions';\n *\n *\tconst targetDocument = cloneDocument(sourceDocument);\n * ```\n */\nexport function cloneDocument(source: Document): Document {\n\tconst target = new Document().setLogger(source.getLogger());\n\tconst resolve = createDefaultPropertyResolver(target, source);\n\tmergeDocuments(target, source, resolve);\n\n\t// Root properties (name, asset, default scene, extras) are not overwritten by\n\t// mergeDocuments(), and should be explicitly copied when cloning.\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\ttarget.getRoot().copy(source.getRoot(), resolve as any);\n\n\treturn target;\n}\n\n/**\n * Merges contents of source {@link Document} into target Document, without\n * modifying the source. Any extensions missing from the target will be added\n * {@link Scene Scenes} and {@link Buffer Buffers} are not combined \n * the target Document may contain multiple Scenes and Buffers after this\n * operation. These may be cleaned up manually (see {@link unpartition}),\n * or document contents may be merged more granularly using\n * {@link copyToDocument}.\n *\n * Example:\n *\n * ```javascript\n *\timport { mergeDocuments, unpartition } from '@gltf-transform/functions';\n *\n *\t// Merge contents of sourceDocument into targetDocument.\n *\tmergeDocuments(targetDocument, sourceDocument);\n *\n *\t// (Optional) Remove all but one Buffer from the target Document.\n *\tawait targetDocument.transform(unpartition());\n * ```\n *\n * To merge several Scenes into one:\n *\n * ```javascript\n * import { mergeDocuments } from '@gltf-transform/functions';\n *\n * const map = mergeDocuments(targetDocument, sourceDocument);\n *\n * // Find original Scene.\n * const sceneA = targetDocument.getRoot().listScenes()[0];\n *\n * // Find counterpart of the source Scene in the target Document.\n * const sceneB = map.get(sourceDocument.getRoot().listScenes()[0]);\n *\n * // Create a Node, and append source Scene's direct children.\n * const rootNode = targetDocument.createNode()\n *\t\t.setName('SceneB')\n *\t\t.setPosition([10, 0, 0]);\n * for (const node of sceneB.listChildren()) {\n *\t\trootNode.addChild(node);\n * }\n *\n * // Append Node to original Scene, and dispose the empty Scene.\n * sceneA.addChild(rootNode);\n * sceneB.dispose();\n * ```\n */\nexport function mergeDocuments(\n\ttarget: Document,\n\tsource: Document,\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tresolve ||= createDefaultPropertyResolver(target, source);\n\n\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n\t\tconst targetExtension = target.createExtension(sourceExtension.constructor as new (doc: Document) => Extension);\n\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n\t}\n\n\t// Root properties (name, asset, default scene, extras) are not overwritten.\n\treturn _copyToDocument(target, source, listNonRootProperties(source), resolve);\n}\n\n/**\n * Moves the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, and removes them from the source.\n * Dependencies of the source properties will be copied into the\n * target, but not removed from the source. Returns a Map from source\n * properties to their counterparts in the target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { moveToDocument, prune } from '@gltf-transform/functions';\n *\n *\t// Move all materials from sourceDocument to targetDocument.\n *\tconst map = moveToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n *\n *\t// (Optional) Remove any resources (like Textures) that may now be unused\n *\t// in the source Document after their parent Materials have been moved.\n *\tawait sourceDocument.transform(prune());\n * ```\n *\n * Moving a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after moving properties.\n *\n * Repeated use of `moveToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `moveToDocument`:\n *\n * ```javascript\n *\timport { moveToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Move materials individually, without creating duplicates of shared textures.\n *\tmoveToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tmoveToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be moved.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when moving a {@link Material}.\n *\n * To copy properties without removing them from the source Document, see\n * {@link copyToDocument}.\n *\n * @experimental\n */\nexport function moveToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tconst targetProperties = copyToDocument(target, source, sourceProperties, resolve);\n\n\tfor (const property of sourceProperties) {\n\t\tproperty.dispose();\n\t}\n\n\treturn targetProperties;\n}\n\n/**\n * Copies the specified {@link Property Properties} from the source\n * {@link Document} to the target Document, leaving originals in the source.\n * Dependencies of the source properties will also be copied into the\n * target. Returns a Map from source properties to their counterparts in the\n * target Document.\n *\n * Example:\n *\n * ```javascript\n *\timport { copyToDocument } from '@gltf-transform/functions';\n *\n *\t// Copy all materials from sourceDocument to targetDocument.\n *\tconst map = copyToDocument(targetDocument, sourceDocument, sourceDocument.listMaterials());\n *\n *\t// Find the new counterpart of `sourceMaterial` in the target Document.\n *\tconst targetMaterial = map.get(sourceMaterial);\n * ```\n *\n * Copying a {@link Mesh}, {@link Animation}, or another resource depending on\n * a {@link Buffer} will create a copy of the source Buffer in the target\n * Document. If the target Document should contain only one Buffer, call\n * {@link unpartition} after copying properties.\n *\n * Repeated use of `copyToDocument` may create multiple copies of some\n * resources, particularly shared dependencies like {@link Texture Textures} or\n * {@link Accessor Accessors}. While duplicates can be cleaned up with\n * {@link dedup}, it is also possible to prevent duplicates by creating and\n * reusing the same resolver for all calls to `copyToDocument`:\n *\n * ```javascript\n *\timport { copyToDocument, createDefaultPropertyResolver } from '@gltf-transform/functions';\n *\n *\tconst resolve = createDefaultPropertyResolver(targetDocument, sourceDocument);\n *\n *\t// Copy materials individually, without creating duplicates of shared textures.\n *\tcopyToDocument(targetDocument, sourceDocument, materialA, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialB, resolve);\n *\tcopyToDocument(targetDocument, sourceDocument, materialC, resolve);\n * ```\n *\n * If the transferred properties include {@link ExtensionProperty ExtensionProperties},\n * the associated {@link Extension Extensions} must be added to the target\n * Document first:\n *\n * ```javascript\n *\tfor (const sourceExtension of source.getRoot().listExtensionsUsed()) {\n *\t\tconst targetExtension = target.createExtension(sourceExtension.constructor);\n *\t\tif (sourceExtension.isRequired()) targetExtension.setRequired(true);\n *\t}\n * ```\n *\n * {@link Root} properties cannot be copied.\n *\n * {@link TextureInfo} properties cannot be given in the property list, but\n * are handled automatically when copying a {@link Material}.\n *\n * To move properties to the target Document without leaving copies behind in\n * the source Document, use {@link moveToDocument} or dispose the properties\n * after copying.\n *\n * @experimental\n */\nexport function copyToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tconst sourcePropertyDependencies = new Set<Property>();\n\tfor (const property of sourceProperties) {\n\t\tif (NO_TRANSFER_TYPES.has(property.propertyType)) {\n\t\t\tthrow new Error(`Type \"${property.propertyType}\" cannot be transferred.`);\n\t\t}\n\t\tlistPropertyDependencies(property, sourcePropertyDependencies);\n\t}\n\treturn _copyToDocument(target, source, Array.from(sourcePropertyDependencies), resolve);\n}\n\n/** @internal */\nfunction _copyToDocument(\n\ttarget: Document,\n\tsource: Document,\n\tsourceProperties: Property[],\n\tresolve?: PropertyResolver<Property>,\n): Map<Property, Property> {\n\tresolve ||= createDefaultPropertyResolver(target, source);\n\n\t// Create stub classes for every Property in other Document.\n\tconst propertyMap = new Map<Property, Property>();\n\tfor (const sourceProp of sourceProperties) {\n\t\t// TextureInfo copy handled by Material or ExtensionProperty.\n\t\tif (!propertyMap.has(sourceProp) && sourceProp.propertyType !== TEXTURE_INFO) {\n\t\t\tpropertyMap.set(sourceProp, resolve(sourceProp));\n\t\t}\n\t}\n\n\t// Assemble relationships between Properties.\n\tfor (const [sourceProp, targetProp] of propertyMap.entries()) {\n\t\ttargetProp.copy(sourceProp, resolve);\n\t}\n\n\treturn propertyMap;\n}\n\n/**\n * Creates a default `resolve` implementation. May be used when moving\n * properties between {@link Document Documents} with {@link mergeDocuments},\n * {@link copyToDocument}, and {@link moveToDocument}. When the same resolver\n * is passed to multiple invocations, these functions will reuse previously-\n * transferred resources.\n *\n * @experimental\n */\nexport function createDefaultPropertyResolver(target: Document, source: Document): PropertyResolver<Property> {\n\tconst propertyMap = new Map<Property, Property>([[source.getRoot(), target.getRoot()]]);\n\n\treturn (sourceProp: Property): Property => {\n\t\t// TextureInfo lifecycle is bound to a Material or ExtensionProperty.\n\t\tif (sourceProp.propertyType === TEXTURE_INFO) return sourceProp;\n\n\t\tlet targetProp = propertyMap.get(sourceProp);\n\t\tif (!targetProp) {\n\t\t\t// Create stub class, defer copying properties.\n\t\t\tconst PropertyClass = sourceProp.constructor as PropertyConstructor;\n\t\t\ttargetProp = new PropertyClass(target.getGraph());\n\t\t\tpropertyMap.set(sourceProp, targetProp);\n\t\t}\n\n\t\treturn targetProp;\n\t};\n}\n\n/** @internal */\nfunction listPropertyDependencies(parent: Property, visited: Set<Property>): Set<Property> {\n\tconst graph = parent.getGraph();\n\tconst queue: Property[] = [parent];\n\n\tlet next: Property | undefined = undefined;\n\twhile ((next = queue.pop())) {\n\t\tvisited.add(next);\n\t\tfor (const child of graph.listChildren(next)) {\n\t\t\tif (!visited.has(child)) {\n\t\t\t\tqueue.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn visited;\n}\n\n/** @internal */\nfunction listNonRootProperties(document: Document): Property[] {\n\tconst visited = new Set<Property>();\n\tfor (const edge of document.getGraph().listEdges()) {\n\t\tvisited.add(edge.getChild());\n\t}\n\treturn Array.from(visited);\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRDracoMeshCompression } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { weld } from './weld.js';\n\nconst NAME = 'draco';\n\nexport interface DracoOptions {\n\tmethod?: 'edgebreaker' | 'sequential';\n\tencodeSpeed?: number;\n\tdecodeSpeed?: number;\n\tquantizePosition?: number;\n\tquantizeNormal?: number;\n\tquantizeColor?: number;\n\tquantizeTexcoord?: number;\n\tquantizeGeneric?: number;\n\tquantizationVolume?: 'mesh' | 'scene';\n}\n\nexport const DRACO_DEFAULTS: Required<DracoOptions> = {\n\tmethod: 'edgebreaker',\n\tencodeSpeed: 5,\n\tdecodeSpeed: 5,\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeColor: 8,\n\tquantizeTexcoord: 12,\n\tquantizeGeneric: 12,\n\tquantizationVolume: 'mesh',\n};\n\n/**\n * Applies Draco compression using {@link KHRDracoMeshCompression KHR_draco_mesh_compression}.\n * This type of compression can reduce the size of triangle geometry.\n *\n * This function is a thin wrapper around the {@link KHRDracoMeshCompression} extension itself.\n *\n * @category Transforms\n */\nexport function draco(_options: DracoOptions = DRACO_DEFAULTS): Transform {\n\tconst options = assignDefaults(DRACO_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tawait document.transform(weld());\n\t\tdocument\n\t\t\t.createExtension(KHRDracoMeshCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.method === 'edgebreaker'\n\t\t\t\t\t\t? KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER\n\t\t\t\t\t\t: KHRDracoMeshCompression.EncoderMethod.SEQUENTIAL,\n\t\t\t\tencodeSpeed: options.encodeSpeed,\n\t\t\t\tdecodeSpeed: options.decodeSpeed,\n\t\t\t\tquantizationBits: {\n\t\t\t\t\tPOSITION: options.quantizePosition,\n\t\t\t\t\tNORMAL: options.quantizeNormal,\n\t\t\t\t\tCOLOR: options.quantizeColor,\n\t\t\t\t\tTEX_COORD: options.quantizeTexcoord,\n\t\t\t\t\tGENERIC: options.quantizeGeneric,\n\t\t\t\t},\n\t\t\t\tquantizationVolume: options.quantizationVolume,\n\t\t\t});\n\t});\n}\n", "import { Document, Node, PropertyType, Transform } from '@gltf-transform/core';\nimport { clearNodeParent } from './clear-node-parent.js';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'flatten';\n\n/** Options for the {@link flatten} function. */\nexport interface FlattenOptions {\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const FLATTEN_DEFAULTS: Required<FlattenOptions> = {\n\tcleanup: true,\n};\n\n/**\n * Flattens the scene graph, leaving {@link Node Nodes} with\n * {@link Mesh Meshes}, {@link Camera Cameras}, and other attachments\n * as direct children of the {@link Scene}. Skeletons and their\n * descendants are left in their original Node structure.\n *\n * {@link Animation} targeting a Node or its parents will\n * prevent that Node from being moved.\n *\n * Example:\n *\n * ```ts\n * import { flatten } from '@gltf-transform/functions';\n *\n * await document.transform(flatten());\n * ```\n *\n * @category Transforms\n */\nexport function flatten(_options: FlattenOptions = FLATTEN_DEFAULTS): Transform {\n\tconst options = assignDefaults(FLATTEN_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// (1) Mark joints.\n\t\tconst joints = new Set<Node>();\n\t\tfor (const skin of root.listSkins()) {\n\t\t\tfor (const joint of skin.listJoints()) {\n\t\t\t\tjoints.add(joint);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Mark nodes with TRS animation.\n\t\tconst animated = new Set<Node>();\n\t\tfor (const animation of root.listAnimations()) {\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tconst node = channel.getTargetNode();\n\t\t\t\tif (node && channel.getTargetPath() !== 'weights') {\n\t\t\t\t\tanimated.add(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Mark descendants of joints and animated nodes.\n\t\tconst hasJointParent = new Set<Node>();\n\t\tconst hasAnimatedParent = new Set<Node>();\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst parent = node.getParentNode();\n\t\t\t\tif (!parent) return;\n\t\t\t\tif (joints.has(parent) || hasJointParent.has(parent)) {\n\t\t\t\t\thasJointParent.add(node);\n\t\t\t\t}\n\t\t\t\tif (animated.has(parent) || hasAnimatedParent.has(parent)) {\n\t\t\t\t\thasAnimatedParent.add(node);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// (4) For each affected node, in top-down order, clear parents.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\tscene.traverse((node) => {\n\t\t\t\tif (animated.has(node)) return;\n\t\t\t\tif (hasJointParent.has(node)) return;\n\t\t\t\tif (hasAnimatedParent.has(node)) return;\n\n\t\t\t\tclearNodeParent(node);\n\t\t\t});\n\t\t}\n\n\t\t// TODO(feat): Transform animation channels, accounting for previously inherited transforms.\n\t\tif (animated.size) {\n\t\t\tlogger.debug(`${NAME}: Flattening node hierarchies with TRS animation not yet supported.`);\n\t\t}\n\n\t\t// (5) Clean up leaf nodes.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(prune({ propertyTypes: [PropertyType.NODE], keepLeaves: false }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { Scene, Node, getBounds as _getBounds, bbox } from '@gltf-transform/core';\n\n/**\n * Computes bounding box (AABB) in world space for the given {@link Node} or {@link Scene}.\n *\n * Example:\n *\n * ```ts\n * import { getBounds } from '@gltf-transform/functions';\n *\n * const {min, max} = getBounds(scene);\n * ```\n */\nexport function getBounds(node: Node | Scene): bbox {\n\treturn _getBounds(node);\n}\n", "import {\n\tAccessor,\n\tDocument,\n\tExtensionProperty,\n\tGLTF,\n\tImageUtils,\n\tTexture,\n\tgetBounds,\n\tPropertyType,\n} from '@gltf-transform/core';\nimport { getGLPrimitiveCount } from './utils.js';\nimport { KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, read as readKTX } from 'ktx-parse';\nimport { VertexCountMethod, getMeshVertexCount, getSceneVertexCount } from './get-vertex-count.js';\n\n/** Inspects the contents of a glTF file and returns a JSON report. */\nexport function inspect(doc: Document): InspectReport {\n\treturn {\n\t\tscenes: listScenes(doc),\n\t\tmeshes: listMeshes(doc),\n\t\tmaterials: listMaterials(doc),\n\t\ttextures: listTextures(doc),\n\t\tanimations: listAnimations(doc),\n\t};\n}\n\n/** List scenes. */\nfunction listScenes(doc: Document): InspectPropertyReport<InspectSceneReport> {\n\tconst scenes = doc\n\t\t.getRoot()\n\t\t.listScenes()\n\t\t.map((scene) => {\n\t\t\tconst root = scene.listChildren()[0];\n\t\t\tconst sceneBounds = getBounds(scene);\n\t\t\treturn {\n\t\t\t\tname: scene.getName(),\n\t\t\t\trootName: root ? root.getName() : '',\n\t\t\t\tbboxMin: toPrecision(sceneBounds.min),\n\t\t\t\tbboxMax: toPrecision(sceneBounds.max),\n\t\t\t\trenderVertexCount: getSceneVertexCount(scene, VertexCountMethod.RENDER),\n\t\t\t\tuploadVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD),\n\t\t\t\tuploadNaiveVertexCount: getSceneVertexCount(scene, VertexCountMethod.UPLOAD_NAIVE),\n\t\t\t};\n\t\t});\n\treturn { properties: scenes };\n}\n\n/** List meshes. */\nfunction listMeshes(doc: Document): InspectPropertyReport<InspectMeshReport> {\n\tconst meshes: InspectMeshReport[] = doc\n\t\t.getRoot()\n\t\t.listMeshes()\n\t\t.map((mesh) => {\n\t\t\tconst instances = mesh.listParents().filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\t\t\tlet glPrimitives = 0;\n\t\t\tconst semantics = new Set<string>();\n\t\t\tconst meshIndices = new Set<string>();\n\t\t\tconst meshAccessors: Set<Accessor> = new Set();\n\n\t\t\tmesh.listPrimitives().forEach((prim) => {\n\t\t\t\tfor (const semantic of prim.listSemantics()) {\n\t\t\t\t\tconst attr = prim.getAttribute(semantic)!;\n\t\t\t\t\tsemantics.add(semantic + ':' + accessorToTypeLabel(attr));\n\t\t\t\t\tmeshAccessors.add(attr);\n\t\t\t\t}\n\t\t\t\tfor (const targ of prim.listTargets()) {\n\t\t\t\t\ttarg.listAttributes().forEach((attr) => meshAccessors.add(attr));\n\t\t\t\t}\n\t\t\t\tconst indices = prim.getIndices();\n\t\t\t\tif (indices) {\n\t\t\t\t\tmeshIndices.add(accessorToTypeLabel(indices));\n\t\t\t\t\tmeshAccessors.add(indices);\n\t\t\t\t}\n\t\t\t\tglPrimitives += getGLPrimitiveCount(prim);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tArray.from(meshAccessors).forEach((a) => (size += a.getArray()!.byteLength));\n\n\t\t\tconst modes = mesh.listPrimitives().map((prim) => MeshPrimitiveModeLabels[prim.getMode()]);\n\n\t\t\treturn {\n\t\t\t\tname: mesh.getName(),\n\t\t\t\tmode: Array.from(new Set(modes)),\n\t\t\t\tmeshPrimitives: mesh.listPrimitives().length,\n\t\t\t\tglPrimitives: glPrimitives,\n\t\t\t\tvertices: getMeshVertexCount(mesh, VertexCountMethod.UPLOAD),\n\t\t\t\tindices: Array.from(meshIndices).sort(),\n\t\t\t\tattributes: Array.from(semantics).sort(),\n\t\t\t\tinstances: instances,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: meshes };\n}\n\n/** List materials. */\nfunction listMaterials(doc: Document): InspectPropertyReport<InspectMaterialReport> {\n\tconst materials: InspectMaterialReport[] = doc\n\t\t.getRoot()\n\t\t.listMaterials()\n\t\t.map((material) => {\n\t\t\tconst instances = material\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\t// Find all texture slots attached to this material or its extensions.\n\t\t\tconst extensions = new Set<ExtensionProperty>(material.listExtensions());\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listEdges()\n\t\t\t\t.filter((ref) => {\n\t\t\t\t\tconst child = ref.getChild();\n\t\t\t\t\tconst parent = ref.getParent();\n\t\t\t\t\tif (child instanceof Texture && parent === material) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (child instanceof Texture && parent instanceof ExtensionProperty && extensions.has(parent)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map((ref) => ref.getName());\n\n\t\t\treturn {\n\t\t\t\tname: material.getName(),\n\t\t\t\tinstances,\n\t\t\t\ttextures: slots,\n\t\t\t\talphaMode: material.getAlphaMode(),\n\t\t\t\tdoubleSided: material.getDoubleSided(),\n\t\t\t};\n\t\t});\n\n\treturn { properties: materials };\n}\n\n/** List textures. */\nfunction listTextures(doc: Document): InspectPropertyReport<InspectTextureReport> {\n\tconst textures: InspectTextureReport[] = doc\n\t\t.getRoot()\n\t\t.listTextures()\n\t\t.map((texture) => {\n\t\t\tconst instances = texture\n\t\t\t\t.listParents()\n\t\t\t\t.filter((parent) => parent.propertyType !== PropertyType.ROOT).length;\n\n\t\t\tconst slots = doc\n\t\t\t\t.getGraph()\n\t\t\t\t.listParentEdges(texture)\n\t\t\t\t.filter((edge) => edge.getParent().propertyType !== PropertyType.ROOT)\n\t\t\t\t.map((edge) => edge.getName());\n\n\t\t\tconst resolution = ImageUtils.getSize(texture.getImage()!, texture.getMimeType());\n\n\t\t\tlet compression = '';\n\t\t\tif (texture.getMimeType() === 'image/ktx2') {\n\t\t\t\tconst container = readKTX(texture.getImage()!);\n\t\t\t\tconst dfd = container.dataFormatDescriptor[0];\n\t\t\t\tif (dfd.colorModel === KHR_DF_MODEL_ETC1S) {\n\t\t\t\t\tcompression = 'ETC1S';\n\t\t\t\t} else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {\n\t\t\t\t\tcompression = 'UASTC';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname: texture.getName(),\n\t\t\t\turi: texture.getURI(),\n\t\t\t\tslots: Array.from(new Set(slots)),\n\t\t\t\tinstances,\n\t\t\t\tmimeType: texture.getMimeType(),\n\t\t\t\tcompression,\n\t\t\t\tresolution: resolution ? resolution.join('x') : '',\n\t\t\t\tsize: texture.getImage()!.byteLength,\n\t\t\t\tgpuSize: ImageUtils.getVRAMByteLength(texture.getImage()!, texture.getMimeType()),\n\t\t\t};\n\t\t});\n\n\treturn { properties: textures };\n}\n\n/** List animations. */\nfunction listAnimations(doc: Document): InspectPropertyReport<InspectAnimationReport> {\n\tconst animations: InspectAnimationReport[] = doc\n\t\t.getRoot()\n\t\t.listAnimations()\n\t\t.map((anim) => {\n\t\t\tlet minTime = Infinity;\n\t\t\tlet maxTime = -Infinity;\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tif (!input) return;\n\t\t\t\tminTime = Math.min(minTime, input.getMin([])[0]);\n\t\t\t\tmaxTime = Math.max(maxTime, input.getMax([])[0]);\n\t\t\t});\n\n\t\t\tlet size = 0;\n\t\t\tlet keyframes = 0;\n\t\t\tconst accessors: Set<Accessor> = new Set();\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (!input) return;\n\t\t\t\tkeyframes += input.getCount();\n\t\t\t\taccessors.add(input);\n\t\t\t\tif (!output) return;\n\t\t\t\taccessors.add(output);\n\t\t\t});\n\t\t\tArray.from(accessors).forEach((accessor) => {\n\t\t\t\tsize += accessor.getArray()!.byteLength;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: anim.getName(),\n\t\t\t\tchannels: anim.listChannels().length,\n\t\t\t\tsamplers: anim.listSamplers().length,\n\t\t\t\tduration: Math.round((maxTime - minTime) * 1000) / 1000,\n\t\t\t\tkeyframes: keyframes,\n\t\t\t\tsize: size,\n\t\t\t};\n\t\t});\n\n\treturn { properties: animations };\n}\n\nexport interface InspectReport {\n\tscenes: InspectPropertyReport<InspectSceneReport>;\n\tmeshes: InspectPropertyReport<InspectMeshReport>;\n\tmaterials: InspectPropertyReport<InspectMaterialReport>;\n\ttextures: InspectPropertyReport<InspectTextureReport>;\n\tanimations: InspectPropertyReport<InspectAnimationReport>;\n}\n\nexport interface InspectPropertyReport<T> {\n\tproperties: T[];\n\terrors?: string[];\n\twarnings?: string[];\n}\n\nexport interface InspectSceneReport {\n\tname: string;\n\trootName: string;\n\tbboxMin: number[];\n\tbboxMax: number[];\n\trenderVertexCount: number;\n\tuploadVertexCount: number;\n\tuploadNaiveVertexCount: number;\n}\n\nexport interface InspectMeshReport {\n\tname: string;\n\tmeshPrimitives: number;\n\tmode: string[];\n\tvertices: number;\n\tglPrimitives: number;\n\tindices: string[];\n\tattributes: string[];\n\tinstances: number;\n\tsize: number;\n}\n\nexport interface InspectMaterialReport {\n\tname: string;\n\tinstances: number;\n\ttextures: string[];\n\talphaMode: GLTF.MaterialAlphaMode;\n\tdoubleSided: boolean;\n}\n\nexport interface InspectTextureReport {\n\tname: string;\n\turi: string;\n\tslots: string[];\n\tinstances: number;\n\tmimeType: string;\n\tresolution: string;\n\tcompression: string;\n\tsize: number;\n\tgpuSize: number | null;\n}\n\nexport interface InspectAnimationReport {\n\tname: string;\n\tchannels: number;\n\tsamplers: number;\n\tkeyframes: number;\n\tduration: number;\n\tsize: number;\n}\n\nconst MeshPrimitiveModeLabels = [\n\t'POINTS',\n\t'LINES',\n\t'LINE_LOOP',\n\t'LINE_STRIP',\n\t'TRIANGLES',\n\t'TRIANGLE_STRIP',\n\t'TRIANGLE_FAN',\n];\n\nconst NumericTypeLabels: Record<string, string> = {\n\tFloat32Array: 'f32',\n\tUint32Array: 'u32',\n\tUint16Array: 'u16',\n\tUint8Array: 'u8',\n\tInt32Array: 'i32',\n\tInt16Array: 'i16',\n\tInt8Array: 'i8',\n};\n\n/** Maps values in a vector to a finite precision. */\nfunction toPrecision(v: number[]): number[] {\n\tfor (let i = 0; i < v.length; i++) {\n\t\tif ((v[i] as number).toFixed) v[i] = Number(v[i].toFixed(5));\n\t}\n\treturn v;\n}\n\nfunction accessorToTypeLabel(accessor: Accessor): string {\n\tconst array = accessor.getArray()!;\n\tconst base = NumericTypeLabels[array.constructor.name] || '?';\n\tconst suffix = accessor.getNormalized() ? '_norm' : '';\n\treturn base + suffix;\n}\n", "import { Document, ILogger, MathUtils, Mesh, Node, Primitive, Transform, vec3, vec4 } from '@gltf-transform/core';\nimport { InstancedMesh, EXTMeshGPUInstancing } from '@gltf-transform/extensions';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'instance';\n\nexport interface InstanceOptions {\n\t/** Minimum number of meshes considered eligible for instancing. Default: 5. */\n\tmin?: number;\n}\n\nexport const INSTANCE_DEFAULTS: Required<InstanceOptions> = {\n\tmin: 5,\n};\n\n/**\n * Creates GPU instances (with `EXT_mesh_gpu_instancing`) for shared {@link Mesh} references. In\n * engines supporting the extension, reused Meshes will be drawn with GPU instancing, greatly\n * reducing draw calls and improving performance in many cases. If you're not sure that identical\n * Meshes share vertex data and materials (\"linked duplicates\"), run {@link dedup} first to link them.\n *\n * Example:\n *\n * ```javascript\n * import { dedup, instance } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup(),\n * \tinstance({min: 5}),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function instance(_options: InstanceOptions = INSTANCE_DEFAULTS): Transform {\n\tconst options = assignDefaults(INSTANCE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\n\t\tif (root.listAnimations().length) {\n\t\t\tlogger.warn(`${NAME}: Instancing is not currently supported for animated models.`);\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst batchExtension = doc.createExtension(EXTMeshGPUInstancing);\n\n\t\tlet numBatches = 0;\n\t\tlet numInstances = 0;\n\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t// Gather a one-to-many Mesh/Node mapping, identifying what we can instance.\n\t\t\tconst meshInstances = new Map<Mesh, Set<Node>>();\n\t\t\tscene.traverse((node) => {\n\t\t\t\tconst mesh = node.getMesh();\n\t\t\t\tif (!mesh) return;\n\t\t\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) return;\n\t\t\t\tmeshInstances.set(mesh, (meshInstances.get(mesh) || new Set<Node>()).add(node));\n\t\t\t});\n\n\t\t\t// For each Mesh, create an InstancedMesh and collect transforms.\n\t\t\tconst modifiedNodes = [];\n\t\t\tfor (const mesh of Array.from(meshInstances.keys())) {\n\t\t\t\tconst nodes = Array.from(meshInstances.get(mesh)!);\n\t\t\t\tif (nodes.length < options.min) continue;\n\t\t\t\tif (nodes.some((node) => node.getSkin())) continue;\n\n\t\t\t\t// Cannot preserve volumetric effects when instancing with varying scale.\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/AttenuationTest\n\t\t\t\tif (mesh.listPrimitives().some(hasVolume) && nodes.some(hasScale)) continue;\n\n\t\t\t\tconst batch = createBatch(doc, batchExtension, mesh, nodes.length);\n\t\t\t\tconst batchTranslation = batch.getAttribute('TRANSLATION')!;\n\t\t\t\tconst batchRotation = batch.getAttribute('ROTATION')!;\n\t\t\t\tconst batchScale = batch.getAttribute('SCALE')!;\n\n\t\t\t\tconst batchNode = doc.createNode().setMesh(mesh).setExtension('EXT_mesh_gpu_instancing', batch);\n\t\t\t\tscene.addChild(batchNode);\n\n\t\t\t\tlet needsTranslation = false;\n\t\t\t\tlet needsRotation = false;\n\t\t\t\tlet needsScale = false;\n\n\t\t\t\t// For each Node, write TRS properties into instance attributes.\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tlet t: vec3, r: vec4, s: vec3;\n\t\t\t\t\tconst node = nodes[i];\n\n\t\t\t\t\tbatchTranslation.setElement(i, (t = node.getWorldTranslation()));\n\t\t\t\t\tbatchRotation.setElement(i, (r = node.getWorldRotation()));\n\t\t\t\t\tbatchScale.setElement(i, (s = node.getWorldScale()));\n\n\t\t\t\t\tif (!MathUtils.eq(t, [0, 0, 0])) needsTranslation = true;\n\t\t\t\t\tif (!MathUtils.eq(r, [0, 0, 0, 1])) needsRotation = true;\n\t\t\t\t\tif (!MathUtils.eq(s, [1, 1, 1])) needsScale = true;\n\t\t\t\t}\n\n\t\t\t\tif (!needsTranslation) batchTranslation.dispose();\n\t\t\t\tif (!needsRotation) batchRotation.dispose();\n\t\t\t\tif (!needsScale) batchScale.dispose();\n\n\t\t\t\tif (!needsTranslation && !needsRotation && !needsScale) {\n\t\t\t\t\tbatchNode.dispose();\n\t\t\t\t\tbatch.dispose();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Mark nodes for cleanup.\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tnode.setMesh(null);\n\t\t\t\t\tmodifiedNodes.push(node);\n\t\t\t\t}\n\n\t\t\t\tnumBatches++;\n\t\t\t\tnumInstances += nodes.length;\n\t\t\t}\n\n\t\t\tpruneUnusedNodes(modifiedNodes, logger);\n\t\t}\n\n\t\tif (numBatches > 0) {\n\t\t\tlogger.info(`${NAME}: Created ${numBatches} batches, with ${numInstances} total instances.`);\n\t\t} else {\n\t\t\tlogger.info(`${NAME}: No meshes with >=${options.min} parent nodes were found.`);\n\t\t}\n\n\t\tif (batchExtension.listProperties().length === 0) {\n\t\t\tbatchExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction pruneUnusedNodes(nodes: Node[], logger: ILogger): void {\n\tlet node: Node | undefined;\n\tlet unusedNodes = 0;\n\twhile ((node = nodes.pop())) {\n\t\tif (\n\t\t\tnode.listChildren().length ||\n\t\t\tnode.getCamera() ||\n\t\t\tnode.getMesh() ||\n\t\t\tnode.getSkin() ||\n\t\t\tnode.listExtensions().length\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst nodeParent = node.getParentNode();\n\t\tif (nodeParent) nodes.push(nodeParent);\n\t\tnode.dispose();\n\t\tunusedNodes++;\n\t}\n\n\tlogger.debug(`${NAME}: Removed ${unusedNodes} unused nodes.`);\n}\n\nfunction hasVolume(prim: Primitive) {\n\tconst material = prim.getMaterial();\n\treturn !!(material && material.getExtension('KHR_materials_volume'));\n}\n\nfunction hasScale(node: Node) {\n\tconst scale = node.getWorldScale();\n\treturn !MathUtils.eq(scale, [1, 1, 1]);\n}\n\nfunction createBatch(doc: Document, batchExtension: EXTMeshGPUInstancing, mesh: Mesh, count: number): InstancedMesh {\n\tconst buffer = mesh.listPrimitives()[0].getAttribute('POSITION')!.getBuffer();\n\n\tconst batchTranslation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\tconst batchRotation = doc\n\t\t.createAccessor()\n\t\t.setType('VEC4')\n\t\t.setArray(new Float32Array(4 * count))\n\t\t.setBuffer(buffer);\n\tconst batchScale = doc\n\t\t.createAccessor()\n\t\t.setType('VEC3')\n\t\t.setArray(new Float32Array(3 * count))\n\t\t.setBuffer(buffer);\n\n\treturn batchExtension\n\t\t.createInstancedMesh()\n\t\t.setAttribute('TRANSLATION', batchTranslation)\n\t\t.setAttribute('ROTATION', batchRotation)\n\t\t.setAttribute('SCALE', batchScale);\n}\n", "import { Document, Primitive, ComponentTypeToTypedArray, Accessor, TypedArray } from '@gltf-transform/core';\nimport { assignDefaults, createIndicesEmpty, createPrimGroupKey, shallowCloneAccessor } from './utils.js';\nimport { convertPrimitiveToLines, convertPrimitiveToTriangles } from './convert-primitive-mode.js';\n\ninterface JoinPrimitiveOptions {\n\tskipValidation?: boolean;\n}\n\nconst JOIN_PRIMITIVE_DEFAULTS: Required<JoinPrimitiveOptions> = {\n\tskipValidation: false,\n};\n\nconst EMPTY_U32 = 2 ** 32 - 1;\n\nconst { LINE_STRIP, LINE_LOOP, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/**\n * Given a list of compatible Mesh {@link Primitive Primitives}, returns new Primitive\n * containing their vertex data. Compatibility requires that all Primitives share the\n * same {@link Material Materials}, draw mode, and vertex attribute types. Primitives\n * using morph targets cannot currently be joined.\n *\n * Example:\n *\n * ```javascript\n * import { joinPrimitives } from '@gltf-transform/functions';\n *\n * // Succeeds if Primitives are compatible, or throws an error.\n * const result = joinPrimitives(mesh.listPrimitives());\n *\n * for (const prim of mesh.listPrimitives()) {\n * \tprim.dispose();\n * }\n *\n * mesh.addPrimitive(result);\n * ```\n */\nexport function joinPrimitives(prims: Primitive[], _options: JoinPrimitiveOptions = {}): Primitive {\n\tconst options = assignDefaults(JOIN_PRIMITIVE_DEFAULTS, _options);\n\tconst templatePrim = prims[0]!;\n\tconst document = Document.fromGraph(templatePrim.getGraph())!;\n\n\t// (1) Validation.\n\tif (!options.skipValidation && new Set(prims.map(createPrimGroupKey)).size > 1) {\n\t\tthrow new Error(\n\t\t\t'' +\n\t\t\t\t'Requires >=2 Primitives, sharing the same Material ' +\n\t\t\t\t'and Mode, with compatible vertex attributes and indices.',\n\t\t);\n\t}\n\n\t// (2) Convert all prims to POINTS, LINES, or TRIANGLES.\n\tfor (const prim of prims) {\n\t\tswitch (prim.getMode()) {\n\t\t\tcase LINE_STRIP:\n\t\t\tcase LINE_LOOP:\n\t\t\t\tconvertPrimitiveToLines(prim);\n\t\t\t\tbreak;\n\t\t\tcase TRIANGLE_STRIP:\n\t\t\tcase TRIANGLE_FAN:\n\t\t\t\tconvertPrimitiveToTriangles(prim);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst primRemaps = [] as Uint32Array[]; // remap[srcIndex]  dstIndex, by prim\n\tconst primVertexCounts = new Uint32Array(prims.length); // vertex count, by prim\n\n\tlet dstVertexCount = 0;\n\tlet dstIndicesCount = 0;\n\n\t// (3) Build remap lists.\n\tfor (let primIndex = 0; primIndex < prims.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst srcIndices = srcPrim.getIndices();\n\t\tconst srcVertexCount = srcPrim.getAttribute('POSITION')!.getCount();\n\t\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\t\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : srcVertexCount;\n\n\t\tconst remap = new Uint32Array(srcVertexCount).fill(EMPTY_U32);\n\n\t\tfor (let i = 0; i < srcIndicesCount; i++) {\n\t\t\tconst index = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\t\tif (remap[index] === EMPTY_U32) {\n\t\t\t\tremap[index] = dstVertexCount++;\n\t\t\t\tprimVertexCounts[primIndex]++;\n\t\t\t}\n\t\t}\n\n\t\tprimRemaps.push(remap);\n\t\tdstIndicesCount += srcIndicesCount;\n\t}\n\n\t// (4) Allocate joined attributes.\n\tconst dstPrim = document.createPrimitive().setMode(templatePrim.getMode()).setMaterial(templatePrim.getMaterial());\n\tfor (const semantic of templatePrim.listSemantics()) {\n\t\tconst tplAttribute = templatePrim.getAttribute(semantic)!;\n\t\tconst AttributeArray = ComponentTypeToTypedArray[tplAttribute.getComponentType()];\n\t\tconst dstAttribute = shallowCloneAccessor(document, tplAttribute).setArray(\n\t\t\tnew AttributeArray(dstVertexCount * tplAttribute.getElementSize()),\n\t\t);\n\t\tdstPrim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// (5) Allocate joined indices.\n\tconst tplIndices = templatePrim.getIndices();\n\tconst dstIndices = tplIndices\n\t\t? shallowCloneAccessor(document, tplIndices).setArray(createIndicesEmpty(dstIndicesCount, dstVertexCount))\n\t\t: null;\n\tdstPrim.setIndices(dstIndices);\n\n\t// (6) Remap attributes into joined Primitive.\n\tlet dstIndicesOffset = 0;\n\tfor (let primIndex = 0; primIndex < primRemaps.length; primIndex++) {\n\t\tconst srcPrim = prims[primIndex];\n\t\tconst srcIndices = srcPrim.getIndices();\n\t\tconst srcIndicesCount = srcIndices ? srcIndices.getCount() : -1;\n\n\t\tconst remap = primRemaps[primIndex];\n\n\t\tif (srcIndices && dstIndices) {\n\t\t\tremapIndices(srcIndices, remap, dstIndices, dstIndicesOffset);\n\t\t\tdstIndicesOffset += srcIndicesCount;\n\t\t}\n\n\t\tfor (const semantic of dstPrim.listSemantics()) {\n\t\t\tconst srcAttribute = srcPrim.getAttribute(semantic)!;\n\t\t\tconst dstAttribute = dstPrim.getAttribute(semantic)!;\n\t\t\tremapAttribute(srcAttribute, srcIndices, remap, dstAttribute);\n\t\t}\n\t}\n\n\treturn dstPrim;\n}\n\n/**\n * Internal variant of {@link compactAttribute}. Unlike compactAttribute,\n * assumes the vertex count cannot change, and avoids cloning attributes.\n * @hidden\n * @internal\n */\nfunction remapAttribute(\n\tsrcAttribute: Accessor,\n\tsrcIndices: Accessor | null,\n\tremap: TypedArray,\n\tdstAttribute: Accessor,\n): void {\n\tconst elementSize = srcAttribute.getElementSize();\n\tconst srcIndicesArray = srcIndices ? srcIndices.getArray() : null;\n\tconst srcVertexCount = srcAttribute.getCount();\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst dstArray = dstAttribute.getArray()!;\n\tconst done = new Uint8Array(srcAttribute.getCount());\n\n\tfor (let i = 0, il = srcIndices ? srcIndices.getCount() : srcVertexCount; i < il; i++) {\n\t\tconst srcIndex = srcIndicesArray ? srcIndicesArray[i] : i;\n\t\tconst dstIndex = remap[srcIndex];\n\t\tif (done[dstIndex]) continue;\n\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[dstIndex * elementSize + j] = srcArray[srcIndex * elementSize + j];\n\t\t}\n\n\t\tdone[dstIndex] = 1;\n\t}\n}\n\n/**\n * Internal variant of {@link compactPrimitive}'s index remapping. Avoids\n * cloning indices; writes directly to `dstIndices`.\n * @hidden\n * @internal\n */\nfunction remapIndices(srcIndices: Accessor, remap: TypedArray, dstIndices: Accessor, dstOffset: number): void {\n\tconst srcCount = srcIndices.getCount();\n\tconst srcArray = srcIndices.getArray()!;\n\tconst dstArray = dstIndices.getArray()!;\n\n\tfor (let i = 0; i < srcCount; i++) {\n\t\tconst srcIndex = srcArray[i];\n\t\tconst dstIndex = remap[srcIndex];\n\t\tdstArray[dstOffset + i] = dstIndex;\n\t}\n}\n", "import {\n\tAnimationChannel,\n\tDocument,\n\tmat4,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPropertyType,\n\tScene,\n\tTransform,\n} from '@gltf-transform/core';\nimport { invert, multiply } from 'gl-matrix/mat4';\nimport { joinPrimitives } from './join-primitives.js';\nimport { prune } from './prune.js';\nimport { transformPrimitive } from './transform-primitive.js';\nimport { assignDefaults, createPrimGroupKey, createTransform, formatLong, isUsed } from './utils.js';\nimport { dequantizeAttribute } from './dequantize.js';\nimport { compactPrimitive } from './compact-primitive.js';\n\nconst NAME = 'join';\n\nconst { ROOT, NODE, MESH, PRIMITIVE, ACCESSOR } = PropertyType;\n\n// prettier-ignore\nconst _matrix = [\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n\t0, 0, 0, 0,\n] as mat4;\n\n/** Options for the {@link join} function. */\nexport interface JoinOptions {\n\t/**\n\t * Prevents joining distinct {@link Mesh Meshes} and {@link Node Nodes}.\n\t * Joins only Primitives found within the same parent Mesh. To preserve\n\t * only _named_ Nodes and Meshes, use\n\t * {@link JoinOptions.keepNamed keepNamed} instead. Default: false.\n\t */\n\tkeepMeshes?: boolean;\n\t/**\n\t * Prevents joining _named_ {@link Mesh Meshes} and {@link Node Nodes}.\n\t * If {@link JoinOptions.keepMeshes keepMeshes} is enabled, keepNamed will\n\t * have no effect. Default: false.\n\t */\n\tkeepNamed?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const JOIN_DEFAULTS: Required<JoinOptions> = {\n\tkeepMeshes: false,\n\tkeepNamed: false,\n\tcleanup: true,\n};\n\n/**\n * Joins compatible {@link Primitive Primitives} and reduces draw calls.\n * Primitives are eligible for joining if they are members of the same\n * {@link Mesh} or, optionally, attached to sibling {@link Node Nodes}\n * in the scene hierarchy. For best results, apply {@link dedup} and\n * {@link flatten} first to maximize the number of Primitives that\n * can be joined.\n *\n * NOTE: In a Scene that heavily reuses the same Mesh data, joining may\n * increase vertex count. Consider alternatives, like\n * {@link instance instancing} with {@link EXTMeshGPUInstancing}.\n *\n * Example:\n *\n * ```ts\n * import { PropertyType } from '@gltf-transform/core';\n * import { join, flatten, dedup } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tdedup({ propertyTypes: [PropertyType.MATERIAL] }),\n * \tflatten(),\n * \tjoin({ keepNamed: false }),\n * );\n * ```\n *\n * @category Transforms\n */\nexport function join(_options: JoinOptions = JOIN_DEFAULTS): Transform {\n\tconst options = assignDefaults(JOIN_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\t// Join.\n\t\tfor (const scene of root.listScenes()) {\n\t\t\t_joinLevel(document, scene, options);\n\t\t\tscene.traverse((node) => _joinLevel(document, node, options));\n\t\t}\n\n\t\t// Clean up.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [NODE, MESH, PRIMITIVE, ACCESSOR],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: false,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\ninterface IJoinGroup {\n\tkey: string;\n\tprims: Primitive[];\n\tprimMeshes: Mesh[];\n\tprimNodes: Node[];\n\tdstNode: Node;\n\tdstMesh?: Mesh | undefined;\n}\n\nfunction _joinLevel(document: Document, parent: Node | Scene, options: Required<JoinOptions>) {\n\tconst logger = document.getLogger();\n\tconst groups = {} as Record<string, IJoinGroup>;\n\n\t// Scan for compatible Primitives.\n\tconst children = parent.listChildren();\n\tfor (let nodeIndex = 0; nodeIndex < children.length; nodeIndex++) {\n\t\tconst node = children[nodeIndex];\n\n\t\t// Skip animated nodes.\n\t\tconst isAnimated = node.listParents().some((p) => p instanceof AnimationChannel);\n\t\tif (isAnimated) continue;\n\n\t\t// Skip nodes without meshes.\n\t\tconst mesh = node.getMesh();\n\t\tif (!mesh) continue;\n\n\t\t// Skip nodes with instancing; unsupported.\n\t\tif (node.getExtension('EXT_mesh_gpu_instancing')) continue;\n\n\t\t// Skip nodes with skinning; unsupported.\n\t\tif (node.getSkin()) continue;\n\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t// Skip prims with morph targets; unsupported.\n\t\t\tif (prim.listTargets().length > 0) continue;\n\n\t\t\t// Skip prims with volumetric materials; unsupported.\n\t\t\tconst material = prim.getMaterial();\n\t\t\tif (material && material.getExtension('KHR_materials_volume')) continue;\n\n\t\t\tcompactPrimitive(prim);\n\t\t\tdequantizeTransformableAttributes(prim);\n\n\t\t\tlet key = createPrimGroupKey(prim);\n\n\t\t\tconst isNamed = mesh.getName() || node.getName();\n\t\t\tif (options.keepMeshes || (options.keepNamed && isNamed)) {\n\t\t\t\tkey += `|${nodeIndex}`;\n\t\t\t}\n\n\t\t\tif (!(key in groups)) {\n\t\t\t\tgroups[key] = {\n\t\t\t\t\tprims: [] as Primitive[],\n\t\t\t\t\tprimMeshes: [] as Mesh[],\n\t\t\t\t\tprimNodes: [] as Node[],\n\t\t\t\t\tdstNode: node,\n\t\t\t\t\tdstMesh: undefined,\n\t\t\t\t} as IJoinGroup;\n\t\t\t}\n\n\t\t\tconst group = groups[key];\n\t\t\tgroup.prims.push(prim);\n\t\t\tgroup.primNodes.push(node);\n\t\t}\n\t}\n\n\t// Discard single-Primitive groups.\n\tconst joinGroups = Object.values(groups).filter(({ prims }) => prims.length > 1);\n\n\t// Unlink all affected Meshes at current level, before modifying Primitives.\n\tconst srcNodes = new Set<Node>(joinGroups.flatMap((group) => group.primNodes));\n\tfor (const node of srcNodes) {\n\t\tconst mesh = node.getMesh()!;\n\t\tconst isSharedMesh = mesh.listParents().some((parent) => {\n\t\t\treturn parent.propertyType !== ROOT && node !== parent;\n\t\t});\n\t\tif (isSharedMesh) {\n\t\t\tnode.setMesh(mesh.clone());\n\t\t}\n\t}\n\n\t// Update Meshes in groups.\n\tfor (const group of joinGroups) {\n\t\tconst { dstNode, primNodes } = group;\n\t\tgroup.dstMesh = dstNode.getMesh()!;\n\t\tgroup.primMeshes = primNodes.map((node) => node.getMesh()!);\n\t}\n\n\t// Join Primitives.\n\tfor (const group of joinGroups) {\n\t\tconst { prims, primNodes, primMeshes, dstNode, dstMesh } = group as Required<IJoinGroup>;\n\t\tconst dstMatrix = dstNode.getMatrix();\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tconst primNode = primNodes[i];\n\t\t\tconst primMesh = primMeshes[i];\n\n\t\t\tlet prim = prims[i];\n\t\t\tprimMesh.removePrimitive(prim);\n\n\t\t\t// If Primitive is still in use after being removed from the\n\t\t\t// current mesh, above, make a deep copy. Because compactPrimitive()\n\t\t\t// was applied earlier in join(), we know the full vertex streams are\n\t\t\t// used, and no accessors are shared.\n\t\t\tif (isUsed(prim)) {\n\t\t\t\tprim = prims[i] = _deepClonePrimitive(prims[i]);\n\t\t\t}\n\n\t\t\t// Transform Primitive into new local coordinate space.\n\t\t\tif (primNode !== dstNode) {\n\t\t\t\tmultiply(_matrix, invert(_matrix, dstMatrix), primNode.getMatrix());\n\t\t\t\ttransformPrimitive(prim, _matrix);\n\t\t\t}\n\t\t}\n\n\t\tconst dstPrim = joinPrimitives(prims);\n\t\tconst dstVertexCount = dstPrim.listAttributes()[0].getCount();\n\t\tdstMesh.addPrimitive(dstPrim);\n\n\t\tlogger.debug(\n\t\t\t`${NAME}: Joined Primitives (${prims.length}) containing ` +\n\t\t\t\t`${formatLong(dstVertexCount)} vertices under Node \"${dstNode.getName()}\".`,\n\t\t);\n\t}\n}\n\nfunction _deepClonePrimitive(src: Primitive): Primitive {\n\t// compactPrimitive already applied; no vertices are unused.\n\tconst dst = src.clone();\n\tfor (const semantic of dst.listSemantics()) {\n\t\tdst.setAttribute(semantic, dst.getAttribute(semantic)!.clone());\n\t}\n\tconst indices = dst.getIndices();\n\tif (indices) dst.setIndices(indices.clone());\n\treturn dst;\n}\n\n/**\n * Dequantize attributes that would be affected by {@link transformPrimitive},\n * to avoid invalidating our primitive group keys.\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/844\n */\nfunction dequantizeTransformableAttributes(prim: Primitive) {\n\tfor (const semantic of ['POSITION', 'NORMAL', 'TANGENT']) {\n\t\tconst attribute = prim.getAttribute(semantic);\n\t\tif (attribute) dequantizeAttribute(attribute);\n\t}\n}\n", "import { Document, Texture } from '@gltf-transform/core';\nimport { Material, TextureChannel, PropertyType } from '@gltf-transform/core';\n\n/**\n * Returns a list of {@link TextureChannel TextureChannels} used by the given\n * texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel\n * in use. See {@link getTextureChannelMask} for bitmask alternative.\n *\n * Example:\n *\n * ```js\n * const channels = listTextureChannels(texture);\n * if (channels.includes(TextureChannel.R)) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function listTextureChannels(texture: Texture): TextureChannel[] {\n\tconst mask = getTextureChannelMask(texture);\n\tconst channels = [];\n\tif (mask & TextureChannel.R) channels.push(TextureChannel.R);\n\tif (mask & TextureChannel.G) channels.push(TextureChannel.G);\n\tif (mask & TextureChannel.B) channels.push(TextureChannel.B);\n\tif (mask & TextureChannel.A) channels.push(TextureChannel.A);\n\treturn channels;\n}\n\n/**\n * Returns bitmask of all {@link TextureChannel TextureChannels} used by the\n * given texture. Determination is based only on the _role_ of the textures, e.g.\n * a texture used for the `occlusionTexture` will have (at least) a red channel.\n * See {@link listTextureChannels} for an array alternative.\n *\n * Example:\n *\n * ```js\n * const mask = getTextureChannelMask(texture);\n * if (mask & TextureChannel.R) {\n *   console.log('texture red channel used');\n * }\n * ```\n */\nexport function getTextureChannelMask(texture: Texture): number {\n\tconst document = Document.fromGraph(texture.getGraph())!;\n\tlet mask = 0x0000;\n\tfor (const edge of document.getGraph().listParentEdges(texture)) {\n\t\tconst parent = edge.getParent();\n\t\tlet { channels } = edge.getAttributes() as { channels: number | undefined };\n\n\t\tif (\n\t\t\tchannels &&\n\t\t\tedge.getName() === 'baseColorTexture' &&\n\t\t\tparent instanceof Material &&\n\t\t\tparent.getAlphaMode() === Material.AlphaMode.OPAQUE\n\t\t) {\n\t\t\tchannels &= ~TextureChannel.A;\n\t\t}\n\n\t\tif (channels) {\n\t\t\tmask |= channels;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (parent.propertyType !== PropertyType.ROOT) {\n\t\t\tdocument.getLogger().warn(`Missing attribute \".channels\" on edge, \"${edge.getName()}\".`);\n\t\t}\n\t}\n\treturn mask;\n}\n", "import { Accessor, Document, GLTF, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform, deepListAttributes, SetMap, shallowCloneAccessor } from './utils.js';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { compactAttribute } from './compact-primitive.js';\n\nconst NAME = 'reorder';\n\n/** Options for the {@link reorder} function. */\nexport interface ReorderOptions {\n\t/** MeshoptEncoder instance. */\n\tencoder: unknown;\n\t/**\n\t * Whether the order should be optimal for transmission size (recommended for Web)\n\t * or for GPU rendering performance. Default is 'size'.\n\t */\n\ttarget?: 'size' | 'performance';\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nconst REORDER_DEFAULTS: Required<Omit<ReorderOptions, 'encoder'>> = {\n\ttarget: 'size',\n\tcleanup: true,\n};\n\n/**\n * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether\n * the order should be optimal for transmission size (recommended for Web) or for GPU rendering\n * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.\n *\n * Example:\n *\n * ```ts\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { reorder } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n * \treorder({encoder: MeshoptEncoder})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function reorder(_options: ReorderOptions): Transform {\n\tconst options = assignDefaults(REORDER_DEFAULTS, _options);\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait encoder.ready;\n\n\t\tconst plan = createLayoutPlan(document);\n\n\t\tfor (const srcIndices of plan.indicesToAttributes.keys()) {\n\t\t\tlet indicesArray = srcIndices.getArray()!;\n\t\t\tif (!(indicesArray instanceof Uint32Array)) {\n\t\t\t\tindicesArray = new Uint32Array(indicesArray);\n\t\t\t} else {\n\t\t\t\tindicesArray = indicesArray.slice();\n\t\t\t}\n\n\t\t\t// Compute optimal order.\n\t\t\tconst [remap, unique] = encoder.reorderMesh(\n\t\t\t\tindicesArray,\n\t\t\t\tplan.indicesToMode.get(srcIndices) === Primitive.Mode.TRIANGLES,\n\t\t\t\toptions.target === 'size',\n\t\t\t);\n\n\t\t\tconst dstIndices = shallowCloneAccessor(document, srcIndices);\n\t\t\tdstIndices.setArray(unique <= 65534 ? new Uint16Array(indicesArray) : indicesArray);\n\n\t\t\t// Update affected primitives.\n\t\t\tfor (const srcAttribute of plan.indicesToAttributes.get(srcIndices)) {\n\t\t\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\t\t\tcompactAttribute(srcAttribute, srcIndices, remap, dstAttribute, unique);\n\n\t\t\t\tfor (const prim of plan.indicesToPrimitives.get(srcIndices)) {\n\t\t\t\t\tif (prim.getIndices() === srcIndices) {\n\t\t\t\t\t\tprim.swap(srcIndices, dstIndices);\n\t\t\t\t\t}\n\n\t\t\t\t\tprim.swap(srcAttribute, dstAttribute);\n\t\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\t\ttarget.swap(srcAttribute, dstAttribute);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any attributes left unused by earlier cloning.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (!plan.indicesToAttributes.size) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found; may need to weld first.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n/** @hidden */\ninterface LayoutPlan {\n\tindicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;\n\tindicesToPrimitives: SetMap<Accessor, Primitive>;\n\tindicesToAttributes: SetMap<Accessor, Accessor>;\n\tattributesToPrimitives: SetMap<Accessor, Primitive>;\n}\n\n/**\n * Constructs a plan for processing vertex streams, based on unique\n * index:attribute[] groups. Where different indices are used with the same\n * attributes, we'll end up splitting the primitives to not share attributes,\n * which appears to be consistent with the Meshopt implementation.\n *\n * @hidden\n */\nfunction createLayoutPlan(document: Document): LayoutPlan {\n\tconst indicesToMode = new Map<Accessor, GLTF.MeshPrimitiveMode>();\n\tconst indicesToPrimitives = new SetMap<Accessor, Primitive>();\n\tconst indicesToAttributes = new SetMap<Accessor, Accessor>();\n\tconst attributesToPrimitives = new SetMap<Accessor, Primitive>();\n\n\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\tconst indices = prim.getIndices();\n\t\t\tif (!indices) continue;\n\n\t\t\tindicesToMode.set(indices, prim.getMode());\n\t\t\tindicesToPrimitives.add(indices, prim);\n\n\t\t\tfor (const attribute of deepListAttributes(prim)) {\n\t\t\t\tindicesToAttributes.add(indices, attribute);\n\t\t\t\tattributesToPrimitives.add(attribute, prim);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { indicesToPrimitives, indicesToAttributes, indicesToMode, attributesToPrimitives };\n}\n", "import { Accessor, GLTF, MathUtils, Primitive, PrimitiveTarget, TypedArray, vec4 } from '@gltf-transform/core';\n\n/**\n * Sorts skinning weights from high to low, for each vertex of the input\n * {@link Primitive} or {@link PrimitiveTarget}, and normalizes the weights.\n * Optionally, uses the given 'limit' to remove least-significant joint\n * influences such that no vertex has more than 'limit' influences.\n *\n * Most realtime engines support a limited number of joint influences per vertex,\n * often 4 or 8. Sorting and removing the additional influences can reduce file\n * size and improve compatibility.\n *\n * Example:\n *\n * ```javascript\n * import { sortPrimitiveWeights } from '@gltf-transform/functions';\n *\n * const limit = 4;\n * for (const mesh of document.getRoot().listMeshes()) {\n * \tfor (const prim of mesh.listPrimitives()) {\n * \t\tsortPrimitiveWeights(prim, limit);\n * \t}\n * }\n * ```\n *\n * @param prim Input, to be modified in place.\n * @param limit Maximum number of joint influences per vertex. Must be a multiple of four.\n */\nexport function sortPrimitiveWeights(prim: Primitive | PrimitiveTarget, limit = Infinity) {\n\tif ((Number.isFinite(limit) && limit % 4) || limit <= 0) {\n\t\tthrow new Error(`Limit must be positive multiple of four.`);\n\t}\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\t// (1) Sort.\n\n\tconst indices = new Uint16Array(setCount * 4);\n\tconst srcWeights = new Float32Array(setCount * 4);\n\tconst dstWeights = new Float32Array(setCount * 4);\n\tconst srcJoints = new Uint32Array(setCount * 4);\n\tconst dstJoints = new Uint32Array(setCount * 4);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'WEIGHTS', srcWeights);\n\t\tgetVertexArray(prim, i, 'JOINTS', srcJoints);\n\n\t\t// Sort indices to create a lookup table, indices[dstIndex]  srcIndex,\n\t\t// indexed into the weights and joints arrays.\n\t\tfor (let j = 0; j < setCount * 4; j++) indices[j] = j;\n\t\tindices.sort((a, b) => (srcWeights[a] > srcWeights[b] ? -1 : 1));\n\n\t\t// Sort weights and joints.\n\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\tdstWeights[j] = srcWeights[indices[j]];\n\t\t\tdstJoints[j] = srcJoints[indices[j]];\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'WEIGHTS', dstWeights);\n\t\tsetVertexArray(prim, i, 'JOINTS', dstJoints);\n\t}\n\n\t// (2) Limit.\n\tfor (let i = setCount; i * 4 > limit; i--) {\n\t\tconst weights = prim.getAttribute(`WEIGHTS_${i - 1}`)!;\n\t\tconst joints = prim.getAttribute(`JOINTS_${i - 1}`)!;\n\t\tprim.setAttribute(`WEIGHTS_${i - 1}`, null);\n\t\tprim.setAttribute(`JOINTS_${i - 1}`, null);\n\t\tif (weights.listParents().length === 1) weights.dispose();\n\t\tif (joints.listParents().length === 1) joints.dispose();\n\t}\n\n\t// (3) Normalize.\n\tnormalizePrimitiveWeights(prim);\n}\n\n// Utilities.\n\ntype PrimLike = Primitive | PrimitiveTarget;\n\nfunction normalizePrimitiveWeights(prim: PrimLike): void {\n\t// TODO(feat): Convert attributes to same component types when necessary.\n\tif (!isNormalizeSafe(prim)) return;\n\n\tconst vertexCount = prim.getAttribute('POSITION')!.getCount();\n\tconst setCount = prim.listSemantics().filter((name) => name.startsWith('WEIGHTS_')).length;\n\n\tconst templateAttribute = prim.getAttribute('WEIGHTS_0')!;\n\tconst templateArray = templateAttribute.getArray()!;\n\tconst componentType = templateAttribute.getComponentType();\n\tconst normalized = templateAttribute.getNormalized();\n\tconst normalizedComponentType = normalized ? componentType : undefined;\n\tconst delta = normalized ? MathUtils.decodeNormalizedInt(1, componentType) : Number.EPSILON;\n\tconst joints = new Uint32Array(setCount * 4).fill(0);\n\tconst weights = templateArray.slice(0, setCount * 4).fill(0);\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tgetVertexArray(prim, i, 'JOINTS', joints);\n\t\tgetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\n\t\tlet weightsSum = sum(weights, normalizedComponentType);\n\n\t\tif (weightsSum !== 0 && weightsSum !== 1) {\n\t\t\t// (1) If sum of weights not within  of 1, renormalize all weights.\n\t\t\tif (Math.abs(1 - weightsSum) > delta) {\n\t\t\t\tfor (let j = 0; j < weights.length; j++) {\n\t\t\t\t\tif (normalized) {\n\t\t\t\t\t\tconst floatValue = MathUtils.decodeNormalizedInt(weights[j], componentType);\n\t\t\t\t\t\tweights[j] = MathUtils.encodeNormalizedInt(floatValue / weightsSum, componentType);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweights[j] /= weightsSum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tweightsSum = sum(weights, normalizedComponentType);\n\n\t\t\t// (2) Sum of normalized weights may still be off by . Compensate\n\t\t\t// in least-significant weight.\n\t\t\tif (normalized && weightsSum !== 1) {\n\t\t\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (weights[j] > 0) {\n\t\t\t\t\t\t// Normalized integer encoding will clamp negative values, so separate the sign.\n\t\t\t\t\t\tconst delta = 1 - weightsSum;\n\t\t\t\t\t\tweights[j] += Math.sign(delta) * MathUtils.encodeNormalizedInt(Math.abs(delta), componentType);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (3) Remove joint indices whose weights have fallen to zero.\n\t\tfor (let j = weights.length - 1; j >= 0; j--) {\n\t\t\tif (weights[j] === 0) {\n\t\t\t\tjoints[j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetVertexArray(prim, i, 'JOINTS', joints);\n\t\tsetVertexArray(prim, i, 'WEIGHTS', weights, normalizedComponentType);\n\t}\n}\n\n/** Lists all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction getVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\ttarget: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType,\n): TypedArray {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tweights.getElement(vertexIndex, el);\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\ttarget[i * 4 + j] = MathUtils.encodeNormalizedInt(el[j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\ttarget[i * 4 + j] = el[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/** Sets all values of a multi-set vertex attribute (WEIGHTS_#, ...) for given vertex. */\nfunction setVertexArray(\n\tprim: PrimLike,\n\tvertexIndex: number,\n\tprefix: string,\n\tvalues: TypedArray,\n\tnormalizedComponentType?: GLTF.AccessorComponentType,\n): void {\n\tlet weights: Accessor | null;\n\tconst el = [0, 0, 0, 0] as vec4;\n\tfor (let i = 0; (weights = prim.getAttribute(`${prefix}_${i}`)); i++) {\n\t\tfor (let j = 0; j < 4; j++) {\n\t\t\tif (normalizedComponentType) {\n\t\t\t\tel[j] = MathUtils.decodeNormalizedInt(values[i * 4 + j], normalizedComponentType);\n\t\t\t} else {\n\t\t\t\tel[j] = values[i * 4 + j];\n\t\t\t}\n\t\t}\n\t\tweights.setElement(vertexIndex, el);\n\t}\n}\n\n/** Sum an array of numbers. */\nfunction sum(values: TypedArray, normalizedComponentType?: GLTF.AccessorComponentType): number {\n\tlet sum = 0;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tif (normalizedComponentType) {\n\t\t\tsum += MathUtils.decodeNormalizedInt(values[i], normalizedComponentType);\n\t\t} else {\n\t\t\tsum += values[i];\n\t\t}\n\t}\n\treturn sum;\n}\n\n/** Returns true if attribute normalization is supported for this primitive. */\nfunction isNormalizeSafe(prim: PrimLike): boolean {\n\tconst attributes = prim\n\t\t.listSemantics()\n\t\t.filter((name) => name.startsWith('WEIGHTS_'))\n\t\t.map((name) => prim.getAttribute(name)!);\n\tconst normList = attributes.map((a) => a.getNormalized());\n\tconst typeList = attributes.map((a) => a.getComponentType());\n\treturn new Set(normList).size === 1 && new Set(typeList).size === 1;\n}\n", "import {\n\tAccessor,\n\tAnimationChannel,\n\tbbox,\n\tDocument,\n\tILogger,\n\tmat4,\n\tMathUtils,\n\tMesh,\n\tNode,\n\tPrimitive,\n\tPrimitiveTarget,\n\tPropertyType,\n\tSkin,\n\tTransform,\n\tvec2,\n\tvec3,\n\tvec4,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup.js';\nimport { fromRotationTranslationScale, fromScaling, invert, multiply as multiplyMat4 } from 'gl-matrix/mat4';\nimport { max, min, scale, transformMat4 } from 'gl-matrix/vec3';\nimport { InstancedMesh, KHRMeshQuantization } from '@gltf-transform/extensions';\nimport type { Volume } from '@gltf-transform/extensions';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { sortPrimitiveWeights } from './sort-primitive-weights.js';\nimport { getPrimitiveVertexCount, VertexCountMethod } from './get-vertex-count.js';\nimport { compactPrimitive } from './compact-primitive.js';\n\nconst NAME = 'quantize';\n\ntype TypedArrayConstructor =\n\t| Int8ArrayConstructor\n\t| Int16ArrayConstructor\n\t| Uint8ArrayConstructor\n\t| Uint16ArrayConstructor;\nconst SIGNED_INT = [Int8Array, Int16Array, Int32Array] as TypedArrayConstructor[];\n\nconst { TRANSLATION, ROTATION, SCALE, WEIGHTS } = AnimationChannel.TargetPath;\nconst TRS_CHANNELS = [TRANSLATION, ROTATION, SCALE];\n\n/** Options for the {@link quantize} function. */\nexport interface QuantizeOptions {\n\t/** Pattern (regex) used to filter vertex attribute semantics for quantization. Default: all. */\n\tpattern?: RegExp;\n\t/** Pattern (regex) used to filter morph target semantics for quantization. Default: `options.pattern`. */\n\tpatternTargets?: RegExp;\n\t/** Bounds for quantization grid. */\n\tquantizationVolume?: 'mesh' | 'scene';\n\t/** Quantization bits for `POSITION` attributes. */\n\tquantizePosition?: number;\n\t/** Quantization bits for `NORMAL` attributes. */\n\tquantizeNormal?: number;\n\t/** Quantization bits for `TEXCOORD_*` attributes. */\n\tquantizeTexcoord?: number;\n\t/** Quantization bits for `COLOR_*` attributes. */\n\tquantizeColor?: number;\n\t/** Quantization bits for `WEIGHT_*` attributes. */\n\tquantizeWeight?: number;\n\t/** Quantization bits for application-specific (`_*`) attributes. */\n\tquantizeGeneric?: number;\n\t/** Normalize weight attributes. */\n\tnormalizeWeights?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const QUANTIZE_DEFAULTS: Required<Omit<QuantizeOptions, 'patternTargets'>> = {\n\tpattern: /.*/,\n\tquantizationVolume: 'mesh',\n\tquantizePosition: 14,\n\tquantizeNormal: 10,\n\tquantizeTexcoord: 12,\n\tquantizeColor: 8,\n\tquantizeWeight: 8,\n\tquantizeGeneric: 12,\n\tnormalizeWeights: true,\n\tcleanup: true,\n};\n\n/**\n * References:\n * - https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n * - http://www.aclockworkberry.com/normal-unpacking-quantization-errors/\n * - https://www.mathworks.com/help/dsp/ref/uniformencoder.html\n * - https://oroboro.com/compressed-unit-vectors/\n */\n\n/**\n * Quantizes vertex attributes with `KHR_mesh_quantization`, reducing the size and memory footprint\n * of the file.\n *\n * @category Transforms\n */\nexport function quantize(_options: QuantizeOptions = QUANTIZE_DEFAULTS): Transform {\n\tconst options = assignDefaults(QUANTIZE_DEFAULTS, {\n\t\tpatternTargets: _options.pattern || QUANTIZE_DEFAULTS.pattern,\n\t\t..._options,\n\t});\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\t// Compute vertex position quantization volume.\n\t\tlet nodeTransform: VectorTransform<vec3> | undefined = undefined;\n\t\tif (options.quantizationVolume === 'scene') {\n\t\t\tnodeTransform = getNodeTransform(expandBounds(root.listMeshes().map(getPositionQuantizationVolume)));\n\t\t}\n\n\t\t// Quantize mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tif (options.quantizationVolume === 'mesh') {\n\t\t\t\tnodeTransform = getNodeTransform(getPositionQuantizationVolume(mesh));\n\t\t\t}\n\n\t\t\tif (nodeTransform && options.pattern.test('POSITION')) {\n\t\t\t\ttransformMeshParents(document, mesh, nodeTransform);\n\t\t\t\ttransformMeshMaterials(mesh, 1 / nodeTransform.scale);\n\t\t\t}\n\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst renderCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\t\t\t\tconst uploadCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\t\t\t\tif (renderCount < uploadCount / 2) {\n\t\t\t\t\tcompactPrimitive(prim);\n\t\t\t\t}\n\t\t\t\tquantizePrimitive(document, prim, nodeTransform!, options);\n\t\t\t\tfor (const target of prim.listTargets()) {\n\t\t\t\t\tquantizePrimitive(document, target, nodeTransform!, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst needsExtension = root\n\t\t\t.listMeshes()\n\t\t\t.flatMap((mesh) => mesh.listPrimitives())\n\t\t\t.some(isQuantizedPrimitive);\n\t\tif (needsExtension) {\n\t\t\tdocument.createExtension(KHRMeshQuantization).setRequired(true);\n\t\t}\n\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.SKIN, PropertyType.MATERIAL],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: true,\n\t\t\t\t\tkeepSolidTextures: true,\n\t\t\t\t}),\n\t\t\t\tdedup({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.MATERIAL, PropertyType.SKIN],\n\t\t\t\t\tkeepUniqueNames: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction quantizePrimitive(\n\tdoc: Document,\n\tprim: Primitive | PrimitiveTarget,\n\tnodeTransform: VectorTransform<vec3>,\n\toptions: Required<QuantizeOptions>,\n): void {\n\tconst isTarget = prim instanceof PrimitiveTarget;\n\tconst logger = doc.getLogger();\n\n\tfor (const semantic of prim.listSemantics()) {\n\t\tif (!isTarget && !options.pattern.test(semantic)) continue;\n\t\tif (isTarget && !options.patternTargets.test(semantic)) continue;\n\n\t\tconst srcAttribute = prim.getAttribute(semantic)!;\n\n\t\tconst { bits, ctor } = getQuantizationSettings(semantic, srcAttribute, logger, options);\n\n\t\tif (!ctor) continue;\n\t\tif (bits < 8 || bits > 16) throw new Error(`${NAME}: Requires bits = 816.`);\n\t\tif (srcAttribute.getComponentSize() <= bits / 8) continue;\n\n\t\tconst dstAttribute = srcAttribute.clone();\n\n\t\t// Remap position data.\n\t\tif (semantic === 'POSITION') {\n\t\t\tconst scale = nodeTransform.scale;\n\t\t\tconst transform: mat4 = [] as unknown as mat4;\n\t\t\t// Morph targets are relative offsets, don't translate them.\n\t\t\tprim instanceof Primitive\n\t\t\t\t? invert(transform, fromTransform(nodeTransform))\n\t\t\t\t: fromScaling(transform, [1 / scale, 1 / scale, 1 / scale]);\n\t\t\tfor (let i = 0, el: vec3 = [0, 0, 0], il = dstAttribute.getCount(); i < il; i++) {\n\t\t\t\tdstAttribute.getElement(i, el);\n\t\t\t\tdstAttribute.setElement(i, transformMat4(el, el, transform) as vec3);\n\t\t\t}\n\t\t}\n\n\t\t// Quantize the vertex attribute.\n\t\tquantizeAttribute(dstAttribute, ctor, bits);\n\t\tprim.setAttribute(semantic, dstAttribute);\n\t}\n\n\t// Normalize skinning weights.\n\tif (options.normalizeWeights && prim.getAttribute('WEIGHTS_0')) {\n\t\tsortPrimitiveWeights(prim, Infinity);\n\t}\n\n\tif (\n\t\tprim instanceof Primitive &&\n\t\tprim.getIndices() &&\n\t\tprim.listAttributes().length &&\n\t\tprim.listAttributes()[0]!.getCount() < 65535\n\t) {\n\t\tconst indices = prim.getIndices()!;\n\t\tindices.setArray(new Uint16Array(indices.getArray()!));\n\t}\n}\n\n/** Computes node quantization transforms in local space. */\nfunction getNodeTransform(volume: bbox): VectorTransform<vec3> {\n\tconst { min, max } = volume;\n\n\t// Scaling factor transforms [-1,1] box to the mesh AABB in local space.\n\t// See: https://github.com/donmccurdy/glTF-Transform/issues/328\n\tconst scale = Math.max(\n\t\t(max[0] - min[0]) / 2, // Divide because interval [-1,1] has length 2.\n\t\t(max[1] - min[1]) / 2,\n\t\t(max[2] - min[2]) / 2,\n\t);\n\n\t// Original center of the mesh, in local space.\n\tconst offset: vec3 = [\n\t\tmin[0] + (max[0] - min[0]) / 2,\n\t\tmin[1] + (max[1] - min[1]) / 2,\n\t\tmin[2] + (max[2] - min[2]) / 2,\n\t];\n\n\treturn { offset, scale };\n}\n\n/** Applies corrective scale and offset to nodes referencing a quantized Mesh. */\nfunction transformMeshParents(doc: Document, mesh: Mesh, nodeTransform: VectorTransform<vec3>): void {\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tfor (const parent of mesh.listParents()) {\n\t\tif (!(parent instanceof Node)) continue;\n\n\t\tconst animChannels = parent.listParents().filter((p) => p instanceof AnimationChannel) as AnimationChannel[];\n\t\tconst isAnimated = animChannels.some((channel) => TRS_CHANNELS.includes(channel.getTargetPath()!));\n\t\tconst isParentNode = parent.listChildren().length > 0;\n\n\t\tconst skin = parent.getSkin();\n\t\tif (skin) {\n\t\t\tparent.setSkin(transformSkin(skin, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst batch = parent.getExtension<InstancedMesh>('EXT_mesh_gpu_instancing');\n\t\tif (batch) {\n\t\t\tparent.setExtension('EXT_mesh_gpu_instancing', transformBatch(batch, nodeTransform));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet targetNode: Node;\n\t\tif (isParentNode || isAnimated) {\n\t\t\ttargetNode = doc.createNode('').setMesh(mesh);\n\t\t\tparent.addChild(targetNode).setMesh(null);\n\t\t\tanimChannels\n\t\t\t\t.filter((channel) => channel.getTargetPath() === WEIGHTS)\n\t\t\t\t.forEach((channel) => channel.setTargetNode(targetNode));\n\t\t} else {\n\t\t\ttargetNode = parent;\n\t\t}\n\n\t\tconst nodeMatrix = targetNode.getMatrix();\n\t\tmultiplyMat4(nodeMatrix, nodeMatrix, transformMatrix);\n\t\ttargetNode.setMatrix(nodeMatrix);\n\t}\n}\n\n/** Applies corrective scale and offset to skin IBMs. */\nfunction transformSkin(skin: Skin, nodeTransform: VectorTransform<vec3>): Skin {\n\tskin = skin.clone(); // quantize() does cleanup.\n\tconst transformMatrix = fromTransform(nodeTransform);\n\tconst inverseBindMatrices = skin.getInverseBindMatrices()!.clone();\n\tconst ibm = [] as unknown as mat4;\n\tfor (let i = 0, count = inverseBindMatrices.getCount(); i < count; i++) {\n\t\tinverseBindMatrices.getElement(i, ibm);\n\t\tmultiplyMat4(ibm, ibm, transformMatrix);\n\t\tinverseBindMatrices.setElement(i, ibm);\n\t}\n\treturn skin.setInverseBindMatrices(inverseBindMatrices);\n}\n\n/** Applies corrective scale and offset to GPU instancing batches. */\nfunction transformBatch(batch: InstancedMesh, nodeTransform: VectorTransform<vec3>): InstancedMesh {\n\tif (!batch.getAttribute('TRANSLATION') && !batch.getAttribute('ROTATION') && !batch.getAttribute('SCALE')) {\n\t\treturn batch;\n\t}\n\n\tbatch = batch.clone(); // quantize() does cleanup.\n\tconst instanceTranslation = batch.getAttribute('TRANSLATION')?.clone();\n\tconst instanceRotation = batch.getAttribute('ROTATION')?.clone();\n\tconst instanceScale = batch.getAttribute('SCALE')?.clone();\n\tconst tpl = (instanceTranslation || instanceRotation || instanceScale)!;\n\n\tconst T_IDENTITY = [0, 0, 0] as vec3;\n\tconst R_IDENTITY = [0, 0, 0, 1] as vec4;\n\tconst S_IDENTITY = [1, 1, 1] as vec3;\n\n\tconst t = [0, 0, 0] as vec3;\n\tconst r = [0, 0, 0, 1] as vec4;\n\tconst s = [1, 1, 1] as vec3;\n\n\t// prettier-ignore\n\tconst instanceMatrix = [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\t] as mat4;\n\n\tconst transformMatrix = fromTransform(nodeTransform);\n\n\tfor (let i = 0, count = tpl.getCount(); i < count; i++) {\n\t\tMathUtils.compose(\n\t\t\tinstanceTranslation ? (instanceTranslation.getElement(i, t) as vec3) : T_IDENTITY,\n\t\t\tinstanceRotation ? (instanceRotation.getElement(i, r) as vec4) : R_IDENTITY,\n\t\t\tinstanceScale ? (instanceScale.getElement(i, s) as vec3) : S_IDENTITY,\n\t\t\tinstanceMatrix,\n\t\t);\n\n\t\tmultiplyMat4(instanceMatrix, instanceMatrix, transformMatrix);\n\n\t\tMathUtils.decompose(instanceMatrix, t, r, s);\n\n\t\tif (instanceTranslation) instanceTranslation.setElement(i, t);\n\t\tif (instanceRotation) instanceRotation.setElement(i, r);\n\t\tif (instanceScale) instanceScale.setElement(i, s);\n\t}\n\n\tif (instanceTranslation) batch.setAttribute('TRANSLATION', instanceTranslation);\n\tif (instanceRotation) batch.setAttribute('ROTATION', instanceRotation);\n\tif (instanceScale) batch.setAttribute('SCALE', instanceScale);\n\n\treturn batch;\n}\n\n/** Applies corrective scale to volumetric materials, which give thickness in local units. */\nfunction transformMeshMaterials(mesh: Mesh, scale: number) {\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tlet material = prim.getMaterial();\n\t\tif (!material) continue;\n\n\t\tlet volume = material.getExtension<Volume>('KHR_materials_volume');\n\t\tif (!volume || volume.getThicknessFactor() <= 0) continue;\n\n\t\t// quantize() does cleanup.\n\t\tvolume = volume.clone().setThicknessFactor(volume.getThicknessFactor() * scale);\n\t\tmaterial = material.clone().setExtension('KHR_materials_volume', volume);\n\t\tprim.setMaterial(material);\n\t}\n}\n\n/**\n * Quantizes an attribute to the given parameters.\n *\n * Uniformly remap 32-bit floats to reduced-precision 8- or 16-bit integers, so\n * that there are only 2^N unique values, for N within [8, 16].\n *\n * See: https://github.com/donmccurdy/glTF-Transform/issues/208\n */\nfunction quantizeAttribute(attribute: Accessor, ctor: TypedArrayConstructor, bits: number): void {\n\tconst dstArray = new ctor(attribute.getArray()!.length);\n\n\tconst signBits = SIGNED_INT.includes(ctor) ? 1 : 0;\n\tconst quantBits = bits - signBits;\n\tconst storageBits = ctor.BYTES_PER_ELEMENT * 8 - signBits;\n\n\tconst scale = Math.pow(2, quantBits) - 1;\n\tconst lo = storageBits - quantBits;\n\tconst hi = 2 * quantBits - storageBits;\n\tconst range = [signBits > 0 ? -1 : 0, 1] as vec2;\n\n\tfor (let i = 0, di = 0, el: number[] = []; i < attribute.getCount(); i++) {\n\t\tattribute.getElement(i, el);\n\t\tfor (let j = 0; j < el.length; j++) {\n\t\t\t// Clamp to range.\n\t\t\tlet value = clamp(el[j], range);\n\n\t\t\t// Map [0.0 ... 1.0] to [0 ... scale].\n\t\t\tvalue = Math.round(Math.abs(value) * scale);\n\n\t\t\t// Replicate msb to missing lsb.\n\t\t\tvalue = (value << lo) | (value >> hi);\n\n\t\t\t// Restore sign.\n\t\t\tdstArray[di++] = value * Math.sign(el[j]);\n\t\t}\n\t}\n\n\t// TODO(feat): Support sparse accessors, https://github.com/donmccurdy/glTF-Transform/issues/795\n\tattribute.setArray(dstArray).setNormalized(true).setSparse(false);\n}\n\nfunction getQuantizationSettings(\n\tsemantic: string,\n\tattribute: Accessor,\n\tlogger: ILogger,\n\toptions: Required<QuantizeOptions>,\n): { bits: number; ctor?: TypedArrayConstructor } {\n\tconst min = attribute.getMinNormalized([]);\n\tconst max = attribute.getMaxNormalized([]);\n\n\tlet bits: number;\n\tlet ctor: TypedArrayConstructor;\n\n\tif (semantic === 'POSITION') {\n\t\tbits = options.quantizePosition;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic === 'NORMAL' || semantic === 'TANGENT') {\n\t\tbits = options.quantizeNormal;\n\t\tctor = bits <= 8 ? Int8Array : Int16Array;\n\t} else if (semantic.startsWith('COLOR_')) {\n\t\tbits = options.quantizeColor;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('TEXCOORD_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeTexcoord;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('JOINTS_')) {\n\t\tbits = Math.max(...attribute.getMax([])) <= 255 ? 8 : 16;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t\tif (attribute.getComponentSize() > bits / 8) {\n\t\t\tattribute.setArray(new ctor(attribute.getArray()!));\n\t\t}\n\t\treturn { bits: -1 };\n\t} else if (semantic.startsWith('WEIGHTS_')) {\n\t\tif (min.some((v) => v < 0) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [0,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeWeight;\n\t\tctor = bits <= 8 ? Uint8Array : Uint16Array;\n\t} else if (semantic.startsWith('_')) {\n\t\tif (min.some((v) => v < -1) || max.some((v) => v > 1)) {\n\t\t\tlogger.warn(`${NAME}: Skipping ${semantic}; out of [-1,1] range.`);\n\t\t\treturn { bits: -1 };\n\t\t}\n\t\tbits = options.quantizeGeneric;\n\t\tctor = min.some((v) => v < 0)\n\t\t\t? (ctor = bits <= 8 ? Int8Array : Int16Array)\n\t\t\t: (ctor = bits <= 8 ? Uint8Array : Uint16Array);\n\t} else {\n\t\tthrow new Error(`${NAME}: Unexpected semantic, \"${semantic}\".`);\n\t}\n\n\treturn { bits, ctor };\n}\n\nfunction getPositionQuantizationVolume(mesh: Mesh): bbox {\n\tconst positions: Accessor[] = [];\n\tconst relativePositions: Accessor[] = [];\n\tfor (const prim of mesh.listPrimitives()) {\n\t\tconst attribute = prim.getAttribute('POSITION');\n\t\tif (attribute) positions.push(attribute);\n\t\tfor (const target of prim.listTargets()) {\n\t\t\tconst attribute = target.getAttribute('POSITION');\n\t\t\tif (attribute) relativePositions.push(attribute);\n\t\t}\n\t}\n\n\tif (positions.length === 0) {\n\t\tthrow new Error(`${NAME}: Missing \"POSITION\" attribute.`);\n\t}\n\n\tconst bbox = flatBounds<vec3>(positions, 3);\n\n\t// Morph target quantization volume is computed differently. First, ensure that the origin\n\t// <0, 0, 0> is in the quantization volume. Because we can't offset target positions (they're\n\t// relative deltas), default remapping will only map to a [-2, 2] AABB. Double the bounding box\n\t// to ensure scaling puts them within a [-1, 1] AABB instead.\n\tif (relativePositions.length > 0) {\n\t\tconst { min: relMin, max: relMax } = flatBounds<vec3>(relativePositions, 3);\n\t\tmin(bbox.min, bbox.min, min(relMin, scale(relMin, relMin, 2), [0, 0, 0]));\n\t\tmax(bbox.max, bbox.max, max(relMax, scale(relMax, relMax, 2), [0, 0, 0]));\n\t}\n\n\treturn bbox;\n}\n\nfunction isQuantizedAttribute(semantic: string, attribute: Accessor): boolean {\n\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview\n\tconst componentSize = attribute.getComponentSize();\n\tif (semantic === 'POSITION') return componentSize < 4;\n\tif (semantic === 'NORMAL') return componentSize < 4;\n\tif (semantic === 'TANGENT') return componentSize < 4;\n\tif (semantic.startsWith('TEXCOORD_')) {\n\t\tconst componentType = attribute.getComponentType();\n\t\tconst normalized = attribute.getNormalized();\n\t\treturn (\n\t\t\tcomponentSize < 4 &&\n\t\t\t!(normalized && componentType === Accessor.ComponentType.UNSIGNED_BYTE) &&\n\t\t\t!(normalized && componentType === Accessor.ComponentType.UNSIGNED_SHORT)\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction isQuantizedPrimitive(prim: Primitive | PrimitiveTarget): boolean {\n\tfor (const semantic of prim.listSemantics()) {\n\t\tconst attribute = prim.getAttribute('POSITION')!;\n\t\tif (isQuantizedAttribute(semantic, attribute)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (prim.propertyType === PropertyType.PRIMITIVE) {\n\t\treturn prim.listTargets().some(isQuantizedPrimitive);\n\t}\n\treturn false;\n}\n\n/** Computes total min and max of all Accessors in a list. */\nfunction flatBounds<T = vec2 | vec3>(accessors: Accessor[], elementSize: number): { min: T; max: T } {\n\tconst min: number[] = new Array(elementSize).fill(Infinity);\n\tconst max: number[] = new Array(elementSize).fill(-Infinity);\n\n\tconst tmpMin: number[] = [];\n\tconst tmpMax: number[] = [];\n\n\tfor (const accessor of accessors) {\n\t\taccessor.getMinNormalized(tmpMin);\n\t\taccessor.getMaxNormalized(tmpMax);\n\t\tfor (let i = 0; i < elementSize; i++) {\n\t\t\tmin[i] = Math.min(min[i], tmpMin[i]);\n\t\t\tmax[i] = Math.max(max[i], tmpMax[i]);\n\t\t}\n\t}\n\n\treturn { min, max } as unknown as { min: T; max: T };\n}\n\nfunction expandBounds(bboxes: bbox[]): bbox {\n\tconst result = bboxes[0];\n\tfor (const bbox of bboxes) {\n\t\tmin(result.min, result.min, bbox.min);\n\t\tmax(result.max, result.max, bbox.max);\n\t}\n\treturn result;\n}\n\ninterface VectorTransform<T = vec2 | vec3 | vec4> {\n\toffset: T;\n\tscale: number;\n}\n\nfunction fromTransform(transform: VectorTransform<vec3>): mat4 {\n\treturn fromRotationTranslationScale([] as unknown as mat4, [0, 0, 0, 1], transform.offset, [\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t\ttransform.scale,\n\t]) as mat4;\n}\n\nfunction clamp(value: number, range: vec2): number {\n\treturn Math.min(Math.max(value, range[0]), range[1]);\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { EXTMeshoptCompression } from '@gltf-transform/extensions';\nimport type { MeshoptEncoder } from 'meshoptimizer';\nimport { reorder } from './reorder.js';\nimport { QUANTIZE_DEFAULTS, QuantizeOptions, quantize } from './quantize.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nexport interface MeshoptOptions extends Omit<QuantizeOptions, 'pattern' | 'patternTargets'> {\n\tencoder: unknown;\n\tlevel?: 'medium' | 'high';\n}\n\nexport const MESHOPT_DEFAULTS: Required<Omit<MeshoptOptions, 'encoder'>> = {\n\tlevel: 'high',\n\t...QUANTIZE_DEFAULTS,\n};\n\nconst NAME = 'meshopt';\n\n/**\n * Applies Meshopt compression using {@link EXTMeshoptCompression EXT_meshopt_compression}.\n * This type of compression can reduce the size of point, line, and triangle geometry,\n * morph targets, and animation data.\n *\n * This function is a thin wrapper around {@link reorder}, {@link quantize}, and\n * {@link EXTMeshoptCompression}, and exposes relatively few configuration options.\n * To access more options (like quantization bits) direct use of the underlying\n * functions is recommended.\n *\n * Example:\n *\n * ```javascript\n * import { MeshoptEncoder } from 'meshoptimizer';\n * import { meshopt } from '@gltf-transform/functions';\n *\n * await MeshoptEncoder.ready;\n *\n * await document.transform(\n *   meshopt({encoder: MeshoptEncoder, level: 'medium'})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function meshopt(_options: MeshoptOptions): Transform {\n\tconst options = assignDefaults(MESHOPT_DEFAULTS, _options);\n\tconst encoder = options.encoder as typeof MeshoptEncoder | undefined;\n\n\tif (!encoder) {\n\t\tthrow new Error(`${NAME}: encoder dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tlet pattern: RegExp;\n\t\tlet patternTargets: RegExp;\n\t\tlet quantizeNormal = options.quantizeNormal;\n\n\t\tif (document.getRoot().listAccessors().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// IMPORTANT: Vertex attributes should be quantized in 'high' mode IFF they are\n\t\t// _not_ filtered in 'packages/extensions/src/ext-meshopt-compression/encoder.ts'.\n\t\t// Note that normals and tangents use octahedral filters, but _morph_ normals\n\t\t// and tangents do not.\n\t\t// See: https://github.com/donmccurdy/glTF-Transform/issues/1142\n\t\tif (options.level === 'medium') {\n\t\t\tpattern = /.*/;\n\t\t\tpatternTargets = /.*/;\n\t\t} else {\n\t\t\tpattern = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR)(_\\d+)?$/;\n\t\t\tpatternTargets = /^(POSITION|TEXCOORD|JOINTS|WEIGHTS|COLOR|NORMAL|TANGENT)(_\\d+)?$/;\n\t\t\tquantizeNormal = Math.min(quantizeNormal, 8); // See meshopt::getMeshoptFilter.\n\t\t}\n\n\t\tawait document.transform(\n\t\t\treorder({\n\t\t\t\tencoder: encoder,\n\t\t\t\ttarget: 'size',\n\t\t\t}),\n\t\t\tquantize({\n\t\t\t\t...options,\n\t\t\t\tpattern,\n\t\t\t\tpatternTargets,\n\t\t\t\tquantizeNormal,\n\t\t\t}),\n\t\t);\n\n\t\tdocument\n\t\t\t.createExtension(EXTMeshoptCompression)\n\t\t\t.setRequired(true)\n\t\t\t.setEncoderOptions({\n\t\t\t\tmethod:\n\t\t\t\t\toptions.level === 'medium'\n\t\t\t\t\t\t? EXTMeshoptCompression.EncoderMethod.QUANTIZE\n\t\t\t\t\t\t: EXTMeshoptCompression.EncoderMethod.FILTER,\n\t\t\t});\n\t});\n}\n", "import type { Document, Texture, Transform } from '@gltf-transform/core';\nimport {\n\tKHRMaterialsIOR,\n\tKHRMaterialsPBRSpecularGlossiness,\n\tKHRMaterialsSpecular,\n\tPBRSpecularGlossiness,\n} from '@gltf-transform/extensions';\nimport { createTransform, rewriteTexture } from './utils.js';\n\nconst NAME = 'metalRough';\n\nexport interface MetalRoughOptions {}\n\nconst METALROUGH_DEFAULTS: Required<MetalRoughOptions> = {};\n\n/**\n * Convert {@link Material}s from spec/gloss PBR workflow to metal/rough PBR workflow,\n * removing `KHR_materials_pbrSpecularGlossiness` and adding `KHR_materials_ior` and\n * `KHR_materials_specular`. The metal/rough PBR workflow is preferred for most use cases,\n * and is a prerequisite for other advanced PBR extensions provided by glTF.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function metalRough(_options: MetalRoughOptions = METALROUGH_DEFAULTS): Transform {\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst extensionsUsed = doc\n\t\t\t.getRoot()\n\t\t\t.listExtensionsUsed()\n\t\t\t.map((ext) => ext.extensionName);\n\t\tif (!extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness')) {\n\t\t\tlogger.warn(`${NAME}: KHR_materials_pbrSpecularGlossiness not found on document.`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst iorExtension = doc.createExtension(KHRMaterialsIOR);\n\t\tconst specExtension = doc.createExtension(KHRMaterialsSpecular);\n\t\tconst specGlossExtension = doc.createExtension(KHRMaterialsPBRSpecularGlossiness);\n\n\t\tconst inputTextures = new Set<Texture | null>();\n\n\t\tfor (const material of doc.getRoot().listMaterials()) {\n\t\t\tconst specGloss = material.getExtension<PBRSpecularGlossiness>('KHR_materials_pbrSpecularGlossiness');\n\t\t\tif (!specGloss) continue;\n\n\t\t\t// Create specular extension.\n\t\t\tconst specular = specExtension\n\t\t\t\t.createSpecular()\n\t\t\t\t.setSpecularFactor(1.0)\n\t\t\t\t.setSpecularColorFactor(specGloss.getSpecularFactor());\n\n\t\t\t// Stash textures that might become unused, to check and clean up later.\n\t\t\tinputTextures.add(specGloss.getSpecularGlossinessTexture());\n\t\t\tinputTextures.add(material.getBaseColorTexture());\n\t\t\tinputTextures.add(material.getMetallicRoughnessTexture());\n\n\t\t\t// Set up a metal/rough PBR material with IOR=Infinity (or 0), metallic=0. This\n\t\t\t// representation is precise and reliable, but perhaps less convenient for artists\n\t\t\t// than deriving a metalness value. Unfortunately we can't do that without imprecise\n\t\t\t// heuristics, and perhaps user tuning.\n\t\t\t// See: https://github.com/KhronosGroup/glTF/pull/1719#issuecomment-674365677\n\t\t\tmaterial\n\t\t\t\t.setBaseColorFactor(specGloss.getDiffuseFactor())\n\t\t\t\t.setMetallicFactor(0)\n\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t.setExtension('KHR_materials_ior', iorExtension.createIOR().setIOR(1000))\n\t\t\t\t.setExtension('KHR_materials_specular', specular);\n\n\t\t\t// Move diffuse -> baseColor.\n\t\t\tconst diffuseTexture = specGloss.getDiffuseTexture();\n\t\t\tif (diffuseTexture) {\n\t\t\t\tmaterial.setBaseColorTexture(diffuseTexture);\n\t\t\t\tmaterial.getBaseColorTextureInfo()!.copy(specGloss.getDiffuseTextureInfo()!);\n\t\t\t}\n\n\t\t\t// Move specular + gloss -> specular + roughness.\n\t\t\tconst sgTexture = specGloss.getSpecularGlossinessTexture();\n\t\t\tif (sgTexture) {\n\t\t\t\t// specularGlossiness -> specular.\n\t\t\t\tconst sgTextureInfo = specGloss.getSpecularGlossinessTextureInfo()!;\n\t\t\t\tconst specularTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, specularTexture, (pixels, i, j) => {\n\t\t\t\t\tpixels.set(i, j, 3, 255); // Remove glossiness.\n\t\t\t\t});\n\t\t\t\tspecular.setSpecularTexture(specularTexture);\n\t\t\t\tspecular.setSpecularColorTexture(specularTexture);\n\t\t\t\tspecular.getSpecularTextureInfo()!.copy(sgTextureInfo);\n\t\t\t\tspecular.getSpecularColorTextureInfo()!.copy(sgTextureInfo);\n\n\t\t\t\t// specularGlossiness -> roughness.\n\t\t\t\tconst glossinessFactor = specGloss.getGlossinessFactor();\n\t\t\t\tconst metalRoughTexture = doc.createTexture();\n\t\t\t\tawait rewriteTexture(sgTexture, metalRoughTexture, (pixels, i, j) => {\n\t\t\t\t\t// Invert glossiness.\n\t\t\t\t\tconst roughness = 255 - Math.round(pixels.get(i, j, 3) * glossinessFactor);\n\t\t\t\t\tpixels.set(i, j, 0, 0);\n\t\t\t\t\tpixels.set(i, j, 1, roughness);\n\t\t\t\t\tpixels.set(i, j, 2, 0);\n\t\t\t\t\tpixels.set(i, j, 3, 255);\n\t\t\t\t});\n\t\t\t\tmaterial.setMetallicRoughnessTexture(metalRoughTexture);\n\t\t\t\tmaterial.getMetallicRoughnessTextureInfo()!.copy(sgTextureInfo);\n\t\t\t} else {\n\t\t\t\tspecular.setSpecularColorFactor(specGloss.getSpecularFactor());\n\t\t\t\tmaterial.setRoughnessFactor(1 - specGloss.getGlossinessFactor());\n\t\t\t}\n\n\t\t\t// Remove KHR_materials_pbrSpecularGlossiness from the material.\n\t\t\tmaterial.setExtension('KHR_materials_pbrSpecularGlossiness', null);\n\t\t}\n\n\t\t// Remove KHR_materials_pbrSpecularGlossiness from the document.\n\t\tspecGlossExtension.dispose();\n\n\t\t// Clean up unused textures.\n\t\tfor (const tex of inputTextures) {\n\t\t\tif (tex && tex.listParents().length === 1) tex.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { Accessor, Document, Primitive, Transform, TypedArrayConstructor } from '@gltf-transform/core';\nimport { createTransform, formatDeltaOp, shallowCloneAccessor } from './utils.js';\n\nconst NAME = 'unweld';\n\n/** Options for the {@link unweld} function. */\nexport interface UnweldOptions {}\n\nconst UNWELD_DEFAULTS: UnweldOptions = {};\n\n/**\n * De-index {@link Primitive}s, disconnecting any shared vertices. This operation will generally\n * increase the number of vertices in a mesh, but may be helpful for some geometry operations or\n * for creating hard edges.\n *\n * No options are currently implemented for this function.\n *\n * @category Transforms\n */\nexport function unweld(_options: UnweldOptions = UNWELD_DEFAULTS): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst visited = new Map<Accessor, Map<Accessor, Accessor>>();\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tunweldPrimitive(prim, visited);\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * @hidden\n * @internal\n */\nexport function unweldPrimitive(prim: Primitive, visited = new Map<Accessor, Map<Accessor, Accessor>>()): void {\n\tconst indices = prim.getIndices();\n\tif (!indices) return;\n\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\n\tconst srcVertexCount = prim.getAttribute('POSITION')!.getCount();\n\n\t// Vertex attributes.\n\tfor (const srcAttribute of prim.listAttributes()) {\n\t\tprim.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n\n\t\t// Clean up.\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\t// Morph target vertex attributes.\n\tfor (const target of prim.listTargets()) {\n\t\tfor (const srcAttribute of target.listAttributes()) {\n\t\t\ttarget.swap(srcAttribute, unweldAttribute(document, srcAttribute, indices, visited));\n\n\t\t\t// Clean up.\n\t\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t\t}\n\t}\n\n\tconst dstVertexCount = prim.getAttribute('POSITION')!.getCount();\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices.`);\n\n\t// Clean up.\n\tprim.setIndices(null);\n\tif (indices.listParents().length === 1) indices.dispose();\n}\n\nfunction unweldAttribute(\n\tdocument: Document,\n\tsrcAttribute: Accessor,\n\tindices: Accessor,\n\tvisited: Map<Accessor, Map<Accessor, Accessor>>,\n): Accessor {\n\tif (visited.has(srcAttribute) && visited.get(srcAttribute)!.has(indices)) {\n\t\treturn visited.get(srcAttribute)!.get(indices)!;\n\t}\n\n\tconst srcArray = srcAttribute.getArray()!;\n\tconst TypedArray = srcArray.constructor as TypedArrayConstructor;\n\tconst dstArray = new TypedArray(indices.getCount() * srcAttribute.getElementSize());\n\n\tconst indicesArray = indices.getArray()!;\n\tconst elementSize = srcAttribute.getElementSize();\n\tfor (let i = 0, il = indices.getCount(); i < il; i++) {\n\t\tfor (let j = 0; j < elementSize; j++) {\n\t\t\tdstArray[i * elementSize + j] = srcArray[indicesArray[i] * elementSize + j];\n\t\t}\n\t}\n\n\tif (!visited.has(srcAttribute)) visited.set(srcAttribute, new Map());\n\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute).setArray(dstArray);\n\tvisited.get(srcAttribute)!.set(indices, dstAttribute);\n\n\treturn dstAttribute;\n}\n", "import type { Document, Transform, vec3 } from '@gltf-transform/core';\nimport { unweld } from './unweld.js';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { normalize } from 'gl-matrix/vec3';\n\nconst NAME = 'normals';\n\n/** Options for the {@link normals} function. */\nexport interface NormalsOptions {\n\t/** Whether to overwrite existing `NORMAL` attributes. */\n\toverwrite?: boolean;\n}\n\nconst NORMALS_DEFAULTS: Required<NormalsOptions> = {\n\toverwrite: false,\n};\n\n/**\n * Generates flat vertex normals for mesh primitives.\n *\n * Example:\n *\n * ```ts\n * import { normals } from '@gltf-transform/functions';\n *\n * await document.transform(normals({overwrite: true}));\n * ```\n *\n * @category Transforms\n */\nexport function normals(_options: NormalsOptions = NORMALS_DEFAULTS): Transform {\n\tconst options = assignDefaults(NORMALS_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tlet modified = 0;\n\n\t\tawait document.transform(unweld());\n\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\t\tlet normal = prim.getAttribute('NORMAL');\n\n\t\t\t\tif (options.overwrite && normal) {\n\t\t\t\t\tnormal.dispose();\n\t\t\t\t} else if (normal) {\n\t\t\t\t\tlogger.debug(`${NAME}: Skipping primitive: NORMAL found.`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnormal = document\n\t\t\t\t\t.createAccessor()\n\t\t\t\t\t.setArray(new Float32Array(position.getCount() * 3))\n\t\t\t\t\t.setType('VEC3');\n\n\t\t\t\tconst a = [0, 0, 0] as vec3;\n\t\t\t\tconst b = [0, 0, 0] as vec3;\n\t\t\t\tconst c = [0, 0, 0] as vec3;\n\n\t\t\t\tfor (let i = 0; i < position.getCount(); i += 3) {\n\t\t\t\t\tposition.getElement(i + 0, a);\n\t\t\t\t\tposition.getElement(i + 1, b);\n\t\t\t\t\tposition.getElement(i + 2, c);\n\n\t\t\t\t\tconst faceNormal = computeNormal(a, b, c);\n\n\t\t\t\t\tnormal.setElement(i + 0, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 1, faceNormal);\n\t\t\t\t\tnormal.setElement(i + 2, faceNormal);\n\t\t\t\t}\n\n\t\t\t\tprim.setAttribute('NORMAL', normal);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\n// https://stackoverflow.com/a/23709352/1314762\nfunction computeNormal(a: vec3, b: vec3, c: vec3): vec3 {\n\tconst A = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];\n\tconst B = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];\n\tconst n = [\n\t\tA[1] * B[2] - A[2] * B[1], //\n\t\tA[2] * B[0] - A[0] * B[2],\n\t\tA[0] * B[1] - A[1] * B[0],\n\t] as vec3;\n\treturn normalize([0, 0, 0], n) as vec3;\n}\n", "import {\n\tColorUtils,\n\tDocument,\n\tMaterial,\n\tPrimitive,\n\tPropertyType,\n\tTexture,\n\tTextureInfo,\n\tTransform,\n\tvec4,\n} from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { prune } from './prune.js';\nimport ndarray, { NdArray, TypedArray } from 'ndarray';\nimport { savePixels } from 'ndarray-pixels';\n\nconst NAME = 'palette';\n\ntype TexturableProp = 'baseColor' | 'emissive' | 'metallicRoughness';\n\nexport interface PaletteOptions {\n\t/** Size (in pixels) of a single block within each palette texture. Default: 4. */\n\tblockSize?: number;\n\t/**\n\t * Minimum number of blocks in the palette texture. If fewer unique\n\t * material values are found, no palettes will be generated. Default: 5.\n\t */\n\tmin?: number;\n\t/**\n\t * Whether to keep unused vertex attributes, such as UVs without an assigned\n\t * texture. If kept, unused UV coordinates may prevent palette texture\n\t * creation. Default: false.\n\t */\n\tkeepAttributes?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const PALETTE_DEFAULTS: Required<PaletteOptions> = {\n\tblockSize: 4,\n\tmin: 5,\n\tkeepAttributes: false,\n\tcleanup: true,\n};\n\n/**\n * Creates palette textures containing all unique values of scalar\n * {@link Material} properties within the scene, then merges materials. For\n * scenes with many solid-colored materials (often found in CAD, architectural,\n * or low-poly styles), texture palettes can reduce the number of materials\n * used, and significantly increase the number of {@link Mesh} objects eligible\n * for {@link join} operations.\n *\n * Materials already containing texture coordinates (UVs) are not eligible for\n * texture palette optimizations. Currently only a material's base color,\n * alpha, emissive factor, metallic factor, and roughness factor are converted\n * to palette textures.\n *\n * Example:\n *\n * ```typescript\n * import { palette, flatten, dequantize, join } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \tpalette({ min: 5 }),\n * \tflatten(),\n * \tdequantize(),\n * \tjoin()\n * );\n * ```\n *\n * The illustration below shows a typical base color palette texture:\n *\n * <img\n * \tsrc=\"/media/functions/palette.png\"\n * \talt=\"Row of colored blocks\"\n * \tstyle=\"width: 100%; max-width: 320px; image-rendering: pixelated;\">\n *\n * @category Transforms\n */\nexport function palette(_options: PaletteOptions = PALETTE_DEFAULTS): Transform {\n\tconst options = assignDefaults(PALETTE_DEFAULTS, _options);\n\tconst blockSize = Math.max(options.blockSize, 1);\n\tconst min = Math.max(options.min, 1);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst root = document.getRoot();\n\n\t\t// Find and remove unused TEXCOORD_n attributes.\n\t\tif (!options.keepAttributes) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR],\n\t\t\t\t\tkeepAttributes: false,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tconst prims = new Set<Primitive>();\n\t\tconst materials = new Set<Material>();\n\n\t\t// (1) Gather list of eligible prims and materials.\n\n\t\tfor (const mesh of root.listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst material = prim.getMaterial();\n\t\t\t\tif (!material || !!prim.getAttribute('TEXCOORD_0')) continue;\n\n\t\t\t\tprims.add(prim);\n\t\t\t\tmaterials.add(material);\n\t\t\t}\n\t\t}\n\n\t\t// (2) Gather list of distinct material properties.\n\n\t\tconst materialKeys = new Set<string>();\n\t\tconst materialKeyMap = new Map<Material, string>();\n\t\tconst materialProps: Record<TexturableProp, Set<string>> = {\n\t\t\tbaseColor: new Set<string>(),\n\t\t\temissive: new Set<string>(),\n\t\t\tmetallicRoughness: new Set<string>(),\n\t\t};\n\n\t\tfor (const material of materials) {\n\t\t\tconst baseColor = encodeRGBA(material.getBaseColorFactor().slice() as vec4);\n\t\t\tconst emissive = encodeRGBA([...material.getEmissiveFactor(), 1]);\n\t\t\tconst roughness = encodeFloat(material.getRoughnessFactor());\n\t\t\tconst metallic = encodeFloat(material.getMetallicFactor());\n\t\t\tconst key = `baseColor:${baseColor},emissive:${emissive},metallicRoughness:${metallic}${roughness}`;\n\t\t\tmaterialProps.baseColor.add(baseColor);\n\t\t\tmaterialProps.emissive.add(emissive);\n\t\t\tmaterialProps.metallicRoughness.add(metallic + '+' + roughness);\n\t\t\tmaterialKeys.add(key);\n\t\t\tmaterialKeyMap.set(material, key);\n\t\t}\n\n\t\t// logger.debug(`${NAME}:\\n${Array.from(materialKeys.values()).join('\\n')}`);\n\n\t\tconst keyCount = materialKeys.size;\n\t\tif (keyCount < min) {\n\t\t\tlogger.debug(`${NAME}: Found <${min} unique material properties. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (3) Allocate palette textures.\n\n\t\tconst w = ceilPowerOfTwo(keyCount * blockSize);\n\t\tconst h = ceilPowerOfTwo(blockSize);\n\t\tconst padWidth = w - keyCount * blockSize;\n\n\t\tconst paletteTexturePixels: Record<TexturableProp, NdArray<Uint8Array> | null> = {\n\t\t\tbaseColor: null,\n\t\t\temissive: null,\n\t\t\tmetallicRoughness: null,\n\t\t};\n\n\t\t// Properties skipped for material equality comparisons.\n\t\tconst skipProps = new Set(['name', 'extras']);\n\t\tconst skip = (...props: string[]) => props.forEach((prop) => skipProps.add(prop));\n\n\t\tlet baseColorTexture: Texture | null = null;\n\t\tlet emissiveTexture: Texture | null = null;\n\t\tlet metallicRoughnessTexture: Texture | null = null;\n\n\t\tif (materialProps.baseColor.size >= min) {\n\t\t\tconst name = 'PaletteBaseColor';\n\t\t\tbaseColorTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.baseColor = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('baseColorFactor', 'baseColorTexture', 'baseColorTextureInfo');\n\t\t}\n\t\tif (materialProps.emissive.size >= min) {\n\t\t\tconst name = 'PaletteEmissive';\n\t\t\temissiveTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.emissive = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('emissiveFactor', 'emissiveTexture', 'emissiveTextureInfo');\n\t\t}\n\t\tif (materialProps.metallicRoughness.size >= min) {\n\t\t\tconst name = 'PaletteMetallicRoughness';\n\t\t\tmetallicRoughnessTexture = document.createTexture(name).setURI(`${name}.png`);\n\t\t\tpaletteTexturePixels.metallicRoughness = ndarray(new Uint8Array(w * h * 4), [w, h, 4]);\n\t\t\tskip('metallicFactor', 'roughnessFactor', 'metallicRoughnessTexture', 'metallicRoughnessTextureInfo');\n\t\t}\n\n\t\tif (!(baseColorTexture || emissiveTexture || metallicRoughnessTexture)) {\n\t\t\tlogger.debug(`${NAME}: No material property has >=${min} unique values. Exiting.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// (4) Write blocks to palette textures.\n\n\t\tconst visitedKeys = new Set<string>();\n\t\tconst materialIndices = new Map<string, number>();\n\t\tconst paletteMaterials: Material[] = [];\n\n\t\tlet nextIndex = 0;\n\t\tfor (const material of materials) {\n\t\t\tconst key = materialKeyMap.get(material)!;\n\t\t\tif (visitedKeys.has(key)) continue;\n\n\t\t\tconst index = nextIndex++;\n\n\t\t\tif (paletteTexturePixels.baseColor) {\n\t\t\t\tconst pixels = paletteTexturePixels.baseColor;\n\t\t\t\tconst baseColor = [...material.getBaseColorFactor()] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(baseColor, baseColor);\n\t\t\t\twriteBlock(pixels, index, baseColor, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.emissive) {\n\t\t\t\tconst pixels = paletteTexturePixels.emissive;\n\t\t\t\tconst emissive = [...material.getEmissiveFactor(), 1] as vec4;\n\t\t\t\tColorUtils.convertLinearToSRGB(emissive, emissive);\n\t\t\t\twriteBlock(pixels, index, emissive, blockSize);\n\t\t\t}\n\t\t\tif (paletteTexturePixels.metallicRoughness) {\n\t\t\t\tconst pixels = paletteTexturePixels.metallicRoughness;\n\t\t\t\tconst metallic = material.getMetallicFactor();\n\t\t\t\tconst roughness = material.getRoughnessFactor();\n\t\t\t\twriteBlock(pixels, index, [0, roughness, metallic, 1], blockSize);\n\t\t\t}\n\n\t\t\tvisitedKeys.add(key);\n\t\t\tmaterialIndices.set(key, index);\n\t\t}\n\n\t\t// (5) Compress palette textures and assign to palette materials.\n\n\t\tconst mimeType = 'image/png';\n\n\t\tif (baseColorTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.baseColor!, mimeType);\n\t\t\tbaseColorTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (emissiveTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.emissive!, mimeType);\n\t\t\temissiveTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\t\tif (metallicRoughnessTexture) {\n\t\t\tconst image = await savePixels(paletteTexturePixels.metallicRoughness!, mimeType);\n\t\t\tmetallicRoughnessTexture.setImage(image).setMimeType(mimeType);\n\t\t}\n\n\t\t// (6) Create palette materials, generate UVs, and assign both to prims.\n\n\t\tlet nextPaletteMaterialIndex = 1;\n\t\tfor (const prim of prims) {\n\t\t\tconst srcMaterial = prim.getMaterial()!;\n\t\t\tconst key = materialKeyMap.get(srcMaterial)!;\n\t\t\tconst blockIndex = materialIndices.get(key)!;\n\n\t\t\t// UVs are centered horizontally in each block, descending vertically\n\t\t\t// to form a diagonal line in the UV layout. Easy and compressible.\n\t\t\tconst baseUV = (blockIndex + 0.5) / keyCount;\n\t\t\tconst padUV = (baseUV * (w - padWidth)) / w;\n\n\t\t\tconst position = prim.getAttribute('POSITION')!;\n\t\t\tconst buffer = position.getBuffer();\n\t\t\tconst array = new Float32Array(position.getCount() * 2).fill(padUV);\n\t\t\tconst uv = document.createAccessor().setType('VEC2').setArray(array).setBuffer(buffer);\n\n\t\t\tlet dstMaterial;\n\t\t\tfor (const material of paletteMaterials) {\n\t\t\t\tif (material.equals(srcMaterial, skipProps)) {\n\t\t\t\t\tdstMaterial = material;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dstMaterial) {\n\t\t\t\tconst suffix = (nextPaletteMaterialIndex++).toString().padStart(3, '0');\n\t\t\t\tdstMaterial = srcMaterial.clone().setName(`PaletteMaterial${suffix}`);\n\n\t\t\t\tif (baseColorTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setBaseColorFactor([1, 1, 1, 1])\n\t\t\t\t\t\t.setBaseColorTexture(baseColorTexture)\n\t\t\t\t\t\t.getBaseColorTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (emissiveTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setEmissiveFactor([1, 1, 1])\n\t\t\t\t\t\t.setEmissiveTexture(emissiveTexture)\n\t\t\t\t\t\t.getEmissiveTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\t\t\t\tif (metallicRoughnessTexture) {\n\t\t\t\t\tdstMaterial\n\t\t\t\t\t\t.setMetallicFactor(1)\n\t\t\t\t\t\t.setRoughnessFactor(1)\n\t\t\t\t\t\t.setMetallicRoughnessTexture(metallicRoughnessTexture)\n\t\t\t\t\t\t.getMetallicRoughnessTextureInfo()!\n\t\t\t\t\t\t.setMinFilter(TextureInfo.MinFilter.NEAREST)\n\t\t\t\t\t\t.setMagFilter(TextureInfo.MagFilter.NEAREST);\n\t\t\t\t}\n\n\t\t\t\tpaletteMaterials.push(dstMaterial);\n\t\t\t}\n\n\t\t\tprim.setMaterial(dstMaterial).setAttribute('TEXCOORD_0', uv);\n\t\t}\n\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(prune({ propertyTypes: [PropertyType.MATERIAL] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Encodes a floating-point value on the interval [0,1] at 8-bit precision. */\nfunction encodeFloat(value: number): string {\n\tconst hex = Math.round(value * 255).toString(16);\n\treturn hex.length === 1 ? '0' + hex : hex;\n}\n\n/** Encodes an RGBA color in Linear-sRGB-D65 color space. */\nfunction encodeRGBA(value: vec4): string {\n\tColorUtils.convertLinearToSRGB(value, value);\n\treturn value.map(encodeFloat).join('');\n}\n\n/** Returns the nearest higher power of two. */\nfunction ceilPowerOfTwo(value: number): number {\n\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\n/** Writes an NxN block of pixels to an image, at the given block index. */\nfunction writeBlock(pixels: NdArray<TypedArray>, index: number, value: vec4, blockSize: number): void {\n\tfor (let i = 0; i < blockSize; i++) {\n\t\tfor (let j = 0; j < blockSize; j++) {\n\t\t\tpixels.set(index * blockSize + i, j, 0, value[0] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 1, value[1] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 2, value[2] * 255);\n\t\t\tpixels.set(index * blockSize + i, j, 3, value[3] * 255);\n\t\t}\n\t}\n}\n", "import { Document, ILogger, PropertyType, Transform } from '@gltf-transform/core';\nimport { prune } from './prune.js';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'partition';\n\nexport interface PartitionOptions {\n\tanimations?: boolean | Array<string>;\n\tmeshes?: boolean | Array<string>;\n}\n\nconst PARTITION_DEFAULTS: Required<PartitionOptions> = {\n\tanimations: true,\n\tmeshes: true,\n};\n\n/**\n * Partitions the binary payload of a glTF file so separate mesh or animation data is in separate\n * `.bin` {@link Buffer}s. This technique may be useful for engines that support lazy-loading\n * specific binary resources as needed over the application lifecycle.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); //  [Buffer]\n *\n * await document.transform(partition({meshes: true}));\n *\n * document.getRoot().listBuffers(); //  [Buffer, Buffer, ...]\n * ```\n *\n * @category Transforms\n */\nexport function partition(_options: PartitionOptions = PARTITION_DEFAULTS): Transform {\n\tconst options = assignDefaults(PARTITION_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (doc: Document): Promise<void> => {\n\t\tconst logger = doc.getLogger();\n\n\t\tif (options.meshes !== false) partitionMeshes(doc, logger, options);\n\t\tif (options.animations !== false) partitionAnimations(doc, logger, options);\n\n\t\tif (!options.meshes && !options.animations) {\n\t\t\tlogger.warn(`${NAME}: Select animations or meshes to create a partition.`);\n\t\t}\n\n\t\tawait doc.transform(prune({ propertyTypes: [PropertyType.BUFFER] }));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\nfunction partitionMeshes(doc: Document, logger: ILogger, options: Required<PartitionOptions>): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI()),\n\t);\n\n\tdoc.getRoot()\n\t\t.listMeshes()\n\t\t.forEach((mesh, meshIndex) => {\n\t\t\tif (Array.isArray(options.meshes) && !options.meshes.includes(mesh.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping mesh #${meshIndex} with name \"${mesh.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for mesh \"${mesh.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(mesh.getName())\n\t\t\t\t.setURI(createBufferURI(mesh.getName() || 'mesh', existingURIs));\n\n\t\t\tmesh.listPrimitives().forEach((primitive) => {\n\t\t\t\tconst indices = primitive.getIndices();\n\t\t\t\tif (indices) indices.setBuffer(buffer);\n\t\t\t\tprimitive.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\tprimitive.listTargets().forEach((primTarget) => {\n\t\t\t\t\tprimTarget.listAttributes().forEach((attribute) => attribute.setBuffer(buffer));\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction partitionAnimations(doc: Document, logger: ILogger, options: Required<PartitionOptions>): void {\n\tconst existingURIs = new Set<string>(\n\t\tdoc\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.map((b) => b.getURI()),\n\t);\n\n\tdoc.getRoot()\n\t\t.listAnimations()\n\t\t.forEach((anim, animIndex) => {\n\t\t\tif (Array.isArray(options.animations) && !options.animations.includes(anim.getName())) {\n\t\t\t\tlogger.debug(`${NAME}: Skipping animation #${animIndex} with name \"${anim.getName()}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`${NAME}: Creating buffer for animation \"${anim.getName()}\".`);\n\n\t\t\tconst buffer = doc\n\t\t\t\t.createBuffer(anim.getName())\n\t\t\t\t.setURI(createBufferURI(anim.getName() || 'animation', existingURIs));\n\n\t\t\tanim.listSamplers().forEach((sampler) => {\n\t\t\t\tconst input = sampler.getInput();\n\t\t\t\tconst output = sampler.getOutput();\n\t\t\t\tif (input) input.setBuffer(buffer);\n\t\t\t\tif (output) output.setBuffer(buffer);\n\t\t\t});\n\t\t});\n}\n\nconst SANITIZE_BASENAME_RE = /[^\\w09-]+/g;\n\nfunction createBufferURI(basename: string, existing: Set<string>): string {\n\tbasename = basename.replace(SANITIZE_BASENAME_RE, '');\n\tlet uri = `${basename}.bin`;\n\tlet i = 1;\n\twhile (existing.has(uri)) uri = `${basename}_${i++}.bin`;\n\texisting.add(uri);\n\treturn uri;\n}\n", "var InterpolationInternal;\n\n(function (InterpolationInternal) {\n  InterpolationInternal[InterpolationInternal[\"STEP\"] = 0] = \"STEP\";\n  InterpolationInternal[InterpolationInternal[\"LERP\"] = 1] = \"LERP\";\n  InterpolationInternal[InterpolationInternal[\"SLERP\"] = 2] = \"SLERP\";\n})(InterpolationInternal || (InterpolationInternal = {}));\n\nconst TO_INTERPOLATION_INTERNAL = {\n  step: InterpolationInternal.STEP,\n  lerp: InterpolationInternal.LERP,\n  slerp: InterpolationInternal.SLERP\n};\nconst EPSILON = 0.000001;\n\n/* Implementation */\n\nfunction resampleDebug(input, output, interpolation, tolerance = 1e-4) {\n  const elementSize = output.length / input.length;\n  const tmp = new Array(elementSize).fill(0);\n  const value = new Array(elementSize).fill(0);\n  const valueNext = new Array(elementSize).fill(0);\n  const valuePrev = new Array(elementSize).fill(0);\n  const lastIndex = input.length - 1;\n  let writeIndex = 1;\n\n  for (let i = 1; i < lastIndex; ++i) {\n    const timePrev = input[writeIndex - 1];\n    const time = input[i];\n    const timeNext = input[i + 1];\n    const t = (time - timePrev) / (timeNext - timePrev);\n    let keep = false; // Remove unnecessary adjacent keyframes.\n\n    if (time !== timeNext && (i !== 1 || time !== input[0])) {\n      getElement(output, writeIndex - 1, valuePrev);\n      getElement(output, i, value);\n      getElement(output, i + 1, valueNext);\n\n      if (interpolation === 'slerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = slerp(tmp, valuePrev, valueNext, t);\n        const angle = getAngle(valuePrev, value) + getAngle(value, valueNext);\n        keep = !eq(value, sample, tolerance) || angle + Number.EPSILON >= Math.PI;\n      } else if (interpolation === 'lerp') {\n        // Prune keyframes colinear with prev/next keyframes.\n        const sample = vlerp(tmp, valuePrev, valueNext, t);\n        keep = !eq(value, sample, tolerance);\n      } else if (interpolation === 'step') {\n        // Prune keyframes identical to prev/next keyframes.\n        keep = !eq(value, valuePrev) || !eq(value, valueNext);\n      }\n    } // In-place compaction.\n\n\n    if (keep) {\n      if (i !== writeIndex) {\n        input[writeIndex] = input[i];\n        setElement(output, writeIndex, getElement(output, i, tmp));\n      }\n\n      writeIndex++;\n    }\n  } // Flush last keyframe (compaction looks ahead).\n\n\n  if (lastIndex > 0) {\n    input[writeIndex] = input[lastIndex];\n    setElement(output, writeIndex, getElement(output, lastIndex, tmp));\n    writeIndex++;\n  }\n\n  return writeIndex;\n}\n/* Utilities */\n\nfunction getElement(array, index, target) {\n  for (let i = 0, elementSize = target.length; i < elementSize; i++) {\n    target[i] = array[index * elementSize + i];\n  }\n\n  return target;\n}\n\nfunction setElement(array, index, value) {\n  for (let i = 0, elementSize = value.length; i < elementSize; i++) {\n    array[index * elementSize + i] = value[i];\n  }\n}\n\nfunction eq(a, b, tolerance = 0) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (Math.abs(a[i] - b[i]) > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lerp(v0, v1, t) {\n  return v0 * (1 - t) + v1 * t;\n}\n\nfunction vlerp(out, a, b, t) {\n  for (let i = 0; i < a.length; i++) out[i] = lerp(a[i], b[i], t);\n\n  return out;\n} // From gl-matrix.\n\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\nfunction getAngle(a, b) {\n  const dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/** WASM loader for Web environments. */\nconst wasm = /* #__PURE__ */fetch( /* #__PURE__ */new URL('./release.wasm', import.meta.url)).then(response => response.arrayBuffer()).then(buffer => new Uint8Array(buffer));\n\n// SETUP\n///////////////////////////////////////////////////////////////////////////////\n\nlet exports;\nconst ready = /* #__PURE__ */new Promise(async (resolve, reject) => {\n  try {\n    const module = await WebAssembly.compile(await wasm);\n    exports = await instantiate(module, {});\n    resolve();\n  } catch (e) {\n    reject(e);\n  }\n});\n\nasync function instantiate(module, imports = {}) {\n  const instance = await WebAssembly.instantiate(module, {\n    env: Object.assign(Object.create(globalThis), {}, {\n      abort: __abort\n    })\n  });\n  return instance.exports;\n} ///////////////////////////////////////////////////////////////////////////////\n// PUBLIC API\n///////////////////////////////////////////////////////////////////////////////\n\n\nconst CHUNK_SIZE = 1024; // The first and last keyframes cannot be removed in any given step, but we need to\n// somehow remove keyframes on chunk boundaries. So after processing each chunk,\n// we copy its last two keyframes in front of the next chunk, and run from there.\n//\n//                        // chunk 1, original\n//                           // chunk 1, resampled\n//                        // chunk 2, original\n//                           // chunk 2, resampled\n// ...\n\nfunction resample(input, output, interpolation, tolerance = 1e-4) {\n  __assert(!!exports, 'Await \"ready\" before using module.');\n\n  __assert(input instanceof Float32Array, 'Missing Float32Array input.');\n\n  __assert(output instanceof Float32Array, 'Missing Float32Array output.');\n\n  const outputSize = output.length / input.length;\n\n  __assert(Number.isInteger(outputSize), 'Invalid input/output counts.');\n\n  __assert(interpolation in TO_INTERPOLATION_INTERNAL, 'Invalid interpolation.');\n\n  __assert(Number.isFinite(tolerance), 'Invalid tolerance');\n\n  const interpVal = TO_INTERPOLATION_INTERNAL[interpolation];\n  const srcCount = input.length;\n  let dstCount = 0;\n\n  for (let chunkStart = 0; chunkStart < input.length; chunkStart += CHUNK_SIZE) {\n    const chunkCount = Math.min(srcCount - chunkStart, CHUNK_SIZE); // Allocate a two-keyframe prefix for all chunks after the first.\n\n    const prefixCount = chunkStart > 0 ? 2 : 0;\n    const chunkInput = new Float32Array(input.buffer, input.byteOffset + (chunkStart - prefixCount) * Float32Array.BYTES_PER_ELEMENT, chunkCount + prefixCount);\n    const chunkOutput = new Float32Array(output.buffer, output.byteOffset + (chunkStart - prefixCount) * outputSize * Float32Array.BYTES_PER_ELEMENT, (chunkCount + prefixCount) * outputSize); // Copy prefix to start of next chunk.\n\n    if (prefixCount > 0) {\n      input.copyWithin(chunkStart - prefixCount, dstCount - prefixCount, dstCount);\n      output.copyWithin((chunkStart - prefixCount) * outputSize, (dstCount - prefixCount) * outputSize, dstCount * outputSize);\n    }\n\n    const inputPtr = __retain(__lowerStaticArray(chunkInput, 4, 2));\n\n    const outputPtr = __retain(__lowerStaticArray(chunkOutput, 4, 2));\n\n    try {\n      exports.__setArgumentsLength(4);\n\n      const count = exports.resample(inputPtr, outputPtr, interpVal, tolerance) >>> 0;\n      dstCount -= prefixCount;\n\n      __liftStaticArray(inputPtr, input, dstCount, count);\n\n      __liftStaticArray(outputPtr, output, dstCount * outputSize, count * outputSize);\n\n      dstCount += count;\n    } finally {\n      __release(inputPtr);\n\n      __release(outputPtr);\n\n      exports.__collect();\n    }\n  } // console.log(`Memory: ${exports.memory.buffer.byteLength} bytes`);\n\n\n  return dstCount;\n} ///////////////////////////////////////////////////////////////////////////////\n// INTERNAL\n///////////////////////////////////////////////////////////////////////////////\n\nfunction __assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction __retain(ptr) {\n  exports.__pin(ptr);\n\n  return ptr;\n}\n\nfunction __release(ptr) {\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftString(ptr) {\n  if (!ptr) return null;\n  const end = ptr + new Uint32Array(exports.memory.buffer)[ptr - 4 >>> 2] >>> 1,\n        memoryU16 = new Uint16Array(exports.memory.buffer);\n  let start = ptr >>> 1,\n      string = '';\n\n  while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));\n\n  return string + String.fromCharCode(...memoryU16.subarray(start, end));\n}\n\nfunction __lowerStaticArray(values, id, align) {\n  const ptr = exports.__pin(exports.__new(values.length << align, id)) >>> 0;\n  new Float32Array(exports.memory.buffer, ptr, values.length).set(values);\n\n  exports.__unpin(ptr);\n\n  return ptr;\n}\n\nfunction __liftStaticArray(ptr, values, offset, count) {\n  values.set(new Float32Array(exports.memory.buffer, ptr, count), offset);\n}\n\nfunction __abort(messagePtr, fileNamePtr, lineNumber, columnNumber) {\n  const message = __liftString(messagePtr >>> 0);\n\n  const fileName = __liftString(fileNamePtr >>> 0);\n\n  lineNumber = lineNumber >>> 0;\n  columnNumber = columnNumber >>> 0;\n\n  (() => {\n    throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\n  })();\n}\n\nexport { ready, resample, resampleDebug };\n//# sourceMappingURL=keyframe-resample-browser.modern.js.map\n", "import {\n\tAccessor,\n\tAnimationSampler,\n\tComponentTypeToTypedArray,\n\tDocument,\n\tGLTF,\n\tMathUtils,\n\tPropertyType,\n\tRoot,\n\tTransform,\n\tTypedArray,\n} from '@gltf-transform/core';\nimport { dedup } from './dedup.js';\nimport { assignDefaults, createTransform } from './utils.js';\nimport { resampleDebug } from 'keyframe-resample';\n\nconst NAME = 'resample';\n\nconst EMPTY_ARRAY = new Float32Array(0);\n\nexport interface ResampleOptions {\n\tready?: Promise<void>;\n\tresample?: unknown; // glTF-Transform/issues/996\n\ttolerance?: number;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nconst RESAMPLE_DEFAULTS: Required<ResampleOptions> = {\n\tready: Promise.resolve(),\n\tresample: resampleDebug,\n\ttolerance: 1e-4,\n\tcleanup: true,\n};\n\n/**\n * Resample {@link AnimationChannel AnimationChannels}, losslessly deduplicating keyframes to\n * reduce file size. Duplicate keyframes are commonly present in animation 'baked' by the\n * authoring software to apply IK constraints or other software-specific features.\n *\n * Optionally, a WebAssembly implementation from the\n * [`keyframe-resample`](https://github.com/donmccurdy/keyframe-resample-wasm) library may be\n * provided. The WebAssembly version is usually much faster at processing large animation\n * sequences, but may not be compatible with all runtimes and JavaScript build tools.\n *\n * Result: (0,0,0,0,1,1,1,0,0,0,0,0,0,0)  (0,0,1,1,0,0)\n *\n * Example:\n *\n * ```\n * import { resample } from '@gltf-transform/functions';\n * import { ready, resample as resampleWASM } from 'keyframe-resample';\n *\n * // JavaScript (slower)\n * await document.transform(resample());\n *\n * // WebAssembly (faster)\n * await document.transform(resample({ ready, resample: resampleWASM }));\n * ```\n *\n * @privateRemarks Implementation based on THREE.KeyframeTrack#optimize().\n * @category Transforms\n */\nexport function resample(_options: ResampleOptions = RESAMPLE_DEFAULTS): Transform {\n\tconst options = assignDefaults(RESAMPLE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst accessorsVisited = new Set<Accessor>();\n\t\tconst srcAccessorCount = document.getRoot().listAccessors().length;\n\t\tconst logger = document.getLogger();\n\n\t\tconst ready = options.ready;\n\t\tconst resample = options.resample as typeof resampleDebug;\n\n\t\tawait ready;\n\n\t\tfor (const animation of document.getRoot().listAnimations()) {\n\t\t\tconst samplerTargetPaths = new Map<AnimationSampler, GLTF.AnimationChannelTargetPath>();\n\t\t\tfor (const channel of animation.listChannels()) {\n\t\t\t\tsamplerTargetPaths.set(channel.getSampler()!, channel.getTargetPath()!);\n\t\t\t}\n\n\t\t\tfor (const sampler of animation.listSamplers()) {\n\t\t\t\tconst samplerInterpolation = sampler.getInterpolation();\n\n\t\t\t\tif (samplerInterpolation === 'STEP' || samplerInterpolation === 'LINEAR') {\n\t\t\t\t\tconst input = sampler.getInput()!;\n\t\t\t\t\tconst output = sampler.getOutput()!;\n\n\t\t\t\t\taccessorsVisited.add(input);\n\t\t\t\t\taccessorsVisited.add(output);\n\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\tconst tmpTimes = toFloat32Array(\n\t\t\t\t\t\tinput.getArray()!,\n\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\tinput.getNormalized()\n\t\t\t\t\t);\n\t\t\t\t\tconst tmpValues = toFloat32Array(\n\t\t\t\t\t\toutput.getArray()!,\n\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t);\n\n\t\t\t\t\tconst elementSize = tmpValues.length / tmpTimes.length;\n\t\t\t\t\tconst srcCount = tmpTimes.length;\n\t\t\t\t\tlet dstCount: number;\n\n\t\t\t\t\tif (samplerInterpolation === 'STEP') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'step', options.tolerance);\n\t\t\t\t\t} else if (samplerTargetPaths.get(sampler) === 'rotation') {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'slerp', options.tolerance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdstCount = resample(tmpTimes, tmpValues, 'lerp', options.tolerance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dstCount < srcCount) {\n\t\t\t\t\t\t// Clone the input/output accessors, without cloning their underlying\n\t\t\t\t\t\t// arrays. Then assign the resampled data.\n\t\t\t\t\t\tconst srcTimes = input.getArray()!;\n\t\t\t\t\t\tconst srcValues = output.getArray()!;\n\n\t\t\t\t\t\tconst dstTimes = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpTimes.buffer, tmpTimes.byteOffset, dstCount),\n\t\t\t\t\t\t\tinput.getComponentType(),\n\t\t\t\t\t\t\tinput.getNormalized(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dstValues = fromFloat32Array(\n\t\t\t\t\t\t\tnew Float32Array(tmpValues.buffer, tmpValues.byteOffset, dstCount * elementSize),\n\t\t\t\t\t\t\toutput.getComponentType(),\n\t\t\t\t\t\t\toutput.getNormalized(),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tinput.setArray(EMPTY_ARRAY);\n\t\t\t\t\t\toutput.setArray(EMPTY_ARRAY);\n\n\t\t\t\t\t\tsampler.setInput(input.clone().setArray(dstTimes));\n\t\t\t\t\t\tsampler.setOutput(output.clone().setArray(dstValues));\n\n\t\t\t\t\t\tinput.setArray(srcTimes);\n\t\t\t\t\t\toutput.setArray(srcValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const accessor of Array.from(accessorsVisited.values())) {\n\t\t\tconst used = accessor.listParents().some((p) => !(p instanceof Root));\n\t\t\tif (!used) accessor.dispose();\n\t\t}\n\n\t\t// Resampling may result in duplicate input or output sampler\n\t\t// accessors. Find and remove the duplicates after processing.\n\t\tconst dstAccessorCount = document.getRoot().listAccessors().length;\n\t\tif (dstAccessorCount > srcAccessorCount && options.cleanup) {\n\t\t\tawait document.transform(dedup({ propertyTypes: [PropertyType.ACCESSOR] }));\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** Returns a copy of the source array, as a denormalized Float32Array. */\nfunction toFloat32Array(\n\tsrcArray: TypedArray,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): Float32Array {\n\tif (srcArray instanceof Float32Array) return srcArray.slice();\n\tconst dstArray = new Float32Array(srcArray);\n\tif (!normalized) return dstArray;\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = MathUtils.decodeNormalizedInt(dstArray[i], componentType);\n\t}\n\n\treturn dstArray;\n}\n\n/** Returns a copy of the source array, with specified component type and normalization. */\nfunction fromFloat32Array(\n\tsrcArray: Float32Array,\n\tcomponentType: GLTF.AccessorComponentType,\n\tnormalized: boolean,\n): TypedArray {\n\tif (componentType === Accessor.ComponentType.FLOAT) return srcArray.slice();\n\tconst TypedArray = ComponentTypeToTypedArray[componentType];\n\tconst dstArray = new TypedArray(srcArray.length);\n\n\tfor (let i = 0; i < dstArray.length; i++) {\n\t\tdstArray[i] = normalized ? MathUtils.encodeNormalizedInt(srcArray[i], componentType) : srcArray[i];\n\t}\n\n\treturn dstArray;\n}\n", "import { Accessor, AnimationChannel, AnimationSampler, Document, Transform } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'sequence';\n\nexport interface SequenceOptions {\n\t/** Frames per second, where one node is shown each frame. Default 10. */\n\tfps?: number;\n\t/** Pattern (regex) used to filter nodes for the sequence. Required. */\n\tpattern: RegExp;\n\t/** Name of the new animation. */\n\tname?: string;\n\t/** Whether to sort the nodes by name, or use original order. Default true. */\n\tsort?: boolean;\n}\n\nconst SEQUENCE_DEFAULTS: Required<SequenceOptions> = {\n\tname: '',\n\tfps: 10,\n\tpattern: /.*/,\n\tsort: true,\n};\n\n/**\n * Creates an {@link Animation} displaying each of the specified {@link Node}s sequentially.\n *\n * @category Transforms\n */\nexport function sequence(_options: SequenceOptions = SEQUENCE_DEFAULTS): Transform {\n\tconst options = assignDefaults(SEQUENCE_DEFAULTS, _options);\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst root = doc.getRoot();\n\t\tconst fps = options.fps;\n\n\t\t// Collect sequence nodes.\n\t\tconst sequenceNodes = root.listNodes().filter((node) => node.getName().match(options.pattern));\n\n\t\t// Sort by node name.\n\t\tif (options.sort) {\n\t\t\tsequenceNodes.sort((a, b) => (a.getName() > b.getName() ? 1 : -1));\n\t\t}\n\n\t\t// Create animation cycling visibility of each node.\n\t\tconst anim = doc.createAnimation(options.name);\n\t\tconst animBuffer = root.listBuffers()[0];\n\t\tsequenceNodes.forEach((node, i) => {\n\t\t\t// Create keyframe tracks that show each node for a single frame.\n\t\t\tlet inputArray;\n\t\t\tlet outputArray;\n\t\t\tif (i === 0) {\n\t\t\t\tinputArray = [i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [1, 1, 1, 0, 0, 0];\n\t\t\t} else if (i === sequenceNodes.length - 1) {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1];\n\t\t\t} else {\n\t\t\t\tinputArray = [(i - 1) / fps, i / fps, (i + 1) / fps];\n\t\t\t\toutputArray = [0, 0, 0, 1, 1, 1, 0, 0, 0];\n\t\t\t}\n\n\t\t\t// Append channel to animation sequence.\n\t\t\tconst input = doc.createAccessor().setArray(new Float32Array(inputArray)).setBuffer(animBuffer);\n\t\t\tconst output = doc\n\t\t\t\t.createAccessor()\n\t\t\t\t.setArray(new Float32Array(outputArray))\n\t\t\t\t.setBuffer(animBuffer)\n\t\t\t\t.setType(Accessor.Type.VEC3);\n\t\t\tconst sampler = doc\n\t\t\t\t.createAnimationSampler()\n\t\t\t\t.setInterpolation(AnimationSampler.Interpolation.STEP)\n\t\t\t\t.setInput(input)\n\t\t\t\t.setOutput(output);\n\t\t\tconst channel = doc\n\t\t\t\t.createAnimationChannel()\n\t\t\t\t.setTargetNode(node)\n\t\t\t\t.setTargetPath(AnimationChannel.TargetPath.SCALE)\n\t\t\t\t.setSampler(sampler);\n\t\t\tanim.addSampler(sampler).addChannel(channel);\n\t\t});\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import { Document, Primitive, PropertyType, Transform } from '@gltf-transform/core';\nimport {\n\tcreateTransform,\n\tformatDeltaOp,\n\tdeepListAttributes,\n\tdeepSwapAttribute,\n\tshallowCloneAccessor,\n\tassignDefaults,\n} from './utils.js';\nimport { weld } from './weld.js';\nimport type { MeshoptSimplifier } from 'meshoptimizer';\nimport { dedup } from './dedup.js';\nimport { prune } from './prune.js';\nimport { dequantizeAttributeArray } from './dequantize.js';\nimport { unweldPrimitive } from './unweld.js';\nimport { convertPrimitiveToTriangles } from './convert-primitive-mode.js';\nimport { compactAttribute, compactPrimitive } from './compact-primitive.js';\nimport { VertexCountMethod, getPrimitiveVertexCount } from './get-vertex-count.js';\n\nconst NAME = 'simplify';\n\nconst { POINTS, LINES, LINE_STRIP, LINE_LOOP, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN } = Primitive.Mode;\n\n/** Options for the {@link simplify} function. */\nexport interface SimplifyOptions {\n\t/** MeshoptSimplifier instance. */\n\tsimplifier: unknown;\n\t/** Target ratio (01) of vertices to keep. Default: 0.0 (0%). */\n\tratio?: number;\n\t/** Limit on error, as a fraction of mesh radius. Default: 0.0001 (0.01%). */\n\terror?: number;\n\t/**\n\t * Whether to lock topological borders of the mesh. May be necessary when\n\t * adjacent 'chunks' of a large mesh (e.g. terrain) share a border, helping\n\t * to ensure no seams appear.\n\t */\n\tlockBorder?: boolean;\n\t/**\n\t * Whether to perform cleanup steps after completing the operation. Recommended, and enabled by\n\t * default. Cleanup removes temporary resources created during the operation, but may also remove\n\t * pre-existing unused or duplicate resources in the {@link Document}. Applications that require\n\t * keeping these resources may need to disable cleanup, instead calling {@link dedup} and\n\t * {@link prune} manually (with customized options) later in the processing pipeline.\n\t * @experimental\n\t */\n\tcleanup?: boolean;\n}\n\nexport const SIMPLIFY_DEFAULTS: Required<Omit<SimplifyOptions, 'simplifier'>> = {\n\tratio: 0.0,\n\terror: 0.0001,\n\tlockBorder: false,\n\tcleanup: true,\n};\n\n/**\n * Simplification algorithm, based on meshoptimizer, producing meshes with fewer\n * triangles and vertices. Simplification is lossy, but the algorithm aims to\n * preserve visual quality as much as possible for given parameters.\n *\n * The algorithm aims to reach the target 'ratio', while minimizing error. If\n * error exceeds the specified 'error' threshold, the algorithm will quit\n * before reaching the target ratio. Examples:\n *\n * - ratio=0.0, error=0.0001: Aims for maximum simplification, constrained to 0.01% error.\n * - ratio=0.5, error=0.0001: Aims for 50% simplification, constrained to 0.01% error.\n * - ratio=0.5, error=1: Aims for 50% simplification, unconstrained by error.\n *\n * Topology, particularly split vertices, will also limit the simplifier. For\n * best results, apply a {@link weld} operation before simplification.\n *\n * Example:\n *\n * ```javascript\n * import { simplify, weld } from '@gltf-transform/functions';\n * import { MeshoptSimplifier } from 'meshoptimizer';\n *\n * await document.transform(\n *   weld({}),\n *   simplify({ simplifier: MeshoptSimplifier, ratio: 0.75, error: 0.001 })\n * );\n * ```\n *\n * References:\n * - https://github.com/zeux/meshoptimizer/blob/master/js/README.md#simplifier\n *\n * @category Transforms\n */\nexport function simplify(_options: SimplifyOptions): Transform {\n\tconst options = assignDefaults(SIMPLIFY_DEFAULTS, _options);\n\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier | undefined;\n\n\tif (!simplifier) {\n\t\tthrow new Error(`${NAME}: simplifier dependency required  install \"meshoptimizer\".`);\n\t}\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tawait simplifier.ready;\n\t\tawait document.transform(weld({ overwrite: false, cleanup: options.cleanup }));\n\n\t\tlet numUnsupported = 0;\n\n\t\t// Simplify mesh primitives.\n\t\tfor (const mesh of document.getRoot().listMeshes()) {\n\t\t\tfor (const prim of mesh.listPrimitives()) {\n\t\t\t\tconst mode = prim.getMode();\n\t\t\t\tif (mode === TRIANGLES || mode === TRIANGLE_STRIP || mode === TRIANGLE_FAN) {\n\t\t\t\t\tsimplifyPrimitive(prim, options);\n\t\t\t\t\tif (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n\t\t\t\t\t\tprim.dispose();\n\t\t\t\t\t}\n\t\t\t\t} else if (prim.getMode() === POINTS && !!simplifier.simplifyPoints) {\n\t\t\t\t\tsimplifyPrimitive(prim, options);\n\t\t\t\t\tif (getPrimitiveVertexCount(prim, VertexCountMethod.RENDER) === 0) {\n\t\t\t\t\t\tprim.dispose();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnumUnsupported++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mesh.listPrimitives().length === 0) mesh.dispose();\n\t\t}\n\n\t\tif (numUnsupported > 0) {\n\t\t\tlogger.warn(`${NAME}: Skipping simplification of ${numUnsupported} primitives: Unsupported draw mode.`);\n\t\t}\n\n\t\t// Where simplification removes meshes, we may need to prune leaf nodes.\n\t\tif (options.cleanup) {\n\t\t\tawait document.transform(\n\t\t\t\tprune({\n\t\t\t\t\tpropertyTypes: [PropertyType.ACCESSOR, PropertyType.NODE],\n\t\t\t\t\tkeepAttributes: true,\n\t\t\t\t\tkeepIndices: true,\n\t\t\t\t\tkeepLeaves: false,\n\t\t\t\t}),\n\t\t\t\tdedup({ propertyTypes: [PropertyType.ACCESSOR] }),\n\t\t\t);\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/** @hidden */\nexport function simplifyPrimitive(prim: Primitive, _options: SimplifyOptions): Primitive {\n\tconst options = { ...SIMPLIFY_DEFAULTS, ..._options } as Required<SimplifyOptions>;\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\tconst graph = prim.getGraph();\n\tconst document = Document.fromGraph(graph)!;\n\tconst logger = document.getLogger();\n\n\tswitch (prim.getMode()) {\n\t\tcase POINTS:\n\t\t\treturn _simplifyPoints(document, prim, options);\n\t\tcase LINES:\n\t\tcase LINE_STRIP:\n\t\tcase LINE_LOOP:\n\t\t\tlogger.warn(`${NAME}: Skipping primitive simplification: Unsupported draw mode.`);\n\t\t\treturn prim;\n\t\tcase TRIANGLE_STRIP:\n\t\tcase TRIANGLE_FAN:\n\t\t\tconvertPrimitiveToTriangles(prim);\n\t\t\tbreak;\n\t}\n\n\t// (1) If primitive draws <50% of its vertex stream, compact before simplification.\n\n\tconst srcVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\tconst srcIndexCount = getPrimitiveVertexCount(prim, VertexCountMethod.RENDER);\n\tif (srcIndexCount < srcVertexCount / 2) {\n\t\tcompactPrimitive(prim);\n\t}\n\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst srcIndices = prim.getIndices()!;\n\n\tlet positionArray = position.getArray()!;\n\tlet indicesArray = srcIndices.getArray()!;\n\n\t// (2) Gather attributes and indices in Meshopt-compatible format.\n\n\tif (!(positionArray instanceof Float32Array)) {\n\t\tpositionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n\t}\n\tif (!(indicesArray instanceof Uint32Array)) {\n\t\tindicesArray = new Uint32Array(indicesArray);\n\t}\n\n\t// (3) Run simplification.\n\n\tconst targetCount = Math.floor((options.ratio * srcIndexCount) / 3) * 3;\n\tconst flags = options.lockBorder ? ['LockBorder'] : [];\n\n\tconst [dstIndicesArray, error] = simplifier.simplify(\n\t\tindicesArray,\n\t\tpositionArray,\n\t\t3,\n\t\ttargetCount,\n\t\toptions.error,\n\t\tflags as 'LockBorder'[],\n\t);\n\n\t// (4) Assign subset of indexes; compact primitive.\n\n\tprim.setIndices(shallowCloneAccessor(document, srcIndices).setArray(dstIndicesArray));\n\tif (srcIndices.listParents().length === 1) srcIndices.dispose();\n\tcompactPrimitive(prim);\n\n\tconst dstVertexCount = getPrimitiveVertexCount(prim, VertexCountMethod.UPLOAD);\n\tif (dstVertexCount <= 65534) {\n\t\tprim.getIndices()!.setArray(new Uint16Array(prim.getIndices()!.getArray()!));\n\t}\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(srcVertexCount, dstVertexCount)} vertices, error: ${error.toFixed(4)}.`);\n\n\treturn prim;\n}\n\nfunction _simplifyPoints(document: Document, prim: Primitive, options: Required<SimplifyOptions>): Primitive {\n\tconst simplifier = options.simplifier as typeof MeshoptSimplifier;\n\tconst logger = document.getLogger();\n\n\tconst indices = prim.getIndices();\n\tif (indices) unweldPrimitive(prim);\n\n\tconst position = prim.getAttribute('POSITION')!;\n\tconst color = prim.getAttribute('COLOR_0');\n\tconst srcVertexCount = position.getCount();\n\n\tlet positionArray = position.getArray()!;\n\tlet colorArray = color ? color.getArray()! : undefined;\n\tconst colorStride = color ? color.getComponentSize() : undefined;\n\n\t// (1) Gather attributes in Meshopt-compatible format.\n\n\tif (!(positionArray instanceof Float32Array)) {\n\t\tpositionArray = dequantizeAttributeArray(positionArray, position.getComponentType(), position.getNormalized());\n\t}\n\tif (colorArray && !(colorArray instanceof Float32Array)) {\n\t\tcolorArray = dequantizeAttributeArray(colorArray, position.getComponentType(), position.getNormalized());\n\t}\n\n\t// (2) Run simplification.\n\n\tsimplifier.useExperimentalFeatures = true;\n\tconst targetCount = Math.floor(options.ratio * srcVertexCount);\n\tconst dstIndicesArray = simplifier.simplifyPoints(positionArray, 3, targetCount, colorArray, colorStride);\n\tsimplifier.useExperimentalFeatures = false;\n\n\t// (3) Write vertex attributes.\n\n\tconst [remap, unique] = simplifier.compactMesh(dstIndicesArray);\n\n\tlogger.debug(`${NAME}: ${formatDeltaOp(position.getCount(), unique)} vertices.`);\n\n\tfor (const srcAttribute of deepListAttributes(prim)) {\n\t\tconst dstAttribute = shallowCloneAccessor(document, srcAttribute);\n\t\tcompactAttribute(srcAttribute, null, remap, dstAttribute, unique);\n\t\tdeepSwapAttribute(prim, srcAttribute, dstAttribute);\n\t\tif (srcAttribute.listParents().length === 1) srcAttribute.dispose();\n\t}\n\n\treturn prim;\n}\n", "import { Document, MathUtils, Transform } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'sparse';\n\n/** Options for the {@link sparse} function. */\nexport interface SparseOptions {\n\t/**\n\t * Threshold ratio used to determine when an accessor should be sparse.\n\t * Default: 1 / 3.\n\t */\n\tratio: number;\n}\n\nconst SPARSE_DEFAULTS: Required<SparseOptions> = {\n\tratio: 1 / 3,\n};\n\n/**\n * Scans all {@link Accessor Accessors} in the Document, detecting whether each Accessor\n * would benefit from sparse data storage. Currently, sparse data storage is used only\n * when many values (>= ratio) are zeroes. Particularly for assets using morph target\n * (\"shape key\") animation, sparse data storage may significantly reduce file sizes.\n *\n * Example:\n *\n * ```ts\n * import { sparse } from '@gltf-transform/functions';\n *\n * accessor.getArray(); //  [ 0, 0, 0, 0, 0, 25.0, 0, 0, ... ]\n * accessor.getSparse(); //  false\n *\n * await document.transform(sparse({ratio: 1 / 10}));\n *\n * accessor.getSparse(); //  true\n * ```\n *\n * @experimental\n * @category Transforms\n */\nexport function sparse(_options: SparseOptions = SPARSE_DEFAULTS): Transform {\n\tconst options = assignDefaults(SPARSE_DEFAULTS, _options);\n\n\tconst ratio = options.ratio;\n\tif (ratio < 0 || ratio > 1) {\n\t\tthrow new Error(`${NAME}: Ratio must be between 0 and 1.`);\n\t}\n\n\treturn createTransform(NAME, (document: Document): void => {\n\t\tconst root = document.getRoot();\n\t\tconst logger = document.getLogger();\n\n\t\tlet modifiedCount = 0;\n\n\t\tfor (const accessor of root.listAccessors()) {\n\t\t\tconst count = accessor.getCount();\n\t\t\tconst base = Array(accessor.getElementSize()).fill(0);\n\t\t\tconst el = Array(accessor.getElementSize()).fill(0);\n\n\t\t\tlet nonZeroCount = 0;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\taccessor.getElement(i, el);\n\t\t\t\tif (!MathUtils.eq(el, base, 0)) nonZeroCount++;\n\t\t\t\tif (nonZeroCount / count >= ratio) break;\n\t\t\t}\n\n\t\t\tconst sparse = nonZeroCount / count < ratio;\n\t\t\tif (sparse !== accessor.getSparse()) {\n\t\t\t\taccessor.setSparse(sparse);\n\t\t\t\tmodifiedCount++;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Updated ${modifiedCount} accessors.`);\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import {\n\tBufferUtils,\n\tDocument,\n\tFileUtils,\n\tImageUtils,\n\tTexture,\n\tTextureChannel,\n\tTransform,\n\tvec2,\n} from '@gltf-transform/core';\nimport { EXTTextureAVIF, EXTTextureWebP } from '@gltf-transform/extensions';\nimport { getTextureChannelMask } from './list-texture-channels.js';\nimport { listTextureSlots } from './list-texture-slots.js';\nimport type sharp from 'sharp';\nimport { assignDefaults, createTransform, fitPowerOfTwo, fitWithin, formatBytes } from './utils.js';\nimport { getPixels, savePixels } from 'ndarray-pixels';\nimport ndarray from 'ndarray';\nimport { lanczos2, lanczos3 } from 'ndarray-lanczos';\n\nconst NAME = 'textureCompress';\n\ntype Format = (typeof TEXTURE_COMPRESS_SUPPORTED_FORMATS)[number];\nexport const TEXTURE_COMPRESS_SUPPORTED_FORMATS = ['jpeg', 'png', 'webp', 'avif'] as const;\nconst SUPPORTED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];\n\n/** Resampling filter methods. LANCZOS3 is sharper, LANCZOS2 is smoother. */\nexport enum TextureResizeFilter {\n\t/** Lanczos3 (sharp) */\n\tLANCZOS3 = 'lanczos3',\n\t/** Lanczos2 (smooth) */\n\tLANCZOS2 = 'lanczos2',\n}\n\nexport interface TextureCompressOptions {\n\t/** Instance of the Sharp encoder, which must be installed from the\n\t * 'sharp' package and provided by the caller. When not provided, a\n\t * platform-specific fallback implementation will be used, and most\n\t * quality- and compression-related options are ignored.\n\t */\n\tencoder?: unknown;\n\t/**\n\t * Target image format. If specified, included textures in other formats\n\t * will be converted. Default: original format.\n\t */\n\ttargetFormat?: Format;\n\t/**\n\t * Resizes textures to given maximum width/height, preserving aspect ratio.\n\t * For example, a 4096x8192 texture, resized with limit [2048, 2048] will\n\t * be reduced to 1024x2048.\n\t *\n\t * Presets \"nearest-pot\", \"ceil-pot\", and \"floor-pot\" resize textures to\n\t * power-of-two dimensions, for older graphics APIs including WebGL 1.0.\n\t */\n\tresize?: vec2 | 'nearest-pot' | 'ceil-pot' | 'floor-pot';\n\t/** Interpolation used if resizing. Default: TextureResizeFilter.LANCZOS3. */\n\tresizeFilter?: TextureResizeFilter;\n\t/** Pattern identifying textures to compress, matched to name or URI. */\n\tpattern?: RegExp | null;\n\t/**\n\t * Pattern matching the format(s) to be compressed or converted. Some examples\n\t * of formats include \"jpeg\" and \"png\".\n\t */\n\tformats?: RegExp | null;\n\t/**\n\t * Pattern matching the material texture slot(s) to be compressed or converted.\n\t * Some examples of slot names include \"baseColorTexture\", \"occlusionTexture\",\n\t * \"metallicRoughnessTexture\", and \"normalTexture\".\n\t */\n\tslots?: RegExp | null;\n\n\t/** Quality, 1-100. Default: auto. */\n\tquality?: number | null;\n\t/**\n\t * Level of CPU effort to reduce file size, 0-100. PNG, WebP, and AVIF\n\t * only. Supported only when a Sharp encoder is provided. Default: auto.\n\t */\n\teffort?: number | null;\n\t/**\n\t * Use lossless compression mode. WebP and AVIF only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tlossless?: boolean;\n\t/**\n\t * Use near lossless compression mode. WebP only. Supported only when a\n\t * Sharp encoder is provided. Default: false.\n\t */\n\tnearLossless?: boolean;\n\n\t/**\n\t * Attempts to avoid processing images that could exceed memory or other other\n\t * limits, throwing an error instead. Default: true.\n\t * @experimental\n\t */\n\tlimitInputPixels?: boolean;\n}\n\nexport type CompressTextureOptions = Omit<TextureCompressOptions, 'pattern' | 'formats' | 'slots'>;\n\n// IMPORTANT: No defaults for quality flags, see https://github.com/donmccurdy/glTF-Transform/issues/969.\nexport const TEXTURE_COMPRESS_DEFAULTS: Omit<TextureCompressOptions, 'resize' | 'targetFormat' | 'encoder'> = {\n\tresizeFilter: TextureResizeFilter.LANCZOS3,\n\tpattern: undefined,\n\tformats: undefined,\n\tslots: undefined,\n\tquality: undefined,\n\teffort: undefined,\n\tlossless: false,\n\tnearLossless: false,\n\tlimitInputPixels: true,\n};\n\n/**\n * Optimizes images, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted  `sharp` works only in Node.js \n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { textureCompress } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * // (A) Optimize without conversion.\n * await document.transform(\n * \ttextureCompress({encoder: sharp})\n * );\n *\n * // (B) Optimize and convert images to WebP.\n * await document.transform(\n * \ttextureCompress({\n * \t\tencoder: sharp,\n * \t\ttargetFormat: 'webp',\n * \t\tslots: /^(?!normalTexture).*$/ // exclude normal maps\n * \t})\n * );\n *\n * // (C) Resize and convert images to WebP in a browser, without a Sharp\n * // encoder. Most quality- and compression-related options are ignored.\n * await document.transform(\n * \ttextureCompress({ targetFormat: 'webp', resize: [1024, 1024] })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function textureCompress(_options: TextureCompressOptions): Transform {\n\tconst options = assignDefaults(TEXTURE_COMPRESS_DEFAULTS, _options);\n\tconst targetFormat = options.targetFormat as Format | undefined;\n\tconst patternRe = options.pattern;\n\tconst formatsRe = options.formats;\n\tconst slotsRe = options.slots;\n\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\t\tconst textures = document.getRoot().listTextures();\n\n\t\tawait Promise.all(\n\t\t\ttextures.map(async (texture, textureIndex) => {\n\t\t\t\tconst slots = listTextureSlots(texture);\n\t\t\t\tconst channels = getTextureChannelMask(texture);\n\t\t\t\tconst textureLabel =\n\t\t\t\t\ttexture.getURI() ||\n\t\t\t\t\ttexture.getName() ||\n\t\t\t\t\t`${textureIndex + 1}/${document.getRoot().listTextures().length}`;\n\t\t\t\tconst prefix = `${NAME}(${textureLabel})`;\n\n\t\t\t\t// FILTER: Exclude textures that don't match (a) 'slots' or (b) expected formats.\n\n\t\t\t\tif (!SUPPORTED_MIME_TYPES.includes(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, unsupported texture type \"${texture.getMimeType()}\".`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (patternRe && !patternRe.test(texture.getName()) && !patternRe.test(texture.getURI())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, excluded by \"pattern\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (formatsRe && !formatsRe.test(texture.getMimeType())) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, \"${texture.getMimeType()}\" excluded by \"formats\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (slotsRe && slots.length && !slots.some((slot) => slotsRe.test(slot))) {\n\t\t\t\t\tlogger.debug(`${prefix}: Skipping, [${slots.join(', ')}] excluded by \"slots\" parameter.`);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (options.targetFormat === 'jpeg' && channels & TextureChannel.A) {\n\t\t\t\t\tlogger.warn(`${prefix}: Skipping, [${slots.join(', ')}] requires alpha channel.`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst srcFormat = getFormat(texture);\n\t\t\t\tconst dstFormat = targetFormat || srcFormat;\n\t\t\t\tlogger.debug(`${prefix}: Format = ${srcFormat}  ${dstFormat}`);\n\t\t\t\tlogger.debug(`${prefix}: Slots = [${slots.join(', ')}]`);\n\n\t\t\t\tconst srcImage = texture.getImage()!;\n\t\t\t\tconst srcByteLength = srcImage.byteLength;\n\n\t\t\t\tawait compressTexture(texture, options);\n\n\t\t\t\tconst dstImage = texture.getImage()!;\n\t\t\t\tconst dstByteLength = dstImage.byteLength;\n\n\t\t\t\tconst flag = srcImage === dstImage ? ' (SKIPPED' : '';\n\n\t\t\t\tlogger.debug(`${prefix}: Size = ${formatBytes(srcByteLength)}  ${formatBytes(dstByteLength)}${flag}`);\n\t\t\t}),\n\t\t);\n\n\t\t// Attach EXT_texture_webp if needed.\n\t\tconst webpExtension = document.createExtension(EXTTextureWebP);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/webp')) {\n\t\t\twebpExtension.setRequired(true);\n\t\t} else {\n\t\t\twebpExtension.dispose();\n\t\t}\n\n\t\t// Attach EXT_texture_avif if needed.\n\t\tconst avifExtension = document.createExtension(EXTTextureAVIF);\n\t\tif (textures.some((texture) => texture.getMimeType() === 'image/avif')) {\n\t\t\tavifExtension.setRequired(true);\n\t\t} else {\n\t\t\tavifExtension.dispose();\n\t\t}\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n\n/**\n * Optimizes a single {@link Texture}, optionally resizing or converting to JPEG, PNG, WebP, or AVIF formats.\n *\n * For best results use a Node.js environment, install the `sharp` module, and\n * provide an encoder. When the encoder is omitted  `sharp` works only in Node.js \n * the implementation will use a platform-specific fallback encoder, and most\n * quality- and compression-related options are ignored.\n *\n * Example:\n *\n * ```javascript\n * import { compressTexture } from '@gltf-transform/functions';\n * import sharp from 'sharp';\n *\n * const texture = document.getRoot().listTextures()\n * \t.find((texture) => texture.getName() === 'MyTexture');\n *\n * // (A) Node.js.\n * await compressTexture(texture, {\n * \tencoder: sharp,\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n *\n * // (B) Web.\n * await compressTexture(texture, {\n * \ttargetFormat: 'webp',\n * \tresize: [1024, 1024]\n * });\n * ```\n */\nexport async function compressTexture(texture: Texture, _options: CompressTextureOptions) {\n\tconst options = { ...TEXTURE_COMPRESS_DEFAULTS, ..._options } as Required<CompressTextureOptions>;\n\tconst encoder = options.encoder as typeof sharp | null;\n\n\tconst srcURI = texture.getURI();\n\tconst srcFormat = getFormat(texture);\n\tconst dstFormat = options.targetFormat || srcFormat;\n\tconst srcMimeType = texture.getMimeType();\n\tconst dstMimeType = `image/${dstFormat}`;\n\n\tconst srcImage = texture.getImage()!;\n\tconst dstImage = encoder\n\t\t? await _encodeWithSharp(srcImage, srcMimeType, dstMimeType, options)\n\t\t: await _encodeWithNdarrayPixels(srcImage, srcMimeType, dstMimeType, options);\n\n\tconst srcByteLength = srcImage.byteLength;\n\tconst dstByteLength = dstImage.byteLength;\n\n\tif (srcMimeType === dstMimeType && dstByteLength >= srcByteLength && !options.resize) {\n\t\t// Skip if src/dst formats match and dst is larger than the original.\n\t\treturn;\n\t} else if (srcMimeType === dstMimeType) {\n\t\t// Overwrite if src/dst formats match and dst is smaller than the original.\n\t\ttexture.setImage(dstImage);\n\t} else {\n\t\t// Overwrite, then update path and MIME type if src/dst formats differ.\n\t\tconst srcExtension = srcURI ? FileUtils.extension(srcURI) : ImageUtils.mimeTypeToExtension(srcMimeType);\n\t\tconst dstExtension = ImageUtils.mimeTypeToExtension(dstMimeType);\n\t\tconst dstURI = texture.getURI().replace(new RegExp(`\\\\.${srcExtension}$`), `.${dstExtension}`);\n\t\ttexture.setImage(dstImage).setMimeType(dstMimeType).setURI(dstURI);\n\t}\n}\n\nasync function _encodeWithSharp(\n\tsrcImage: Uint8Array,\n\t_srcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst encoder = options.encoder as typeof sharp;\n\tlet encoderOptions: sharp.JpegOptions | sharp.PngOptions | sharp.WebpOptions | sharp.AvifOptions = {};\n\n\tconst dstFormat = getFormatFromMimeType(dstMimeType);\n\n\tswitch (dstFormat) {\n\t\tcase 'jpeg':\n\t\t\tencoderOptions = { quality: options.quality } as sharp.JpegOptions;\n\t\t\tbreak;\n\t\tcase 'png':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 10),\n\t\t\t} as sharp.PngOptions;\n\t\t\tbreak;\n\t\tcase 'webp':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 6),\n\t\t\t\tlossless: options.lossless,\n\t\t\t\tnearLossless: options.nearLossless,\n\t\t\t} as sharp.WebpOptions;\n\t\t\tbreak;\n\t\tcase 'avif':\n\t\t\tencoderOptions = {\n\t\t\t\tquality: options.quality,\n\t\t\t\teffort: remap(options.effort, 100, 9),\n\t\t\t\tlossless: options.lossless,\n\t\t\t} as sharp.AvifOptions;\n\t\t\tbreak;\n\t}\n\n\tconst limitInputPixels = options.limitInputPixels;\n\tconst instance = encoder(srcImage, { limitInputPixels }).toFormat(dstFormat, encoderOptions);\n\n\tif (options.resize) {\n\t\tconst srcSize = ImageUtils.getSize(srcImage, _srcMimeType)!;\n\t\tconst dstSize = Array.isArray(options.resize)\n\t\t\t? fitWithin(srcSize, options.resize)\n\t\t\t: fitPowerOfTwo(srcSize, options.resize);\n\t\tinstance.resize(dstSize[0], dstSize[1], { fit: 'fill', kernel: options.resizeFilter });\n\t}\n\n\treturn BufferUtils.toView(await instance.toBuffer());\n}\n\nasync function _encodeWithNdarrayPixels(\n\tsrcImage: Uint8Array,\n\tsrcMimeType: string,\n\tdstMimeType: string,\n\toptions: Required<CompressTextureOptions>,\n): Promise<Uint8Array> {\n\tconst srcPixels = (await getPixels(srcImage, srcMimeType)) as ndarray.NdArray<Uint8Array>;\n\n\tif (options.resize) {\n\t\tconst [w, h] = srcPixels.shape;\n\t\tconst dstSize = Array.isArray(options.resize)\n\t\t\t? fitWithin([w, h], options.resize)\n\t\t\t: fitPowerOfTwo([w, h], options.resize);\n\t\tconst dstPixels = ndarray(new Uint8Array(dstSize[0] * dstSize[1] * 4), [...dstSize, 4]);\n\t\toptions.resizeFilter === TextureResizeFilter.LANCZOS3\n\t\t\t? lanczos3(srcPixels, dstPixels)\n\t\t\t: lanczos2(srcPixels, dstPixels);\n\t\treturn savePixels(dstPixels, dstMimeType);\n\t}\n\n\treturn savePixels(srcPixels, dstMimeType);\n}\n\nfunction getFormat(texture: Texture): Format {\n\treturn getFormatFromMimeType(texture.getMimeType());\n}\n\nfunction getFormatFromMimeType(mimeType: string): Format {\n\tconst format = mimeType.split('/').pop() as Format | undefined;\n\tif (!format || !TEXTURE_COMPRESS_SUPPORTED_FORMATS.includes(format)) {\n\t\tthrow new Error(`Unknown MIME type \"${mimeType}\".`);\n\t}\n\treturn format;\n}\n\nfunction remap(value: number | null | undefined, srcMax: number, dstMax: number): number | undefined {\n\tif (value == null) return undefined;\n\treturn Math.round((value / srcMax) * dstMax);\n}\n", "import { Accessor, Document, ILogger, Primitive, Transform, TypedArray, uuid } from '@gltf-transform/core';\nimport { assignDefaults, createTransform } from './utils.js';\n\nconst NAME = 'tangents';\n\n/** Options for the {@link tangents} function. */\nexport interface TangentsOptions {\n\t/**\n\t * Callback function to generate tangents from position, uv, and normal attributes.\n\t * Generally, users will want to provide the `generateTangents` from the\n\t * [mikktspace](https://github.com/donmccurdy/mikktspace-wasm) library, which is not\n\t * included by default.\n\t */\n\tgenerateTangents?: (pos: Float32Array, norm: Float32Array, uv: Float32Array) => Float32Array;\n\t/** Whether to overwrite existing `TANGENT` attributes. */\n\toverwrite?: boolean;\n}\n\nconst TANGENTS_DEFAULTS: Required<Omit<TangentsOptions, 'generateTangents'>> = {\n\toverwrite: false,\n};\n\n/**\n * Generates MikkTSpace vertex tangents for mesh primitives, which may fix rendering issues\n * occuring with some baked normal maps. Requires access to the [mikktspace](https://github.com/donmccurdy/mikktspace-wasm)\n * WASM package, or equivalent.\n *\n * Example:\n *\n * ```ts\n * import { generateTangents } from 'mikktspace';\n * import { tangents } from '@gltf-transform/functions';\n *\n * await document.transform(\n * \ttangents({generateTangents})\n * );\n * ```\n *\n * @category Transforms\n */\nexport function tangents(_options: TangentsOptions = TANGENTS_DEFAULTS): Transform {\n\tconst options = assignDefaults(TANGENTS_DEFAULTS, _options);\n\n\tif (!options.generateTangents) {\n\t\tthrow new Error(`${NAME}: generateTangents callback required  install \"mikktspace\".`);\n\t}\n\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\t\tconst attributeIDs = new Map<TypedArray, string>();\n\t\tconst tangentCache = new Map<string, Accessor>();\n\t\tlet modified = 0;\n\n\t\tfor (const mesh of doc.getRoot().listMeshes()) {\n\t\t\tconst meshName = mesh.getName();\n\t\t\tconst meshPrimitives = mesh.listPrimitives();\n\n\t\t\tfor (let i = 0; i < meshPrimitives.length; i++) {\n\t\t\t\tconst prim = meshPrimitives[i];\n\n\t\t\t\t// Skip primitives for which we can't compute tangents.\n\t\t\t\tif (!filterPrimitive(prim, logger, meshName, i, options.overwrite)) continue;\n\n\t\t\t\tconst texcoordSemantic = getNormalTexcoord(prim);\n\n\t\t\t\t// Nullability conditions checked by filterPrimitive() above.\n\t\t\t\tconst position = prim.getAttribute('POSITION')!.getArray()!;\n\t\t\t\tconst normal = prim.getAttribute('NORMAL')!.getArray()!;\n\t\t\t\tconst texcoord = prim.getAttribute(texcoordSemantic)!.getArray()!;\n\n\t\t\t\t// Compute UUIDs for each attribute.\n\t\t\t\tconst positionID = attributeIDs.get(position) || uuid();\n\t\t\t\tattributeIDs.set(position, positionID);\n\n\t\t\t\tconst normalID = attributeIDs.get(normal) || uuid();\n\t\t\t\tattributeIDs.set(normal, normalID);\n\n\t\t\t\tconst texcoordID = attributeIDs.get(texcoord) || uuid();\n\t\t\t\tattributeIDs.set(texcoord, texcoordID);\n\n\t\t\t\t// Dispose of previous TANGENT accessor if only used by this primitive (and Root).\n\t\t\t\tconst prevTangent = prim.getAttribute('TANGENT');\n\t\t\t\tif (prevTangent && prevTangent.listParents().length === 2) prevTangent.dispose();\n\n\t\t\t\t// If we've already computed tangents for this pos/norm/uv set, reuse them.\n\t\t\t\tconst attributeHash = `${positionID}|${normalID}|${texcoordID}`;\n\t\t\t\tlet tangent = tangentCache.get(attributeHash);\n\t\t\t\tif (tangent) {\n\t\t\t\t\tlogger.debug(`${NAME}: Found cache for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\t\t\t\t\tmodified++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, generate tangents with the 'mikktspace' WASM library.\n\t\t\t\tlogger.debug(`${NAME}: Generating for primitive ${i} of mesh \"${meshName}\".`);\n\t\t\t\tconst tangentBuffer = prim.getAttribute('POSITION')!.getBuffer();\n\t\t\t\tconst tangentArray = options.generateTangents!(\n\t\t\t\t\tposition instanceof Float32Array ? position : new Float32Array(position),\n\t\t\t\t\tnormal instanceof Float32Array ? normal : new Float32Array(normal),\n\t\t\t\t\ttexcoord instanceof Float32Array ? texcoord : new Float32Array(texcoord),\n\t\t\t\t);\n\n\t\t\t\t// See: https://github.com/KhronosGroup/glTF-Sample-Models/issues/174\n\t\t\t\tfor (let i = 3; i < tangentArray.length; i += 4) tangentArray[i] *= -1;\n\n\t\t\t\ttangent = doc.createAccessor().setBuffer(tangentBuffer).setArray(tangentArray).setType('VEC4');\n\t\t\t\tprim.setAttribute('TANGENT', tangent);\n\n\t\t\t\ttangentCache.set(attributeHash, tangent);\n\t\t\t\tmodified++;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified) {\n\t\t\tlogger.warn(`${NAME}: No qualifying primitives found. See debug output.`);\n\t\t} else {\n\t\t\tlogger.debug(`${NAME}: Complete.`);\n\t\t}\n\t});\n}\n\nfunction getNormalTexcoord(prim: Primitive): string {\n\tconst material = prim.getMaterial();\n\tif (!material) return 'TEXCOORD_0';\n\n\tconst normalTextureInfo = material.getNormalTextureInfo();\n\tif (!normalTextureInfo) return 'TEXCOORD_0';\n\n\tconst texcoord = normalTextureInfo.getTexCoord();\n\tconst semantic = `TEXCOORD_${texcoord}`;\n\tif (prim.getAttribute(semantic)) return semantic;\n\n\treturn 'TEXCOORD_0';\n}\n\nfunction filterPrimitive(prim: Primitive, logger: ILogger, meshName: string, i: number, overwrite: boolean): boolean {\n\tif (\n\t\tprim.getMode() !== Primitive.Mode.TRIANGLES ||\n\t\t!prim.getAttribute('POSITION') ||\n\t\t!prim.getAttribute('NORMAL') ||\n\t\t!prim.getAttribute('TEXCOORD_0')\n\t) {\n\t\tlogger.debug(\n\t\t\t`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` +\n\t\t\t\t' have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.',\n\t\t);\n\t\treturn false;\n\t}\n\n\tif (prim.getAttribute('TANGENT') && !overwrite) {\n\t\tlogger.debug(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": TANGENT found.`);\n\t\treturn false;\n\t}\n\n\tif (prim.getIndices()) {\n\t\tlogger.warn(`${NAME}: Skipping primitive ${i} of mesh \"${meshName}\": primitives must` + ' be unwelded.');\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { KHRMaterialsUnlit } from '@gltf-transform/extensions';\n\n/**\n * @category Transforms\n */\nexport function unlit(): Transform {\n\treturn (doc: Document): void => {\n\t\tconst unlitExtension = doc.createExtension(KHRMaterialsUnlit) as KHRMaterialsUnlit;\n\t\tconst unlit = unlitExtension.createUnlit();\n\t\tdoc.getRoot()\n\t\t\t.listMaterials()\n\t\t\t.forEach((material) => {\n\t\t\t\tmaterial.setExtension('KHR_materials_unlit', unlit);\n\t\t\t});\n\t};\n}\n", "import type { Document, Transform } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'unpartition';\n\nexport interface UnpartitionOptions {}\nconst UNPARTITION_DEFAULTS: Required<UnpartitionOptions> = {};\n\n/**\n * Removes partitions from the binary payload of a glTF file, so that the asset\n * contains at most one (1) `.bin` {@link Buffer}. This process reverses the\n * changes from a {@link partition} transform.\n *\n * Example:\n *\n * ```ts\n * document.getRoot().listBuffers(); //  [Buffer, Buffer, ...]\n *\n * await document.transform(unpartition());\n *\n * document.getRoot().listBuffers(); //  [Buffer]\n * ```\n *\n * @category Transforms\n */\nexport function unpartition(_options: UnpartitionOptions = UNPARTITION_DEFAULTS): Transform {\n\treturn createTransform(NAME, async (document: Document): Promise<void> => {\n\t\tconst logger = document.getLogger();\n\n\t\tconst buffer = document.getRoot().listBuffers()[0];\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listAccessors()\n\t\t\t.forEach((a) => a.setBuffer(buffer));\n\t\tdocument\n\t\t\t.getRoot()\n\t\t\t.listBuffers()\n\t\t\t.forEach((b, index) => (index > 0 ? b.dispose() : null));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n", "import type { Accessor, Document, Primitive, Transform, vec3 } from '@gltf-transform/core';\nimport { createTransform } from './utils.js';\n\nconst NAME = 'vertexColorSpace';\n\n/** Options for the {@link vertexColorSpace} function. */\nexport interface ColorSpaceOptions {\n\t/** Input color space of vertex colors, to be converted to \"srgb-linear\". Required. */\n\tinputColorSpace: 'srgb' | 'srgb-linear';\n}\n\n/**\n * Vertex color color space correction. The glTF format requires vertex colors to be stored\n * in Linear Rec. 709 D65 color space, and this function provides a way to correct vertex\n * colors that are (incorrectly) stored in sRGB.\n *\n * Example:\n *\n * ```typescript\n * import { vertexColorSpace } from '@gltf-transform/functions';\n *\n * await document.transform(\n *   vertexColorSpace({ inputColorSpace: 'srgb' })\n * );\n * ```\n *\n * @category Transforms\n */\nexport function vertexColorSpace(options: ColorSpaceOptions): Transform {\n\treturn createTransform(NAME, (doc: Document): void => {\n\t\tconst logger = doc.getLogger();\n\n\t\tconst inputColorSpace = (options.inputColorSpace || '').toLowerCase();\n\n\t\tif (inputColorSpace === 'srgb-linear') {\n\t\t\tlogger.info(`${NAME}: Vertex colors already linear. Skipping conversion.`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (inputColorSpace !== 'srgb') {\n\t\t\tlogger.error(\n\t\t\t\t`${NAME}: Unknown input color space \"${inputColorSpace}\"  should be \"srgb\" or ` +\n\t\t\t\t\t'\"srgb-linear\". Skipping conversion.',\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst converted = new Set<Accessor>();\n\n\t\t// Source: THREE.Color\n\t\tfunction sRGBToLinear(c: number): number {\n\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t}\n\n\t\tfunction updatePrimitive(primitive: Primitive): void {\n\t\t\tconst color = [0, 0, 0] as vec3;\n\t\t\tlet attribute: Accessor | null;\n\t\t\tfor (let i = 0; (attribute = primitive.getAttribute(`COLOR_${i}`)); i++) {\n\t\t\t\tif (converted.has(attribute)) continue;\n\n\t\t\t\tfor (let j = 0; j < attribute.getCount(); j++) {\n\t\t\t\t\tattribute.getElement(j, color);\n\t\t\t\t\tcolor[0] = sRGBToLinear(color[0]);\n\t\t\t\t\tcolor[1] = sRGBToLinear(color[1]);\n\t\t\t\t\tcolor[2] = sRGBToLinear(color[2]);\n\t\t\t\t\tattribute.setElement(j, color);\n\t\t\t\t}\n\n\t\t\t\tconverted.add(attribute);\n\t\t\t}\n\t\t}\n\n\t\tdoc.getRoot()\n\t\t\t.listMeshes()\n\t\t\t.forEach((mesh) => mesh.listPrimitives().forEach(updatePrimitive));\n\n\t\tlogger.debug(`${NAME}: Complete.`);\n\t});\n}\n"],
  "mappings": "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",
  "names": ["n", "a", "i", "n", "len", "a", "t", "a", "getPixelsInternal", "buffer", "mimeType", "Uint8Array", "Error", "blob", "Blob", "type", "path", "URL", "createObjectURL", "Promise", "resolve", "reject", "img", "Image", "crossOrigin", "onload", "revokeObjectURL", "canvas", "OffscreenCanvas", "width", "height", "context", "getContext", "drawImage", "pixels", "getImageData", "ndarray", "data", "onerror", "err", "src", "putPixelData", "array", "frame", "shape", "length", "pick", "ops", "assign", "assigns", "stride", "offset", "savePixelsInternal", "options", "imageData", "putImageData", "streamCanvas", "convertToBlob", "ab", "arrayBuffer", "getPixels", "savePixels", "typeOrOptions", "quality", "undefined", "KHR_SUPERCOMPRESSION_NONE", "KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT", "KHR_DF_VENDORID_KHRONOS", "KHR_DF_VERSION", "KHR_DF_MODEL_UNSPECIFIED", "KHR_DF_MODEL_ETC1S", "KHR_DF_MODEL_UASTC", "KHR_DF_FLAG_ALPHA_STRAIGHT", "KHR_DF_TRANSFER_SRGB", "KHR_DF_PRIMARIES_BT709", "KHR_DF_SAMPLE_DATATYPE_SIGNED", "VK_FORMAT_UNDEFINED", "KTX2Container", "constructor", "vkFormat", "VK_FORMAT_UNDEFINED", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "supercompressionScheme", "KHR_SUPERCOMPRESSION_NONE", "levels", "dataFormatDescriptor", "vendorId", "KHR_DF_VENDORID_KHRONOS", "descriptorType", "KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT", "descriptorBlockSize", "versionNumber", "KHR_DF_VERSION", "colorModel", "KHR_DF_MODEL_UNSPECIFIED", "colorPrimaries", "KHR_DF_PRIMARIES_BT709", "transferFunction", "KHR_DF_TRANSFER_SRGB", "flags", "KHR_DF_FLAG_ALPHA_STRAIGHT", "texelBlockDimension", "bytesPlane", "samples", "keyValue", "globalData", "BufferReader", "data", "byteOffset", "byteLength", "littleEndian", "_dataView", "_littleEndian", "_offset", "DataView", "buffer", "_nextUint8", "value", "getUint8", "_nextUint16", "getUint16", "_nextUint32", "getUint32", "_nextUint64", "left", "right", "_nextInt32", "getInt32", "_nextUint8Array", "len", "Uint8Array", "_skip", "bytes", "_scan", "maxByteLength", "term", "NUL", "Uint8Array", "KTX2_ID", "decodeText", "buffer", "TextDecoder", "decode", "read", "data", "id", "Uint8Array", "buffer", "byteOffset", "KTX2_ID", "length", "Error", "container", "KTX2Container", "headerByteLength", "Uint32Array", "BYTES_PER_ELEMENT", "headerReader", "BufferReader", "vkFormat", "_nextUint32", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "levelCount", "supercompressionScheme", "dfdByteOffset", "dfdByteLength", "kvdByteOffset", "kvdByteLength", "sgdByteOffset", "_nextUint64", "sgdByteLength", "levelByteLength", "levelReader", "i", "levels", "push", "levelData", "uncompressedByteLength", "dfdReader", "dfd", "vendorId", "_skip", "_nextUint16", "descriptorType", "versionNumber", "descriptorBlockSize", "colorModel", "_nextUint8", "colorPrimaries", "transferFunction", "flags", "texelBlockDimension", "bytesPlane", "samples", "sampleStart", "sampleWords", "numSamples", "sample", "bitOffset", "bitLength", "channelType", "samplePosition", "sampleLower", "sampleUpper", "Infinity", "KHR_DF_SAMPLE_DATATYPE_SIGNED", "_nextInt32", "dataFormatDescriptor", "kvdReader", "_offset", "keyValueByteLength", "keyData", "_scan", "key", "decodeText", "keyValue", "_nextUint8Array", "byteLength", "match", "text", "substring", "lastIndexOf", "kvPadding", "sgdReader", "endpointCount", "selectorCount", "endpointsByteLength", "selectorsByteLength", "tablesByteLength", "extendedByteLength", "imageDescs", "imageFlags", "rgbSliceByteOffset", "rgbSliceByteLength", "alphaSliceByteOffset", "alphaSliceByteLength", "endpointsByteOffset", "selectorsByteOffset", "tablesByteOffset", "extendedByteOffset", "endpointsData", "selectorsData", "tablesData", "extendedData", "globalData", "EXT_MESH_GPU_INSTANCING", "EXT_MESHOPT_COMPRESSION", "EXT_TEXTURE_WEBP", "EXT_TEXTURE_AVIF", "KHR_DRACO_MESH_COMPRESSION", "KHR_LIGHTS_PUNCTUAL", "KHR_MATERIALS_ANISOTROPY", "KHR_MATERIALS_CLEARCOAT", "KHR_MATERIALS_DIFFUSE_TRANSMISSION", "KHR_MATERIALS_DISPERSION", "KHR_MATERIALS_EMISSIVE_STRENGTH", "KHR_MATERIALS_IOR", "KHR_MATERIALS_IRIDESCENCE", "KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS", "KHR_MATERIALS_SHEEN", "KHR_MATERIALS_SPECULAR", "KHR_MATERIALS_TRANSMISSION", "KHR_MATERIALS_UNLIT", "KHR_MATERIALS_VOLUME", "KHR_MATERIALS_VARIANTS", "KHR_MESH_QUANTIZATION", "KHR_TEXTURE_BASISU", "KHR_TEXTURE_TRANSFORM", "KHR_XMP_JSON_LD", "INSTANCE_ATTRIBUTE", "InstancedMesh", "ExtensionProperty", "init", "extensionName", "propertyType", "parentTypes", "PropertyType", "NODE", "getDefaults", "Object", "assign", "attributes", "RefMap", "getAttribute", "semantic", "getRefMap", "setAttribute", "accessor", "setRefMap", "usage", "listAttributes", "listRefMapValues", "listSemantics", "listRefMapKeys", "EXTENSION_NAME", "NAME", "EXTMeshGPUInstancing", "Extension", "constructor", "args", "provideTypes", "prewriteTypes", "ACCESSOR", "createInstancedMesh", "document", "getGraph", "read", "context", "jsonDoc", "nodeDefs", "json", "nodes", "forEach", "nodeDef", "nodeIndex", "extensions", "instancedMeshDef", "instancedMesh", "accessors", "setExtension", "prewrite", "accessorUsageGroupedByParent", "add", "prop", "properties", "attribute", "addAccessorToUsageGroup", "write", "getRoot", "listNodes", "node", "getExtension", "nodeIndexMap", "get", "accessorIndexMap", "EncoderMethod", "MeshoptMode", "MeshoptFilter", "BYTE", "SHORT", "FLOAT", "Accessor", "ComponentType", "encodeNormalizedInt", "decodeNormalizedInt", "MathUtils", "prepareAccessor", "encoder", "mode", "filterOptions", "filter", "bits", "result", "array", "getArray", "byteStride", "getElementSize", "getComponentSize", "componentType", "getComponentType", "normalized", "getNormalized", "ATTRIBUTES", "NONE", "decodeNormalizedIntArray", "Float32Array", "EXPONENTIAL", "encodeFilterExp", "getCount", "OCTAHEDRAL", "padNormals", "encodeFilterOct", "QUATERNION", "encodeFilterQuat", "Error", "min", "getMin", "max", "getMax", "map", "v", "padArrayElements", "byteLength", "srcArray", "dstArray", "length", "i", "elementSize", "BufferUtils", "padNumber", "BYTES_PER_ELEMENT", "elementStride", "elementCount", "j", "il", "getMeshoptMode", "WriterContext", "BufferViewUsage", "ELEMENT_ARRAY_BUFFER", "isTriangles", "listParents", "some", "parent", "Primitive", "getMode", "Mode", "TRIANGLES", "INDICES", "getMeshoptFilter", "doc", "refs", "listParentEdges", "edge", "getParent", "Root", "ref", "refName", "getName", "refKey", "getAttributes", "key", "isDelta", "PRIMITIVE_TARGET", "startsWith", "targetPath", "getTargetPath", "sampler", "AnimationSampler", "channel", "AnimationChannel", "isFallbackBuffer", "bufferDef", "fallbackDef", "fallback", "DEFAULT_ENCODER_OPTIONS", "method", "QUANTIZE", "EXTMeshoptCompression", "prereadTypes", "BUFFER", "PRIMITIVE", "readDependencies", "writeDependencies", "_decoder", "_decoderFallbackBufferMap", "Map", "_encoder", "_encoderOptions", "_encoderFallbackBuffer", "_encoderBufferViews", "_encoderBufferViewData", "_encoderBufferViewAccessors", "install", "dependency", "setEncoderOptions", "options", "_extends", "preread", "isRequired", "supported", "_prereadBuffers", "_prereadPrimitives", "viewDefs", "bufferViews", "viewDef", "index", "meshoptDef", "byteOffset", "count", "stride", "Uint8Array", "buffers", "buffer", "resource", "uri", "resources", "GLB_BUFFER", "source", "toView", "decodeGltfBuffer", "fallbackBuffer", "fallbackBufferDef", "set", "_context", "swap", "dispose", "_prewriteAccessors", "_prewriteBuffers", "graph", "createBuffer", "fallbackBufferIndex", "listBuffers", "indexOf", "nextID", "parentToID", "getParentID", "property", "ROOT", "id", "undefined", "listAccessors", "getSparse", "getAccessorUsage", "parentID", "has", "FILTER", "preparedAccessor", "getBuffer", "bufferIndex", "join", "bufferView", "bufferViewData", "bufferViewAccessors", "target", "USAGE_TO_TARGET", "ARRAY_BUFFER", "accessorDef", "createAccessorDef", "push", "EXT_meshopt_compression", "otherBufferViews", "concat", "encodeGltfBuffer", "compressedData", "pad", "fallbackBufferByteOffset", "bufferViewIndex", "otherBufferViewsIndexMap", "finalBufferViewDef", "compressedByteOffset", "bufferViewExtensionDef", "bufferIndexMap", "AVIFImageUtils", "match", "decodeText", "slice", "getSize", "view", "DataView", "box", "unbox", "offset", "end", "type", "start", "getUint32", "getChannels", "_buffer", "EXTTextureAVIF", "TEXTURE", "register", "ImageUtils", "registerFormat", "textureDefs", "textures", "textureDef", "listTextures", "texture", "getMimeType", "imageIndex", "imageIndexMap", "data", "size", "WEBPImageUtils", "RIFF", "WEBP", "chunkId", "getUint8", "chunkByteLength", "width", "getInt16", "height", "b0", "b1", "b2", "b3", "EXTTextureWebP", "decoderModule", "COMPONENT_ARRAY", "DATA_TYPE", "decodeGeometry", "decoder", "DecoderBuffer", "Init", "geometryType", "GetEncodedGeometryType", "TRIANGULAR_MESH", "dracoMesh", "Mesh", "status", "DecodeBufferToMesh", "ok", "ptr", "destroy", "decodeIndex", "mesh", "numFaces", "num_faces", "numIndices", "indices", "num_points", "Uint16Array", "_malloc", "GetTrianglesUInt16Array", "HEAPU16", "Uint32Array", "GetTrianglesUInt32Array", "HEAPU32", "_free", "decodeAttribute", "dataType", "ArrayCtor", "numComponents", "num_components", "numPoints", "numValues", "GetAttributeDataArrayForAllPoints", "HEAPF32", "initDecoderModule", "_decoderModule", "UNSIGNED_INT", "UNSIGNED_SHORT", "UNSIGNED_BYTE", "Int16Array", "Int8Array", "DT_FLOAT32", "DT_UINT32", "DT_UINT16", "DT_UINT8", "DT_INT16", "DT_INT8", "encoderModule", "AttributeEnum", "DEFAULT_QUANTIZATION_BITS", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "GENERIC", "decodeSpeed", "encodeSpeed", "EDGEBREAKER", "quantizationBits", "quantizationVolume", "initEncoderModule", "_encoderModule", "encodeGeometry", "prim", "_options", "builder", "MeshBuilder", "ExpertEncoder", "attributeIDs", "dracoBuffer", "DracoInt8Array", "hasMorphTargets", "listTargets", "hasSparseAttributes", "attributeEnum", "getAttributeEnum", "attributeID", "addAttribute", "SetAttributeQuantization", "range", "Math", "SetAttributeExplicitQuantization", "getIndices", "EncodingError", "AddFacesToMesh", "SetSpeedOptions", "SetTrackEncodedProperties", "SEQUENTIAL", "SetEncodingMethod", "MESH_SEQUENTIAL_ENCODING", "MESH_EDGEBREAKER_ENCODING", "EncodeToDracoBuffer", "GetValue", "numVertices", "GetNumberOfEncodedPoints", "GetNumberOfEncodedFaces", "itemSize", "AddUInt8Attribute", "AddInt8Attribute", "AddUInt16Attribute", "AddInt16Attribute", "AddUInt32Attribute", "AddFloatAttribute", "KHRDracoMeshCompression", "logger", "getLogger", "dracoMeshes", "meshDefs", "meshes", "meshDef", "primDef", "primitives", "dracoDef", "bufferViewDef", "Decoder", "debug", "dracoAttribute", "GetAttributeByUniqueId", "attributeArray", "setArray", "Array", "from", "values", "_propertyType", "JSON", "stringify", "primitiveHashMap", "listDracoPrimitives", "primitiveEncodingMap", "listScenes", "warn", "getBounds", "pop", "keys", "primHash", "accessorDefs", "encodedPrim", "e", "message", "indicesDef", "attributeDef", "extensionData", "dracoContext", "listMeshes", "meshIndexMap", "listPrimitives", "extensionsUsed", "name", "extensionsRequired", "included", "Set", "excluded", "nonIndexed", "nonTriangles", "accessorIndices", "includedAccessors", "includedHashKeys", "primToHashKey", "hashKey", "createHashKey", "dstIndices", "clone", "dstAttribute", "attr", "indexMap", "hashElements", "sort", "Light", "color", "intensity", "Type", "POINT", "innerConeAngle", "outerConeAngle", "PI", "getColor", "setColor", "getIntensity", "setIntensity", "getType", "setType", "getRange", "setRange", "getInnerConeAngle", "setInnerConeAngle", "angle", "getOuterConeAngle", "setOuterConeAngle", "SPOT", "DIRECTIONAL", "KHRLightsPunctual", "createLight", "rootDef", "lightDefs", "lights", "lightDef", "_lightDef$spot", "_lightDef$spot2", "light", "setName", "spot", "lightNodeDef", "lightIndexMap", "eq", "R", "G", "B", "TextureChannel", "Anisotropy", "MATERIAL", "anisotropyStrength", "anisotropyRotation", "anisotropyTexture", "anisotropyTextureInfo", "TextureInfo", "getAnisotropyStrength", "setAnisotropyStrength", "strength", "getAnisotropyRotation", "setAnisotropyRotation", "rotation", "getAnisotropyTexture", "getRef", "getAnisotropyTextureInfo", "setAnisotropyTexture", "setRef", "channels", "KHRMaterialsAnisotropy", "MESH", "createAnisotropy", "materialDefs", "materials", "materialDef", "materialIndex", "anisotropy", "anisotropyDef", "textureInfoDef", "setTextureInfo", "listMaterials", "material", "materialIndexMap", "textureInfo", "createTextureInfoDef", "Clearcoat", "clearcoatFactor", "clearcoatTexture", "clearcoatTextureInfo", "clearcoatRoughnessFactor", "clearcoatRoughnessTexture", "clearcoatRoughnessTextureInfo", "clearcoatNormalScale", "clearcoatNormalTexture", "clearcoatNormalTextureInfo", "getClearcoatFactor", "setClearcoatFactor", "factor", "getClearcoatTexture", "getClearcoatTextureInfo", "setClearcoatTexture", "getClearcoatRoughnessFactor", "setClearcoatRoughnessFactor", "getClearcoatRoughnessTexture", "getClearcoatRoughnessTextureInfo", "setClearcoatRoughnessTexture", "getClearcoatNormalScale", "setClearcoatNormalScale", "scale", "getClearcoatNormalTexture", "getClearcoatNormalTextureInfo", "setClearcoatNormalTexture", "KHRMaterialsClearcoat", "createClearcoat", "clearcoat", "clearcoatDef", "A", "DiffuseTransmission", "diffuseTransmissionFactor", "diffuseTransmissionTexture", "diffuseTransmissionTextureInfo", "diffuseTransmissionColorFactor", "diffuseTransmissionColorTexture", "diffuseTransmissionColorTextureInfo", "getDiffuseTransmissionFactor", "setDiffuseTransmissionFactor", "getDiffuseTransmissionTexture", "getDiffuseTransmissionTextureInfo", "setDiffuseTransmissionTexture", "getDiffuseTransmissionColorFactor", "setDiffuseTransmissionColorFactor", "getDiffuseTransmissionColorTexture", "getDiffuseTransmissionColorTextureInfo", "setDiffuseTransmissionColorTexture", "KHRMaterialsDiffuseTransmission", "createDiffuseTransmission", "transmission", "transmissionDef", "Dispersion", "dispersion", "getDispersion", "setDispersion", "KHRMaterialsDispersion", "createDispersion", "dispersionDef", "EmissiveStrength", "emissiveStrength", "getEmissiveStrength", "setEmissiveStrength", "KHRMaterialsEmissiveStrength", "createEmissiveStrength", "emissiveStrengthDef", "IOR", "ior", "getIOR", "setIOR", "KHRMaterialsIOR", "createIOR", "iorDef", "Iridescence", "iridescenceFactor", "iridescenceTexture", "iridescenceTextureInfo", "iridescenceIOR", "iridescenceThicknessMinimum", "iridescenceThicknessMaximum", "iridescenceThicknessTexture", "iridescenceThicknessTextureInfo", "getIridescenceFactor", "setIridescenceFactor", "getIridescenceTexture", "getIridescenceTextureInfo", "setIridescenceTexture", "getIridescenceIOR", "setIridescenceIOR", "getIridescenceThicknessMinimum", "setIridescenceThicknessMinimum", "thickness", "getIridescenceThicknessMaximum", "setIridescenceThicknessMaximum", "getIridescenceThicknessTexture", "getIridescenceThicknessTextureInfo", "setIridescenceThicknessTexture", "KHRMaterialsIridescence", "createIridescence", "iridescence", "iridescenceDef", "iridescenceIor", "PBRSpecularGlossiness", "diffuseFactor", "diffuseTexture", "diffuseTextureInfo", "specularFactor", "glossinessFactor", "specularGlossinessTexture", "specularGlossinessTextureInfo", "getDiffuseFactor", "setDiffuseFactor", "getDiffuseTexture", "getDiffuseTextureInfo", "setDiffuseTexture", "isColor", "getSpecularFactor", "setSpecularFactor", "getGlossinessFactor", "setGlossinessFactor", "getSpecularGlossinessTexture", "getSpecularGlossinessTextureInfo", "setSpecularGlossinessTexture", "KHRMaterialsPBRSpecularGlossiness", "createPBRSpecularGlossiness", "specGloss", "specGlossDef", "Sheen", "sheenColorFactor", "sheenColorTexture", "sheenColorTextureInfo", "sheenRoughnessFactor", "sheenRoughnessTexture", "sheenRoughnessTextureInfo", "getSheenColorFactor", "setSheenColorFactor", "getSheenColorTexture", "getSheenColorTextureInfo", "setSheenColorTexture", "getSheenRoughnessFactor", "setSheenRoughnessFactor", "getSheenRoughnessTexture", "getSheenRoughnessTextureInfo", "setSheenRoughnessTexture", "KHRMaterialsSheen", "createSheen", "sheen", "sheenDef", "Specular", "specularTexture", "specularTextureInfo", "specularColorFactor", "specularColorTexture", "specularColorTextureInfo", "getSpecularColorFactor", "setSpecularColorFactor", "getSpecularTexture", "getSpecularTextureInfo", "setSpecularTexture", "getSpecularColorTexture", "getSpecularColorTextureInfo", "setSpecularColorTexture", "KHRMaterialsSpecular", "createSpecular", "specular", "specularDef", "Transmission", "transmissionFactor", "transmissionTexture", "transmissionTextureInfo", "getTransmissionFactor", "setTransmissionFactor", "getTransmissionTexture", "getTransmissionTextureInfo", "setTransmissionTexture", "KHRMaterialsTransmission", "createTransmission", "Unlit", "KHRMaterialsUnlit", "createUnlit", "Mapping", "variants", "RefSet", "getMaterial", "setMaterial", "addVariant", "variant", "addRef", "removeVariant", "removeRef", "listVariants", "listRefs", "MappingList", "mappings", "addMapping", "mapping", "removeMapping", "listMappings", "Variant", "KHRMaterialsVariants", "createMappingList", "createVariant", "createMapping", "variantsRootDef", "variantDefs", "variantDef", "meshIndex", "primDefs", "primIndex", "mappingList", "variantPrimDef", "mappingDef", "variantIndex", "variantIndexMap", "createPropertyDef", "mappingDefs", "Volume", "thicknessFactor", "thicknessTexture", "thicknessTextureInfo", "attenuationDistance", "Infinity", "attenuationColor", "getThicknessFactor", "setThicknessFactor", "getThicknessTexture", "getThicknessTextureInfo", "setThicknessTexture", "getAttenuationDistance", "setAttenuationDistance", "distance", "getAttenuationColor", "setAttenuationColor", "KHRMaterialsVolume", "createVolume", "volume", "volumeDef", "Number", "isFinite", "KHRMeshQuantization", "_", "KTX2ImageUtils", "container", "readKTX", "pixelWidth", "pixelHeight", "dfd", "dataFormatDescriptor", "colorModel", "KHR_DF_MODEL_ETC1S", "samples", "channelType", "KHR_DF_MODEL_UASTC", "getVRAMByteLength", "hasAlpha", "uncompressedBytes", "levels", "level", "uncompressedByteLength", "levelWidth", "floor", "pow", "levelHeight", "blockSize", "KHRTextureBasisu", "basisuDef", "Transform", "TEXTURE_INFO", "texCoord", "getOffset", "setOffset", "getRotation", "setRotation", "getScale", "setScale", "getTexCoord", "setTexCoord", "KHRTextureTransform", "createTransform", "textureInfos", "entries", "transform", "transformDef", "textureInfoEntries", "textureInfoDefMap", "PARENT_TYPES", "SCENE", "ANIMATION", "Packet", "getContext", "setContext", "listProperties", "getProperty", "setProperty", "value", "_assertContext", "toJSONLD", "copyJSON", "fromJSONLD", "jsonld", "prefix", "split", "object", "parse", "KHRXMP", "createPacket", "listPackets", "_context$jsonDoc$json", "extensionDef", "packets", "root", "packetDef", "defLists", "asset", "scenes", "images", "animations", "propertyLists", "listAnimations", "defs", "def", "xmpDef", "packet", "packetDefs", "parentDef", "sceneIndexMap", "animationIndexMap", "KHRONOS_EXTENSIONS", "ALL_EXTENSIONS", "filterValue", "x", "a", "xPi", "Math", "PI", "sin", "filters", "srcSize", "destSize", "scale", "offset", "use2", "floatType", "intType", "fixedFracBits", "mul", "toFixedPoint", "value", "round", "scaleInverted", "scaleClamped", "min", "srcWindow", "packedFilter", "floor", "packedFilterPtr", "destPixel", "sourcePixel", "sourceFirst", "max", "sourceLast", "ceil", "filterElementSize", "floatFilter", "fxpFilter", "total", "index", "pixel", "floatValue", "filterTotal", "length", "leftNotEmpty", "rightNotEmpty", "filterSize", "set", "subarray", "convolve", "src", "dst", "_", "srcHeight", "shape", "dstWidth", "maxValue", "data", "BYTES_PER_ELEMENT", "clamp", "v", "fixedFracMul", "fixedFracMul2", "srcY", "dstY", "filterPtr", "dstX", "srcX", "r", "g", "b", "get", "Method", "resize", "method", "TypeError", "srcWidth", "dstHeight", "ratioX", "ratioY", "dtype", "Float32Array", "Int16Array", "Float64Array", "Int32Array", "filtersX", "LANCZOS_2", "filtersY", "tmp", "ndarray", "constructor", "tmpTranspose", "transpose", "dstTranspose", "lanczos3", "LANCZOS_3", "lanczos2", "POINTS", "LINES", "LINE_STRIP", "LINE_LOOP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN", "Primitive", "Mode", "createTransform", "name", "fn", "Object", "defineProperty", "value", "isTransformPending", "context", "initial", "pending", "initialIndex", "stack", "lastIndexOf", "pendingIndex", "assignDefaults", "defaults", "options", "result", "_extends", "key", "undefined", "rewriteTexture", "source", "target", "srcImage", "getImage", "pixels", "getPixels", "getMimeType", "i", "shape", "j", "dstImage", "savePixels", "setImage", "setMimeType", "getGLPrimitiveCount", "prim", "indices", "getIndices", "position", "getAttribute", "getMode", "getCount", "Error", "SetMap", "constructor", "_map", "Map", "size", "has", "k", "add", "v", "entry", "get", "Set", "set", "keys", "formatBytes", "bytes", "decimals", "dm", "sizes", "Math", "floor", "log", "parseFloat", "pow", "toFixed", "formatLong", "x", "toString", "replace", "formatDelta", "a", "b", "prefix", "suffix", "abs", "formatDeltaOp", "deepListAttributes", "accessors", "attribute", "listAttributes", "push", "listTargets", "Array", "from", "deepSwapAttribute", "src", "dst", "swap", "shallowEqualsArray", "length", "shallowCloneAccessor", "document", "accessor", "createAccessor", "getName", "setArray", "getArray", "setType", "getType", "setBuffer", "getBuffer", "setNormalized", "getNormalized", "setSparse", "getSparse", "createIndices", "count", "maxIndex", "array", "createIndicesEmpty", "Uint16Array", "Uint32Array", "isUsed", "prop", "listParents", "some", "parent", "propertyType", "PropertyType", "ROOT", "isEmptyObject", "object", "createPrimGroupKey", "Document", "fromGraph", "getGraph", "material", "getMaterial", "materialIndex", "getRoot", "listMaterials", "indexOf", "mode", "BASIC_MODE_MAPPING", "attributes", "listSemantics", "sort", "map", "semantic", "elementSize", "getElementSize", "componentType", "getComponentType", "join", "targets", "fitWithin", "limit", "maxWidth", "maxHeight", "srcWidth", "srcHeight", "dstWidth", "dstHeight", "fitPowerOfTwo", "method", "isPowerOfTwo", "nearestPowerOfTwo", "ceilPowerOfTwo", "floorPowerOfTwo", "lo", "hi", "LN2", "ceil", "NAME", "CENTER_DEFAULTS", "pivot", "center", "_options", "doc", "logger", "getLogger", "root", "isAnimated", "listAnimations", "listSkins", "listScenes", "forEach", "scene", "index", "debug", "bbox", "getBounds", "max", "min", "offset", "offsetNode", "createNode", "setTranslation", "listChildren", "child", "addChild", "t", "getTranslation", "listNodeScenes", "node", "visited", "getParentNode", "filter", "Scene", "clearNodeParent", "scenes", "setMatrix", "getWorldMatrix", "removeChild", "invert", "multiply", "s", "create", "glMatrix.ARRAY_TYPE", "scale", "len", "mul", "DEDUP_DEFAULTS", "keepUniqueNames", "propertyTypes", "ACCESSOR", "MESH", "TEXTURE", "MATERIAL", "SKIN", "dedup", "includes", "dedupAccessors", "dedupImages", "dedupMaterials", "dedupMeshes", "dedupSkins", "indicesMap", "attributeMap", "inputMap", "outputMap", "meshes", "listMeshes", "mesh", "listPrimitives", "primitive", "hashAccessor", "animation", "sampler", "listSamplers", "getInput", "getOutput", "group", "hash", "hashSet", "detectDuplicates", "duplicates", "aData", "BufferUtils", "toView", "equals", "total", "hashGroup", "values", "input", "output", "dispose", "refs", "listAccessors", "numMeshes", "uniqueMeshes", "srcKeyItems", "createPrimitiveKey", "meshKey", "targetMesh", "textures", "listTextures", "bData", "aSize", "getSize", "bSize", "entries", "property", "Root", "materials", "modifierCache", "skip", "hasModifier", "skins", "listJoints", "primKeyItems", "cache", "graph", "visitedNodes", "edgeQueue", "listParentEdges", "edge", "pop", "getAttributes", "modifyChild", "getChild", "childEdge", "listChildEdges", "SRGB_PATTERN", "getTextureColorSpace", "texture", "edges", "isSRGB", "isColor", "test", "listTextureInfo", "results", "textureEdge", "getParent", "TextureInfo", "listTextureInfoByMaterial", "traverse", "textureInfoNames", "Texture", "ExtensionProperty", "listTextureSlots", "slots", "EPS", "PRUNE_DEFAULTS", "NODE", "CAMERA", "PRIMITIVE", "PRIMITIVE_TARGET", "ANIMATION", "BUFFER", "keepLeaves", "keepAttributes", "keepIndices", "keepSolidTextures", "keepExtras", "prune", "counter", "DisposeCounter", "onDispose", "event", "addEventListener", "nodeTreeShake", "listNodes", "treeShake", "skin", "camera", "listCameras", "indirectTreeShake", "materialPrims", "required", "listRequiredSemantics", "unused", "listUnusedSemantics", "pruneAttributes", "prims", "shiftTexCoords", "pruneIndices", "anim", "channel", "listChannels", "getTargetNode", "samplers", "pruneSolidTextures", "listBuffers", "buffer", "removeEventListener", "empty", "str", "type", "info", "disposed", "parents", "p", "AnimationChannel", "needsExtras", "getExtras", "listEdges", "e", "ptype", "SCENE", "isEmpty", "setAttribute", "indicesArray", "il", "setIndices", "startsWith", "semantics", "textureNames", "getTexCoord", "match", "isLit", "Material", "getExtension", "isPoints", "textureInfoList", "texCoordSet", "texCoordList", "texCoordMap", "texCoord", "semanticMap", "textureInfo", "setTexCoord", "updatePrim", "srcSemantics", "srcSemantic", "uv", "dstSemantic", "_texture$getSize", "factor", "getTextureFactor", "ColorUtils", "convertSRGBToLinear", "getURI", "applyMaterialFactor", "Promise", "all", "slot", "setBaseColorFactor", "getBaseColorFactor", "setEmissiveFactor", "mulVec3", "slice", "getEmissiveFactor", "setRoughnessFactor", "getRoughnessFactor", "setMetallicFactor", "getMetallicFactor", "sub", "warn", "maybeGetPixels", "Infinity", "width", "height", "EMPTY_U32", "VertexStream", "u8", "u32", "byteStride", "_initAttribute", "Uint8Array", "byteOffset", "byteLength", "getComponentSize", "paddedByteStride", "padNumber", "murmurHash2", "equal", "h", "m", "r", "imul", "hashLookup", "table", "buckets", "stream", "hashmod", "hashval", "bucket", "probe", "item", "VertexCountMethod", "getSceneVertexCount", "_getSubtreeVertexCount", "getNodeVertexCount", "instancedMeshes", "nonInstancedMeshes", "getMesh", "batch", "flatMap", "positions", "uniquePositions", "uniquePrims", "RENDER", "RENDER_CACHED", "_sum", "getMeshVertexCount", "UPLOAD_NAIVE", "UPLOAD", "DISTINCT", "DISTINCT_POSITION", "_assertNotImplemented", "UNUSED", "_sumUnused", "_assertUnreachable", "getPrimitiveVertexCount", "attributeIndexMap", "indicesSet", "usedIndices", "compactPrimitive", "remap", "dstVertexCount", "createCompactPlan", "srcIndices", "srcIndicesArray", "srcIndicesCount", "dstIndices", "dstIndicesCount", "dstIndicesArray", "srcAttributesPrev", "srcAttribute", "dstAttribute", "compactAttribute", "srcArray", "dstArray", "dstDone", "srcIndex", "dstIndex", "srcVertexCount", "fill", "WELD_DEFAULTS", "overwrite", "cleanup", "weld", "weldPrimitive", "transform", "tableSize", "writeMap", "hashIndex", "FLOAT", "Accessor", "ComponentType", "transformPrimitive", "matrix", "applyMatrix", "normal", "applyNormalMatrix", "tangent", "applyTangentMatrix", "determinant", "reversePrimitiveWindingOrder", "normalized", "Float32Array", "vector", "createVec3", "MathUtils", "decodeNormalizedInt", "transformMat4", "normalMatrix", "createMat3", "fromMat4", "transpose", "transformMat3", "normalizeVec3", "v3", "getScalar", "c", "setScalar", "transformMesh", "srcPrim", "dstPrim", "shallowClonePrimitive", "removePrimitive", "addPrimitive", "parentMesh", "isSharedPrimitive", "Mesh", "clone", "isSharedTarget", "removeTarget", "addTarget", "IDENTITY", "clearNodeTransform", "localMatrix", "getMatrix", "eq", "multiplyMat4", "convertPrimitiveToLines", "dstGLPrimitiveCount", "IndicesArray", "ComponentTypeToTypedArray", "srcMode", "setMode", "convertPrimitiveToTriangles", "DEQUANTIZE_DEFAULTS", "pattern", "dequantize", "dequantizePrimitive", "createExtension", "KHRMeshQuantization", "dequantizeAttribute", "dequantizeAttributeArray", "TEXTURE_INFO", "NO_TRANSFER_TYPES", "cloneDocument", "setLogger", "resolve", "createDefaultPropertyResolver", "mergeDocuments", "copy", "sourceExtension", "listExtensionsUsed", "targetExtension", "isRequired", "setRequired", "_copyToDocument", "listNonRootProperties", "moveToDocument", "sourceProperties", "targetProperties", "copyToDocument", "sourcePropertyDependencies", "listPropertyDependencies", "propertyMap", "sourceProp", "targetProp", "PropertyClass", "queue", "next", "DRACO_DEFAULTS", "encodeSpeed", "decodeSpeed", "quantizePosition", "quantizeNormal", "quantizeColor", "quantizeTexcoord", "quantizeGeneric", "quantizationVolume", "draco", "KHRDracoMeshCompression", "setEncoderOptions", "EncoderMethod", "EDGEBREAKER", "SEQUENTIAL", "quantizationBits", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "GENERIC", "FLATTEN_DEFAULTS", "flatten", "joints", "joint", "animated", "getTargetPath", "hasJointParent", "hasAnimatedParent", "_getBounds", "inspect", "animations", "sceneBounds", "rootName", "bboxMin", "toPrecision", "bboxMax", "renderVertexCount", "uploadVertexCount", "uploadNaiveVertexCount", "properties", "instances", "glPrimitives", "meshIndices", "meshAccessors", "attr", "accessorToTypeLabel", "targ", "modes", "MeshPrimitiveModeLabels", "meshPrimitives", "vertices", "extensions", "listExtensions", "ref", "alphaMode", "getAlphaMode", "doubleSided", "getDoubleSided", "resolution", "ImageUtils", "compression", "container", "readKTX", "dfd", "dataFormatDescriptor", "colorModel", "KHR_DF_MODEL_ETC1S", "KHR_DF_MODEL_UASTC", "uri", "mimeType", "gpuSize", "getVRAMByteLength", "minTime", "maxTime", "getMin", "getMax", "keyframes", "channels", "duration", "round", "NumericTypeLabels", "Int32Array", "Int16Array", "Int8Array", "Number", "base", "INSTANCE_DEFAULTS", "instance", "batchExtension", "EXTMeshGPUInstancing", "numBatches", "numInstances", "meshInstances", "modifiedNodes", "nodes", "getSkin", "hasVolume", "hasScale", "createBatch", "batchTranslation", "batchRotation", "batchScale", "batchNode", "setMesh", "setExtension", "needsTranslation", "needsRotation", "needsScale", "setElement", "getWorldTranslation", "getWorldRotation", "getWorldScale", "pruneUnusedNodes", "listProperties", "unusedNodes", "getCamera", "nodeParent", "createInstancedMesh", "JOIN_PRIMITIVE_DEFAULTS", "skipValidation", "joinPrimitives", "templatePrim", "primRemaps", "primVertexCounts", "primIndex", "createPrimitive", "setMaterial", "tplAttribute", "AttributeArray", "tplIndices", "dstIndicesOffset", "remapIndices", "remapAttribute", "done", "dstOffset", "srcCount", "_matrix", "JOIN_DEFAULTS", "keepMeshes", "keepNamed", "_joinLevel", "groups", "children", "nodeIndex", "dequantizeTransformableAttributes", "isNamed", "primMeshes", "primNodes", "dstNode", "dstMesh", "joinGroups", "srcNodes", "isSharedMesh", "dstMatrix", "primNode", "primMesh", "_deepClonePrimitive", "listTextureChannels", "mask", "getTextureChannelMask", "TextureChannel", "R", "G", "B", "A", "AlphaMode", "OPAQUE", "REORDER_DEFAULTS", "reorder", "encoder", "ready", "plan", "createLayoutPlan", "indicesToAttributes", "unique", "reorderMesh", "indicesToMode", "indicesToPrimitives", "attributesToPrimitives", "sortPrimitiveWeights", "isFinite", "vertexCount", "setCount", "srcWeights", "dstWeights", "srcJoints", "dstJoints", "getVertexArray", "setVertexArray", "weights", "normalizePrimitiveWeights", "isNormalizeSafe", "templateAttribute", "templateArray", "normalizedComponentType", "delta", "EPSILON", "weightsSum", "sum", "floatValue", "encodeNormalizedInt", "sign", "vertexIndex", "el", "getElement", "normList", "typeList", "SIGNED_INT", "TRANSLATION", "ROTATION", "SCALE", "WEIGHTS", "TargetPath", "TRS_CHANNELS", "QUANTIZE_DEFAULTS", "quantizeWeight", "normalizeWeights", "quantize", "patternTargets", "nodeTransform", "getNodeTransform", "expandBounds", "getPositionQuantizationVolume", "transformMeshParents", "transformMeshMaterials", "renderCount", "uploadCount", "quantizePrimitive", "needsExtension", "isQuantizedPrimitive", "isTarget", "PrimitiveTarget", "bits", "ctor", "getQuantizationSettings", "fromTransform", "fromScaling", "quantizeAttribute", "volume", "transformMatrix", "Node", "animChannels", "isParentNode", "setSkin", "transformSkin", "transformBatch", "targetNode", "setTargetNode", "nodeMatrix", "inverseBindMatrices", "getInverseBindMatrices", "ibm", "setInverseBindMatrices", "_batch$getAttribute", "_batch$getAttribute2", "_batch$getAttribute3", "instanceTranslation", "instanceRotation", "instanceScale", "tpl", "T_IDENTITY", "R_IDENTITY", "S_IDENTITY", "instanceMatrix", "compose", "decompose", "getThicknessFactor", "setThicknessFactor", "signBits", "quantBits", "storageBits", "BYTES_PER_ELEMENT", "range", "di", "clamp", "getMinNormalized", "getMaxNormalized", "relativePositions", "flatBounds", "relMin", "relMax", "isQuantizedAttribute", "componentSize", "UNSIGNED_BYTE", "UNSIGNED_SHORT", "tmpMin", "tmpMax", "bboxes", "fromRotationTranslationScale", "MESHOPT_DEFAULTS", "level", "meshopt", "EXTMeshoptCompression", "QUANTIZE", "FILTER", "METALROUGH_DEFAULTS", "metalRough", "extensionsUsed", "ext", "extensionName", "iorExtension", "KHRMaterialsIOR", "specExtension", "KHRMaterialsSpecular", "specGlossExtension", "KHRMaterialsPBRSpecularGlossiness", "inputTextures", "specGloss", "specular", "createSpecular", "setSpecularFactor", "setSpecularColorFactor", "getSpecularFactor", "getSpecularGlossinessTexture", "getBaseColorTexture", "getMetallicRoughnessTexture", "getDiffuseFactor", "createIOR", "setIOR", "diffuseTexture", "getDiffuseTexture", "setBaseColorTexture", "getBaseColorTextureInfo", "getDiffuseTextureInfo", "sgTexture", "sgTextureInfo", "getSpecularGlossinessTextureInfo", "specularTexture", "createTexture", "setSpecularTexture", "setSpecularColorTexture", "getSpecularTextureInfo", "getSpecularColorTextureInfo", "glossinessFactor", "getGlossinessFactor", "metalRoughTexture", "roughness", "setMetallicRoughnessTexture", "getMetallicRoughnessTextureInfo", "tex", "UNWELD_DEFAULTS", "unweld", "unweldPrimitive", "unweldAttribute", "TypedArray", "NORMALS_DEFAULTS", "normals", "modified", "faceNormal", "computeNormal", "n", "normalize", "PALETTE_DEFAULTS", "blockSize", "palette", "materialKeys", "materialKeyMap", "materialProps", "baseColor", "emissive", "metallicRoughness", "encodeRGBA", "encodeFloat", "metallic", "keyCount", "w", "padWidth", "paletteTexturePixels", "skipProps", "props", "baseColorTexture", "emissiveTexture", "metallicRoughnessTexture", "setURI", "ndarray", "visitedKeys", "materialIndices", "paletteMaterials", "nextIndex", "convertLinearToSRGB", "writeBlock", "image", "nextPaletteMaterialIndex", "srcMaterial", "blockIndex", "baseUV", "padUV", "dstMaterial", "padStart", "setName", "setMinFilter", "MinFilter", "NEAREST", "setMagFilter", "MagFilter", "setEmissiveTexture", "getEmissiveTextureInfo", "hex", "PARTITION_DEFAULTS", "partition", "partitionMeshes", "partitionAnimations", "existingURIs", "meshIndex", "isArray", "createBuffer", "createBufferURI", "primTarget", "animIndex", "SANITIZE_BASENAME_RE", "basename", "existing", "InterpolationInternal", "EMPTY_ARRAY", "RESAMPLE_DEFAULTS", "resample", "resampleDebug", "tolerance", "accessorsVisited", "srcAccessorCount", "samplerTargetPaths", "getSampler", "samplerInterpolation", "getInterpolation", "tmpTimes", "toFloat32Array", "tmpValues", "dstCount", "srcTimes", "srcValues", "dstTimes", "fromFloat32Array", "dstValues", "setInput", "setOutput", "used", "dstAccessorCount", "SEQUENCE_DEFAULTS", "fps", "sequence", "sequenceNodes", "createAnimation", "animBuffer", "inputArray", "outputArray", "Type", "VEC3", "createAnimationSampler", "setInterpolation", "AnimationSampler", "Interpolation", "STEP", "createAnimationChannel", "setTargetPath", "setSampler", "addSampler", "addChannel", "SIMPLIFY_DEFAULTS", "ratio", "error", "lockBorder", "simplify", "simplifier", "numUnsupported", "simplifyPrimitive", "simplifyPoints", "_simplifyPoints", "srcIndexCount", "positionArray", "targetCount", "flags", "color", "colorArray", "colorStride", "useExperimentalFeatures", "compactMesh", "SPARSE_DEFAULTS", "sparse", "modifiedCount", "nonZeroCount", "TEXTURE_COMPRESS_SUPPORTED_FORMATS", "SUPPORTED_MIME_TYPES", "TextureResizeFilter", "TEXTURE_COMPRESS_DEFAULTS", "resizeFilter", "LANCZOS3", "formats", "quality", "effort", "lossless", "nearLossless", "limitInputPixels", "textureCompress", "targetFormat", "patternRe", "formatsRe", "slotsRe", "textureIndex", "textureLabel", "srcFormat", "getFormat", "dstFormat", "srcByteLength", "compressTexture", "dstByteLength", "flag", "webpExtension", "EXTTextureWebP", "avifExtension", "EXTTextureAVIF", "srcURI", "srcMimeType", "dstMimeType", "_encodeWithSharp", "_encodeWithNdarrayPixels", "resize", "srcExtension", "FileUtils", "extension", "mimeTypeToExtension", "dstExtension", "dstURI", "RegExp", "_srcMimeType", "encoderOptions", "getFormatFromMimeType", "toFormat", "srcSize", "dstSize", "fit", "kernel", "toBuffer", "srcPixels", "dstPixels", "lanczos3", "lanczos2", "format", "split", "srcMax", "dstMax", "TANGENTS_DEFAULTS", "tangents", "generateTangents", "attributeIDs", "tangentCache", "meshName", "filterPrimitive", "texcoordSemantic", "getNormalTexcoord", "texcoord", "positionID", "uuid", "normalID", "texcoordID", "prevTangent", "attributeHash", "tangentBuffer", "tangentArray", "normalTextureInfo", "getNormalTextureInfo", "unlit", "unlitExtension", "KHRMaterialsUnlit", "createUnlit", "UNPARTITION_DEFAULTS", "unpartition", "vertexColorSpace", "inputColorSpace", "toLowerCase", "converted", "sRGBToLinear", "updatePrimitive"]
}
