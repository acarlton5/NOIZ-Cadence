<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bootstrap Avatar Preview</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    body { margin: 0; }
    canvas { width: 100%; height: 100%; display: block; }
    .sidebar { width: 4rem; }
    .asset-card { cursor: pointer; }
    .asset-card.selected { outline: 2px solid #0d6efd; }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="row">
      <nav class="sidebar col-auto bg-dark min-vh-100 d-flex flex-column align-items-center py-3 text-white">
        <button class="btn btn-dark mb-3 active"><i class="bi bi-person"></i></button>
        <button class="btn btn-dark"><i class="bi bi-tshirt"></i></button>
      </nav>
      <main class="col-md-7 py-3">
        <h1 class="h4 mb-3">Assets</h1>
        <div id="assetGrid" class="row row-cols-2 row-cols-md-3 g-3">
          <div class="col">
            <div class="card asset-card selected" data-url="public/models/Teleporter Base.glb">
              <img src="public/images/wawasensei-white.png" class="card-img-top" alt="Teleporter Base">
              <div class="card-body p-2 text-center">
                <p class="card-text small mb-0">Teleporter Base</p>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="card asset-card" data-url="public/models/Teleporter Base.glb">
              <img src="public/images/wawasensei-white.png" class="card-img-top" alt="Hair">
              <div class="card-body p-2 text-center">
                <p class="card-text small mb-0">Hair</p>
              </div>
            </div>
          </div>
          <div class="col">
            <div class="card asset-card" data-url="public/models/Teleporter Base.glb">
              <img src="public/images/wawasensei-white.png" class="card-img-top" alt="Top">
              <div class="card-body p-2 text-center">
                <p class="card-text small mb-0">Top</p>
              </div>
            </div>
          </div>
        </div>
      </main>
      <aside class="col-md-5 py-3 d-flex flex-column">
        <div id="viewer" class="border rounded mb-3 flex-grow-1" style="min-height:400px"></div>
        <div class="mb-3">
          <label for="colorInput" class="form-label">Body Color</label>
          <input type="color" class="form-control form-control-color" id="colorInput" value="#ffccaa">
        </div>
      </aside>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/loaders/DRACOLoader.js": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/loaders/DRACOLoader.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    const viewer = document.getElementById('viewer');
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    viewer.appendChild(renderer.domElement);
    camera.aspect = viewer.clientWidth / viewer.clientHeight;
    camera.updateProjectionMatrix();

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(light);

    const modelGroup = new THREE.Group();
    scene.add(modelGroup);

    let avatar;
    const extras = new Map();
    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/libs/draco/');
    loader.setDRACOLoader(dracoLoader);

    function frame(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.5;
      camera.position.set(0, size.y * 0.5, cameraZ);
      camera.lookAt(0, 0, 0);
    }

    loader.load('public/models/Armature.glb', (gltf) => {
      avatar = gltf.scene;
      modelGroup.add(avatar);
      frame(modelGroup);
    }, undefined, (err) => console.error(err));

    function loadExtra(url) {
      loader.load(url, (gltf) => {
        const obj = gltf.scene;
        modelGroup.add(obj);
        extras.set(url, obj);
      }, undefined, (err) => console.error(err));
    }

    function removeExtra(url) {
      const obj = extras.get(url);
      if (obj) {
        modelGroup.remove(obj);
        extras.delete(url);
      }
    }

    document.querySelectorAll('#assetGrid .asset-card').forEach((card) => {
      const url = card.dataset.url;
      card.addEventListener('click', () => {
        card.classList.toggle('selected');
        if (card.classList.contains('selected')) {
          loadExtra(url);
        } else {
          removeExtra(url);
        }
      });
      if (card.classList.contains('selected')) {
        loadExtra(url);
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      modelGroup.rotation.y += 0.005;
      renderer.render(scene, camera);
    }
    animate();

    document.getElementById('colorInput').addEventListener('input', (e) => {
      if (!avatar) return;
      avatar.traverse((child) => {
        if (child.isMesh && child.material && child.material.color) {
          child.material.color.set(e.target.value);
        }
      });
    });

    window.addEventListener('resize', () => {
      const { clientWidth, clientHeight } = viewer;
      renderer.setSize(clientWidth, clientHeight);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
