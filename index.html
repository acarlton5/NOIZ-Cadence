<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cadence 2D â€“ Layered Prototype</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>
<style>
  :root{
    --bg-1:#0f0a2b;
    --bg-2:#24105b;
    --panel:#130a38;
    --panel-soft:rgba(255,255,255,.06);
    --text:#e9e6ff;
    --text-dim:#c8c4ff;
    --accent:#7a5cff;
    --tile-outline:#8de0ff;
    --card:#ffffff;
    --card-text:#1d124b;
  }

  html, body { height:100%; }
  body{
    background: radial-gradient(1600px 900px at 72% 18%, var(--bg-2) 0%, var(--bg-1) 60%, #07051a 100%);
    color:var(--text);
    overflow:hidden;
    font-weight:500;
  }

  .app{
    height:100vh;
    display:grid;
    grid-template-columns: 72px minmax(520px, 45%) 1fr;
    gap:18px;
    padding:20px;
  }

  .slotbar{
    background:var(--panel-soft);
    border-radius:18px;
    padding:10px 8px;
    display:flex; flex-direction:column; align-items:center; gap:10px;
  }
  .slotbtn{
    width:46px; height:46px; border-radius:12px;
    display:grid; place-items:center;
    color:var(--text-dim); background:transparent; border:none; transition:.15s;
  }
  .slotbtn.active,.slotbtn:hover{ color:#fff; background:rgba(122,92,255,.18); }
  .slotdivider{height:1px;width:72%;background:rgba(255,255,255,.12);margin:6px 0;}

  .catalog{
    background:var(--panel-soft);
    border-radius:18px; padding:18px; height:100%; overflow:auto;
    display:flex; flex-direction:column;
  }
  .tabs-above{
    display:flex; gap:22px; margin-bottom:8px;
  }
  .tabs-above button{
    background:transparent; border:0; color:var(--text-dim);
    text-transform:uppercase; font-weight:800; letter-spacing:.04em;
    padding:0;
  }
  .tabs-above button.active{ color:#fff; }
  .tabs-above button.active::after{
    content:""; display:block; height:2px; background:#fff; margin-top:6px; border-radius:2px;
  }

  .panel-title{font-weight:900; letter-spacing:.04em;}
  .catalog-sub{ color:var(--text-dim); }

  .searchbox .form-control{
    background:transparent; color:#fff;
    border-color:rgba(255,255,255,.28);
  }
  .searchbox .form-control::placeholder{ color:#d7d4ff; opacity:.7; }

  .catalog-grid{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:12px;
    flex:1 1 auto;
  }
  @media (min-width: 576px){ .catalog-grid{ grid-template-columns: repeat(3, 1fr);} }

  .tile{
    background:var(--card); color:var(--card-text);
    border-radius:14px; padding:12px;
    box-shadow: 0 2px 10px rgba(0,0,0,.18);
    cursor:pointer; transition:transform .12s, box-shadow .12s, outline .12s;
    outline:2px solid transparent; position:relative;
  }
  .tile:hover{ transform:translateY(-2px); box-shadow:0 12px 28px rgba(0,0,0,.25); }
  .tile.selected{ outline-color: var(--tile-outline); outline-offset: -2px; }
  .tile .thumb{
    height:96px; border-radius:10px;
    background:linear-gradient(145deg,#eef6ff 0%,#e9e6ff 100%);
    display:grid; place-items:center; font-size:34px; color:var(--accent);
    margin-bottom:8px;
  }
  .tile small{ opacity:.7; text-transform:uppercase; letter-spacing:.08em; }
  .tile.equipped::after{
    content:"Equipped";
    position:absolute; top:10px; right:12px;
    background:var(--accent); color:#fff;
    border-radius:999px; padding:2px 8px;
    font-size:10px; font-weight:700; letter-spacing:.08em;
  }

  .variant-bar{
    margin-top:16px;
    background:rgba(255,255,255,.05);
    border-radius:14px; padding:14px;
    flex-shrink:0;
  }
  .variant-bar h6{ font-size:13px; text-transform:uppercase; letter-spacing:.08em; color:var(--text-dim); }

  .variant-pill{
    border:1px solid rgba(255,255,255,.25);
    color:#fff; border-radius:999px; padding:4px 12px;
    background:transparent; font-size:12px; font-weight:600;
    cursor:pointer;
  }
  .variant-pill.active{ background:var(--accent); border-color:var(--accent); }
  .variant-pill:focus{ outline:none; }

  .preview{
    background:var(--panel-soft);
    border-radius:18px; padding:18px; height:100%;
    display:flex; flex-direction:column;
  }
  .stage{
    flex:1; background:var(--panel);
    border-radius:18px; overflow:hidden;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  }

  .btn-discard{ background: transparent; border: 1px solid rgba(255,255,255,.25); color: var(--text); }
  .btn-save{ background: var(--accent); border: none; color:#fff; }
</style>
</head>
<body>
<div class="app">
  <aside class="slotbar">
    <button class="slotbtn active" data-bs-toggle="tooltip" data-bs-placement="right" title="Outfits">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M9 7h6l2 3v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V10l2-3z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Tops">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M7 6l5-3 5 3v12a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V6z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Bottoms">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M8 4h8l-1 8h-2l-1 6h-2l-1-6H9L8 4z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Shoes">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M3 15h11l7 3v2H3v-5z"/></svg>
    </button>
    <div class="slotdivider"></div>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Accessories">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="7" r="3"/><path d="M5 22a7 7 0 0 1 14 0"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Props">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3 7h7l-5.5 4 2 7-6.5-4.5L5 20l2-7L2 9h7z"/></svg>
    </button>
  </aside>

  <main class="catalog">
    <div class="tabs-above">
      <button id="tabAppearance" class="active">APPEARANCE</button>
      <button id="tabOutfit">OUTFIT</button>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-2">
      <div>
        <div id="panelTitle" class="panel-title">APPEARANCE</div>
        <div id="panelSub" class="small catalog-sub">Customize your body, skin, hair, and face.</div>
      </div>
      <div class="input-group input-group-sm searchbox" style="max-width: 260px;">
        <span class="input-group-text bg-transparent text-light border-secondary">ðŸ”Ž</span>
        <input id="search" class="form-control" placeholder="Search itemsâ€¦">
      </div>
    </div>

    <div id="grid" class="catalog-grid"></div>
    <div id="variantBar" class="variant-bar d-none"></div>
  </main>

  <section class="preview">
    <div class="d-flex justify-content-between align-items-center mb-2">
      <div>
        <div class="panel-title">Preview</div>
        <div class="small catalog-sub">PixiJS layered composite</div>
      </div>
      <div class="d-flex gap-2">
        <button id="discardBtn" class="btn btn-sm btn-discard" disabled>DISCARD CHANGES</button>
        <button id="saveBtn" class="btn btn-sm btn-save" disabled>SAVE AND CLOSE</button>
      </div>
    </div>
    <div id="stage" class="stage"></div>
  </section>
</div>

<div class="modal fade" id="conflictModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content bg-dark text-light">
      <div class="modal-header border-0">
        <h5 class="modal-title">Item blocked</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-2">Due to brand or safety conflicts, you need to resolve the following before equipping:</p>
        <ul id="conflictList" class="ps-3 mb-0"></ul>
      </div>
      <div class="modal-footer border-0">
        <button id="conflictCancel" type="button" class="btn btn-outline-light btn-sm" data-bs-dismiss="modal">Cancel</button>
        <button id="conflictReplace" type="button" class="btn btn-sm btn-save">Replace items</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
(() => {
  'use strict';

  [...document.querySelectorAll('[data-bs-toggle="tooltip"]')].forEach(el => new bootstrap.Tooltip(el, {placement:'right'}));

  const messageTarget = window.parent && window.parent !== window ? window.parent : window;

  const ITEM_SECTIONS = {
    appearance: [
      { id:'skin_tan', name:'Skin â€“ Tan', slot:'skin', icon:'ðŸ§´', manifest:'./assets/items/skin_tan.manifest.json' },
      { id:'skin_dark', name:'Skin â€“ Deep', slot:'skin', icon:'ðŸ§´', manifest:'./assets/items/skin_dark.manifest.json' },
      { id:'hair_wave', name:'Hair â€“ Wave', slot:'hair', icon:'ðŸ’‡', manifest:'./assets/items/hair_wave.manifest.json' },
      { id:'eyes_green', name:'Eyes â€“ Green', slot:'eyes', icon:'ðŸ‘ï¸', manifest:'./assets/items/eyes_green.manifest.json' },
      { id:'mouth_smile', name:'Smile', slot:'mouth', icon:'ðŸ˜„', manifest:'./assets/items/mouth_smile.manifest.json' }
    ],
    outfit: [
      { id:'hoodie_blue', name:'Hoodie â€“ Blue', slot:'torso', icon:'ðŸ§¥', manifest:'./assets/items/hoodie_blue.manifest.json' },
      { id:'jacket_gold', name:'Jacket â€“ Gold', slot:'jacket', icon:'ðŸ¥‡', manifest:'./assets/items/jacket_gold.manifest.json' },
      { id:'hat_beanie', name:'Beanie Hat', slot:'hat', icon:'ðŸ§¢', manifest:'./assets/items/hat_beanie.manifest.json' },
      { id:'vfx_sparkles', name:'Sparkle Overlay', slot:'vfx', icon:'âœ¨', manifest:'./assets/items/vfx_sparkles.manifest.json' }
    ]
  };

  const ITEM_BY_ID = new Map();
  Object.values(ITEM_SECTIONS).forEach(section => section.forEach(item => ITEM_BY_ID.set(item.id, item)));

  const grid = document.getElementById('grid');
  const search = document.getElementById('search');
  const panelTitle = document.getElementById('panelTitle');
  const panelSub = document.getElementById('panelSub');
  const variantBar = document.getElementById('variantBar');
  const saveBtn = document.getElementById('saveBtn');
  const discardBtn = document.getElementById('discardBtn');

  const conflictModalEl = document.getElementById('conflictModal');
  const conflictModal = new bootstrap.Modal(conflictModalEl);
  const conflictList = document.getElementById('conflictList');
  const conflictReplace = document.getElementById('conflictReplace');
  const conflictCancel = document.getElementById('conflictCancel');

  const manifestCache = new Map();
  const USER_ID = 'demo-user';
  const state = { equipped: {} };
  let savedLoadout = {};
  let savedFingerprint = fingerprint({});
  let currentSection = 'appearance';
  let selectedItemId = null;
  let ipMatrix = [];
  let safetyRules = [];
  let renderer;
  let pendingEquip = null;

  function fingerprint(obj) {
    const ordered = Object.keys(obj).sort().reduce((acc, key) => {
      acc[key] = obj[key];
      return acc;
    }, {});
    return JSON.stringify(ordered);
  }

  function normalizeState(st) {
    const normalized = {};
    Object.entries(st.equipped).forEach(([slot, entry]) => {
      if (!entry) return;
      normalized[slot] = {
        itemId: entry.itemId,
        entitlementId: entry.entitlementId,
        variantId: entry.variantId || null
      };
    });
    return normalized;
  }

  function updateDirty() {
    const dirty = fingerprint(normalizeState(state)) !== savedFingerprint;
    saveBtn.disabled = !dirty;
    discardBtn.disabled = !dirty;
    return dirty;
  }

  function render(filter='') {
    const q = (filter || '').toLowerCase();
    const items = ITEM_SECTIONS[currentSection].filter(item => !q || item.name.toLowerCase().includes(q));
    if (!items.length) {
      grid.innerHTML = '<div class="text-center text-secondary py-5">No items match your search.</div>';
      return;
    }
    grid.innerHTML = items.map(item => {
      const equipped = state.equipped[item.slot]?.itemId === item.id;
      const selected = selectedItemId === item.id;
      return `<div class="tile ${selected ? 'selected' : ''} ${equipped ? 'equipped' : ''}" data-id="${item.id}">`
        + `<div class="thumb">${item.icon || 'ðŸŽ´'}</div>`
        + `<div class="fw-semibold">${item.name}</div>`
        + `<small>${item.slot.replace(/_/g,' ')}</small>`
        + `</div>`;
    }).join('');
  }

  function setSection(next) {
    if (currentSection === next) return;
    currentSection = next;
    document.getElementById('tabAppearance').classList.toggle('active', next === 'appearance');
    document.getElementById('tabOutfit').classList.toggle('active', next === 'outfit');
    if (next === 'appearance') {
      panelTitle.textContent = 'APPEARANCE';
      panelSub.textContent = 'Customize your body, skin, hair, and face.';
    } else {
      panelTitle.textContent = 'OUTFIT';
      panelSub.textContent = 'Mix and match clothing, hats, and effects.';
    }
    selectedItemId = null;
    render(search.value);
    showInspector(null);
  }

  async function fetchJSON(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to load ${url}: ${res.status}`);
    return res.json();
  }

  async function getManifest(itemId) {
    if (manifestCache.has(itemId)) return manifestCache.get(itemId);
    const def = ITEM_BY_ID.get(itemId);
    if (!def) throw new Error(`Unknown item ${itemId}`);
    const data = await fetchJSON(def.manifest);
    manifestCache.set(itemId, data);
    return data;
  }
  function createRenderer(layerOrder) {
    const order = layerOrder || {};
    let app;
    let avatarRoot;
    const containers = new Map();
    const slotState = new Map();
    const baseLayers = new Map();

    function parseColor(hex) {
      if (!hex) return 0xffffff;
      const normalized = hex.replace('#', '').trim();
      if (!normalized) return 0xffffff;
      return parseInt(normalized, 16);
    }

    function buildVisual(entry) {
      return {
        image: entry?.image ?? null,
        fill: entry?.fill ?? null,
        alpha: typeof entry?.alpha === 'number' ? entry.alpha : undefined,
        size: entry?.size ?? null
      };
    }

    function mergeVisual(base, override) {
      const baseVisual = buildVisual(base);
      if (!override) {
        return {
          image: baseVisual.image,
          fill: baseVisual.fill,
          alpha: baseVisual.alpha ?? 1,
          size: baseVisual.size
        };
      }
      const overrideVisual = buildVisual(override);
      return {
        image: overrideVisual.image ?? baseVisual.image,
        fill: overrideVisual.fill ?? baseVisual.fill,
        alpha: overrideVisual.alpha ?? baseVisual.alpha ?? 1,
        size: overrideVisual.size ?? baseVisual.size
      };
    }

    function normalizeMount(mount) {
      return {
        anchor: mount?.anchor ?? [0.5, 0.5],
        offset: mount?.offset ?? [0, 0],
        scale: mount?.scale ?? 1,
        renderLayer: mount?.renderLayer ?? null
      };
    }

    function resolveZ(slot, explicit, renderLayer) {
      let base = typeof explicit === 'number' ? explicit : (order[slot] ?? 600);
      if (renderLayer === 'behind') base -= 10;
      if (renderLayer === 'front') base += 10;
      return base;
    }

    function ensureSlot(slot, zHint, renderLayer) {
      if (!containers.has(slot)) {
        const container = new PIXI.Container();
        container.sortableChildren = true;
        container.zIndex = resolveZ(slot, zHint, renderLayer);
        containers.set(slot, container);
        avatarRoot.addChild(container);
      }
      const container = containers.get(slot);
      container.zIndex = resolveZ(slot, zHint, renderLayer);
      return container;
    }

    function applyVisual(container, visual, mount, basePath) {
      container.removeChildren();
      let sprite;
      if (visual.image) {
        const src = visual.image.startsWith('http') || visual.image.startsWith('data:')
          ? visual.image
          : `${basePath}${visual.image}`;
        const texture = PIXI.Texture.from(src);
        sprite = new PIXI.Sprite(texture);
      } else {
        sprite = new PIXI.Sprite(PIXI.Texture.WHITE);
        const size = visual.size ?? [320, 320];
        sprite.width = size[0];
        sprite.height = size[1];
        sprite.tint = parseColor(visual.fill);
        sprite.alpha = visual.alpha ?? 1;
      }
      sprite.anchor.set(mount.anchor[0], mount.anchor[1]);
      sprite.position.set(400 + mount.offset[0], 400 + mount.offset[1]);
      sprite.scale.set(mount.scale);
      container.addChild(sprite);
      return sprite;
    }

    function layout() {
      if (!app || !avatarRoot) return;
      const w = app.renderer.width;
      const h = app.renderer.height;
      const base = 800;
      const scale = Math.min(w, h) / (base * 1.05);
      avatarRoot.scale.set(scale);
      avatarRoot.position.set(w / 2, h * 0.92);
    }

    return {
      initStage(stageEl) {
        app = new PIXI.Application({
          backgroundAlpha: 0,
          resizeTo: stageEl,
          antialias: true,
          powerPreference: 'high-performance'
        });
        stageEl.appendChild(app.view);
        app.stage.sortableChildren = true;
        avatarRoot = new PIXI.Container();
        avatarRoot.sortableChildren = true;
        avatarRoot.pivot.set(400, 400);
        app.stage.addChild(avatarRoot);
        layout();
        window.addEventListener('resize', layout, { passive: true });
      },
      loadBase(baseManifest) {
        baseManifest.layers.forEach(layer => {
          const mount = normalizeMount(layer.mount);
          const visual = mergeVisual(layer, null);
          baseLayers.set(layer.id, { visual, mount, z: layer.z });
          const container = ensureSlot(layer.id, layer.z, mount.renderLayer);
          const sprite = applyVisual(container, visual, mount, './assets/base/');
          slotState.set(layer.id, { sprite, manifest: null, variantId: null, visual, isBase: true });
        });
      },
      applyItem(manifest, options = {}) {
        const mount = normalizeMount(manifest.mount || {});
        const container = ensureSlot(manifest.slot, manifest.z, mount.renderLayer);
        const variantId = options.variantId ?? null;
        const variant = variantId ? manifest.variants?.find(v => v.id === variantId) : null;
        const visual = mergeVisual(manifest, variant);
        const sprite = applyVisual(container, visual, mount, './assets/items/');
        slotState.set(manifest.slot, { sprite, manifest, variantId, visual });
      },
      removeSlot(slot) {
        const container = containers.get(slot);
        if (!container) return;
        container.removeChildren();
        slotState.delete(slot);
        if (baseLayers.has(slot)) {
          const base = baseLayers.get(slot);
          const sprite = applyVisual(container, base.visual, base.mount, './assets/base/');
          slotState.set(slot, { sprite, manifest: null, variantId: null, visual: base.visual, isBase: true });
        }
      },
      setVariant(slot, variantId) {
        const entry = slotState.get(slot);
        if (!entry || !entry.manifest) return;
        const manifest = entry.manifest;
        const variant = manifest.variants?.find(v => v.id === variantId);
        if (!variant) return;
        this.applyItem(manifest, { variantId });
      },
      getSlotState(slot) {
        return slotState.get(slot);
      }
    };
  }

  function checkConflicts(next, state) {
    const blockers = new Set();
    const reasons = new Set();
    const exclusive = new Set(next.locks?.exclusive_with ?? []);
    const nextIp = next.ipTags ?? [];
    const nextConflictIp = new Set(next.conflicts?.ip ?? []);
    const nextSafety = next.conflicts?.safety ?? [];
    const nextTags = next.tags ?? [];

    Object.entries(state.equipped).forEach(([slot, entry]) => {
      if (!entry || slot === next.slot) return;
      const other = entry.manifest;
      if (!other) return;
      if (exclusive.has(other.id) || (other.locks?.exclusive_with ?? []).includes(next.id)) {
        blockers.add(slot);
        reasons.add(`${next.name} cannot be combined with ${other.name}.`);
        return;
      }
      const otherIp = other.ipTags ?? [];
      const otherConflictIp = new Set(other.conflicts?.ip ?? []);
      if (nextConflictIp.size && otherIp.some(tag => nextConflictIp.has(tag))) {
        blockers.add(slot);
        reasons.add(`${next.name} conflicts with ${other.name} because of brand rules.`);
      }
      if (otherConflictIp.size && nextIp.some(tag => otherConflictIp.has(tag))) {
        blockers.add(slot);
        reasons.add(`${next.name} conflicts with ${other.name} because of brand rules.`);
      }
      nextIp.forEach(a => {
        otherIp.forEach(b => {
          const match = ipMatrix.find(rule => (rule.a === a && rule.b === b) || (rule.a === b && rule.b === a));
          if (match) {
            blockers.add(slot);
            reasons.add(match.reason || `${next.name} cannot pair with ${other.name}.`);
          }
        });
      });
      const otherSafety = other.conflicts?.safety ?? [];
      const otherTags = other.tags ?? [];
      safetyRules.forEach(rule => {
        if (nextSafety.includes(rule.tag)) {
          const hit = rule.conflicts_with.some(tag => otherTags.includes(tag) || otherSafety.includes(tag) || (other.ipTags ?? []).includes(tag));
          if (hit) {
            blockers.add(slot);
            reasons.add(rule.message || `${next.name} violates a safety rule with ${other.name}.`);
          }
        }
        if (otherSafety.includes(rule.tag)) {
          const hit = rule.conflicts_with.some(tag => nextTags.includes(tag) || nextSafety.includes(tag) || nextIp.includes(tag));
          if (hit) {
            blockers.add(slot);
            reasons.add(rule.message || `${next.name} violates a safety rule with ${other.name}.`);
          }
        }
      });
    });

    return { ok: reasons.size === 0, reasons: Array.from(reasons), blockers: Array.from(blockers) };
  }

  function showInspector(manifest) {
    if (!manifest) {
      variantBar.classList.add('d-none');
      variantBar.removeAttribute('data-slot');
      variantBar.innerHTML = '';
      return;
    }
    const equippedEntry = state.equipped[manifest.slot];
    const activeVariant = equippedEntry?.variantId || null;
    let html = '<div class="d-flex justify-content-between align-items-center">'
      + `<div><h6 class="mb-1">Slot</h6><div class="fw-semibold text-uppercase">${manifest.slot.replace(/_/g,' ')}</div></div>`
      + `<div class="d-flex gap-2"><button type="button" class="btn btn-sm btn-outline-light" data-action="clear" data-slot="${manifest.slot}">Clear slot</button></div>`
      + '</div>';
    if (manifest.variants && manifest.variants.length) {
      html += '<h6 class="mt-3 mb-2">Variants</h6>';
      html += '<div class="d-flex flex-wrap gap-2">' + manifest.variants.map(variant => {
        const active = activeVariant === variant.id ? ' active' : '';
        const name = variant.name || variant.id;
        return `<button type="button" class="variant-pill${active}" data-action="variant" data-slot="${manifest.slot}" data-variant="${variant.id}">${name}</button>`;
      }).join('') + '</div>';
    }
    variantBar.innerHTML = html;
    variantBar.classList.remove('d-none');
    variantBar.dataset.slot = manifest.slot;
  }

  async function loadProfileEntitlements(userId) {
    try {
      const raw = localStorage.getItem(`cadence-equip-${userId}`);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : {};
    } catch (err) {
      console.warn('Failed to load entitlements', err);
      return {};
    }
  }

  async function saveProfileEntitlements(userId, state) {
    const payload = normalizeState(state);
    try {
      localStorage.setItem(`cadence-equip-${userId}`, JSON.stringify(payload));
    } catch (err) {
      console.warn('Failed to save entitlements', err);
    }
    return payload;
  }
  async function finalizeEquip(manifest, options = {}) {
    const variantId = options.variantId ?? null;
    renderer.applyItem(manifest, { variantId });
    state.equipped[manifest.slot] = {
      itemId: manifest.id,
      entitlementId: manifest.entitlementId,
      manifest,
      variantId
    };
    if (!options.skipRender) {
      render(search.value);
    }
    if (!options.skipDirty) {
      updateDirty();
    }
    if (options.notify !== false) {
      messageTarget.postMessage({ type: 'equipped', slot: manifest.slot, itemId: manifest.id }, '*');
    }
  }

  async function attemptEquip(manifest, options = {}) {
    let variantId = options.variantId ?? null;
    const existing = state.equipped[manifest.slot];
    if (!variantId && existing && existing.itemId === manifest.id) {
      variantId = existing.variantId || null;
    }
    if (!options.skipConflicts) {
      const conflict = checkConflicts(manifest, state);
      if (!conflict.ok) {
        pendingEquip = { manifest, conflict, variantId };
        conflictList.innerHTML = conflict.reasons.map(reason => `<li>${reason}</li>`).join('');
        conflictModal.show();
        messageTarget.postMessage({ type: 'blocked', itemId: manifest.id, reasons: conflict.reasons }, '*');
        return;
      }
    }
    await finalizeEquip(manifest, { variantId, skipRender: options.skipRender, skipDirty: options.skipDirty, notify: options.notify });
  }

  async function applySavedLoadout(loadout) {
    Object.keys(state.equipped).forEach(slot => {
      renderer.removeSlot(slot);
      delete state.equipped[slot];
    });
    const entries = Object.entries(loadout);
    for (const [slot, entry] of entries) {
      if (!entry || !entry.itemId) continue;
      const manifest = await getManifest(entry.itemId);
      await finalizeEquip(manifest, { variantId: entry.variantId || null, skipRender: true, skipDirty: true, notify: false });
    }
    render(search.value);
    showInspector(null);
  }

  grid.addEventListener('click', async (event) => {
    const tile = event.target.closest('.tile');
    if (!tile) return;
    const id = tile.dataset.id;
    const def = ITEM_BY_ID.get(id);
    if (!def) return;
    selectedItemId = id;
    render(search.value);
    const manifest = await getManifest(id);
    showInspector(manifest);
    await attemptEquip(manifest);
  });

  variantBar.addEventListener('click', async (event) => {
    const btn = event.target.closest('[data-action]');
    if (!btn) return;
    const slot = btn.dataset.slot;
    if (!slot) return;
    if (btn.dataset.action === 'clear') {
      renderer.removeSlot(slot);
      delete state.equipped[slot];
      render(search.value);
      showInspector(null);
      updateDirty();
      messageTarget.postMessage({ type: 'equipped', slot, itemId: null }, '*');
      return;
    }
    if (btn.dataset.action === 'variant') {
      const variantId = btn.dataset.variant;
      const entry = state.equipped[slot];
      if (!entry || !entry.manifest) return;
      renderer.setVariant(slot, variantId);
      entry.variantId = variantId;
      render(search.value);
      showInspector(entry.manifest);
      updateDirty();
    }
  });

  conflictReplace.addEventListener('click', async () => {
    if (!pendingEquip) return;
    const { manifest, conflict, variantId } = pendingEquip;
    conflict.blockers.forEach(slot => {
      renderer.removeSlot(slot);
      delete state.equipped[slot];
    });
    conflictModal.hide();
    pendingEquip = null;
    await finalizeEquip(manifest, { variantId });
    showInspector(manifest);
  });

  conflictCancel.addEventListener('click', () => {
    pendingEquip = null;
  });

  document.getElementById('tabAppearance').addEventListener('click', () => setSection('appearance'));
  document.getElementById('tabOutfit').addEventListener('click', () => setSection('outfit'));
  search.addEventListener('input', (event) => render(event.target.value));

  saveBtn.addEventListener('click', async () => {
    const payload = await saveProfileEntitlements(USER_ID, state);
    savedLoadout = payload;
    savedFingerprint = fingerprint(payload);
    updateDirty();
    messageTarget.postMessage({ type: 'save_loadout', equipped: payload }, '*');
  });

  discardBtn.addEventListener('click', async () => {
    await applySavedLoadout(savedLoadout);
    savedFingerprint = fingerprint(savedLoadout);
    updateDirty();
  });

  async function bootstrap() {
    const [layerOrder, baseManifest, matrix, safety, saved] = await Promise.all([
      fetchJSON('./assets/layer_order.json'),
      fetchJSON('./assets/base/base.manifest.json'),
      fetchJSON('./assets/ip_matrix.json'),
      fetchJSON('./assets/safety_rules.json'),
      loadProfileEntitlements(USER_ID)
    ]);
    renderer = createRenderer(layerOrder);
    renderer.initStage(document.getElementById('stage'));
    renderer.loadBase(baseManifest);
    ipMatrix = Array.isArray(matrix) ? matrix : [];
    safetyRules = Array.isArray(safety) ? safety : [];
    savedLoadout = saved;
    savedFingerprint = fingerprint(savedLoadout);
    await applySavedLoadout(savedLoadout);
    render();
    updateDirty();
    messageTarget.postMessage({ type: 'profile_render' }, '*');
  }

  bootstrap().catch(err => {
    console.error('Failed to bootstrap Cadence runtime', err);
  });
})();
</script>
</body>
</html>
