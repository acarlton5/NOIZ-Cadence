<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cadence 2D â€“ Layered Prototype</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7/dist/pixi.min.js"></script>
<script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.min.js"></script>
<style>
  :root{
    --bg-1:#0f0a2b;
    --bg-2:#24105b;
    --panel:#130a38;
    --panel-soft:rgba(255,255,255,.06);
    --text:#e9e6ff;
    --text-dim:#c8c4ff;
    --accent:#7a5cff;
    --tile-outline:#8de0ff;
    --card:#ffffff;
    --card-text:#1d124b;
  }

  html, body { height:100%; }
  body{
    background: radial-gradient(1600px 900px at 72% 18%, var(--bg-2) 0%, var(--bg-1) 60%, #07051a 100%);
    color:var(--text);
    overflow:hidden;
    font-weight:500;
  }

  .app{
    height:100vh;
    display:grid;
    grid-template-columns: 72px minmax(520px, 45%) 1fr;
    gap:18px;
    padding:20px;
  }

  .slotbar{
    background:var(--panel-soft);
    border-radius:18px;
    padding:10px 8px;
    display:flex; flex-direction:column; align-items:center; gap:10px;
  }
  .slotbtn{
    width:46px; height:46px; border-radius:12px;
    display:grid; place-items:center;
    color:var(--text-dim); background:transparent; border:none; transition:.15s;
  }
  .slotbtn.active,.slotbtn:hover{ color:#fff; background:rgba(122,92,255,.18); }
  .slotdivider{height:1px;width:72%;background:rgba(255,255,255,.12);margin:6px 0;}

  .catalog{
    background:var(--panel-soft);
    border-radius:18px; padding:18px; height:100%; overflow:auto;
    display:flex; flex-direction:column;
  }
  .tabs-above{
    display:flex; gap:22px; margin-bottom:8px;
  }
  .tabs-above button{
    background:transparent; border:0; color:var(--text-dim);
    text-transform:uppercase; font-weight:800; letter-spacing:.04em;
    padding:0;
  }
  .tabs-above button.active{ color:#fff; }
  .tabs-above button.active::after{
    content:""; display:block; height:2px; background:#fff; margin-top:6px; border-radius:2px;
  }

  .panel-title{font-weight:900; letter-spacing:.04em;}
  .catalog-sub{ color:var(--text-dim); }

  .searchbox .form-control{
    background:transparent; color:#fff;
    border-color:rgba(255,255,255,.28);
  }
  .searchbox .form-control::placeholder{ color:#d7d4ff; opacity:.7; }

  .catalog-grid{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:12px;
    flex:1 1 auto;
  }
  @media (min-width: 576px){ .catalog-grid{ grid-template-columns: repeat(3, 1fr);} }

  .tile{
    background:var(--card); color:var(--card-text);
    border-radius:14px; padding:12px;
    box-shadow: 0 2px 10px rgba(0,0,0,.18);
    cursor:pointer; transition:transform .12s, box-shadow .12s, outline .12s;
    outline:2px solid transparent; position:relative;
    border:0; width:100%; text-align:left;
    display:block; font:inherit;
  }
  .tile:focus-visible{ outline-color: var(--tile-outline); outline-offset:-2px; }
  .tile:hover{ transform:translateY(-2px); box-shadow:0 12px 28px rgba(0,0,0,.25); }
  .tile.selected{ outline-color: var(--tile-outline); outline-offset: -2px; }
  .tile .thumb{
    height:96px; border-radius:10px;
    background:linear-gradient(145deg,#eef6ff 0%,#e9e6ff 100%);
    display:grid; place-items:center; font-size:34px; color:var(--accent);
    margin-bottom:8px;
  }
  .tile small{ opacity:.7; text-transform:uppercase; letter-spacing:.08em; }
  .tile.equipped::after{
    content:"Equipped";
    position:absolute; top:10px; right:12px;
    background:var(--accent); color:#fff;
    border-radius:999px; padding:2px 8px;
    font-size:10px; font-weight:700; letter-spacing:.08em;
  }

  .variant-bar{
    margin-top:16px;
    background:rgba(255,255,255,.05);
    border-radius:14px; padding:14px;
    flex-shrink:0;
  }
  .variant-bar h6{ font-size:13px; text-transform:uppercase; letter-spacing:.08em; color:var(--text-dim); }

  .variant-pill{
    border:1px solid rgba(255,255,255,.25);
    color:#fff; border-radius:999px; padding:4px 12px;
    background:transparent; font-size:12px; font-weight:600;
    cursor:pointer;
  }
  .variant-pill.active{ background:var(--accent); border-color:var(--accent); }
  .variant-pill:focus{ outline:none; }

  .preview{
    background:var(--panel-soft);
    border-radius:18px; padding:18px; height:100%;
    display:flex; flex-direction:column;
  }
  .stage{
    flex:1; background:var(--panel);
    border-radius:18px; overflow:hidden;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  }

  .btn-discard{ background: transparent; border: 1px solid rgba(255,255,255,.25); color: var(--text); }
  .btn-save{ background: var(--accent); border: none; color:#fff; }
  .model-select{
    min-width: 180px;
    background: rgba(255,255,255,.08);
    border-color: rgba(255,255,255,.2);
    color: var(--text);
  }
  .model-select:focus{ box-shadow: none; border-color: rgba(255,255,255,.45); }
  .model-select option{ color:#1d124b; }
</style>
</head>
<body>
<div class="app">
  <aside class="slotbar">
    <button class="slotbtn active" data-bs-toggle="tooltip" data-bs-placement="right" title="Outfits">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M9 7h6l2 3v7a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V10l2-3z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Tops">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M7 6l5-3 5 3v12a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V6z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Bottoms">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M8 4h8l-1 8h-2l-1 6h-2l-1-6H9L8 4z"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Shoes">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M3 15h11l7 3v2H3v-5z"/></svg>
    </button>
    <div class="slotdivider"></div>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Accessories">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="7" r="3"/><path d="M5 22a7 7 0 0 1 14 0"/></svg>
    </button>
    <button class="slotbtn" data-bs-toggle="tooltip" data-bs-placement="right" title="Props">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3 7h7l-5.5 4 2 7-6.5-4.5L5 20l2-7L2 9h7z"/></svg>
    </button>
  </aside>

  <main class="catalog">
    <div class="tabs-above">
      <button id="tabAppearance" class="active">APPEARANCE</button>
      <button id="tabOutfit">OUTFIT</button>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-2">
      <div>
        <div id="panelTitle" class="panel-title">APPEARANCE</div>
        <div id="panelSub" class="small catalog-sub">Customize your body, skin, hair, and face.</div>
      </div>
      <div class="input-group input-group-sm searchbox" style="max-width: 260px;">
        <span class="input-group-text bg-transparent text-light border-secondary">ðŸ”Ž</span>
        <input id="search" class="form-control" placeholder="Search itemsâ€¦">
      </div>
    </div>

    <div id="grid" class="catalog-grid"></div>
    <div id="variantBar" class="variant-bar d-none"></div>
  </main>

  <section class="preview">
    <div class="d-flex justify-content-between align-items-center mb-2">
      <div>
        <div class="panel-title">Preview</div>
        <div class="small catalog-sub">Live2D model composite</div>
      </div>
      <div class="d-flex align-items-center gap-2">
        <select id="modelSelect" class="form-select form-select-sm model-select"></select>
        <button id="discardBtn" class="btn btn-sm btn-discard" disabled>DISCARD CHANGES</button>
        <button id="saveBtn" class="btn btn-sm btn-save" disabled>SAVE AND CLOSE</button>
      </div>
    </div>
    <div id="stage" class="stage"></div>
  </section>
</div>

<div class="modal fade" id="conflictModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content bg-dark text-light">
      <div class="modal-header border-0">
        <h5 class="modal-title">Item blocked</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-2">Due to brand or safety conflicts, you need to resolve the following before equipping:</p>
        <ul id="conflictList" class="ps-3 mb-0"></ul>
      </div>
      <div class="modal-footer border-0">
        <button id="conflictCancel" type="button" class="btn btn-outline-light btn-sm" data-bs-dismiss="modal">Cancel</button>
        <button id="conflictReplace" type="button" class="btn btn-sm btn-save">Replace items</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
(() => {
  'use strict';

  if (window.bootstrap && typeof bootstrap.Tooltip === 'function') {
    [...document.querySelectorAll('[data-bs-toggle="tooltip"]')]
      .forEach(el => new bootstrap.Tooltip(el, { placement: 'right' }));
  }

  const messageTarget = window.parent && window.parent !== window ? window.parent : window;

  const MODEL_CONFIGS = [
    {
      id: 'redfox',
      name: 'Crimson Kitsune',
      model: './items/RedFox/CrimsonKitsune.model3.json',
      layout: { canvas: 2100, scale: 1.05, anchorY: 0.92, offsetY: -40 },
      defaults: {
        toggles: []
      },
      expressions: [
        { id: 'neutral', name: 'Neutral', icon: 'ðŸ™‚', files: [] },
        { id: 'love', name: 'Love', icon: 'ðŸ’–', files: ['./items/RedFox/Love.exp3.json'] },
        { id: 'mad', name: 'Mad', icon: 'ðŸ˜¡', files: ['./items/RedFox/Mad.exp3.json'] },
        { id: 'confused', name: 'Confused', icon: 'ðŸ˜•', files: ['./items/RedFox/Confused.exp3.json'] },
        { id: 'boring', name: 'Bored', icon: 'ðŸ˜', files: ['./items/RedFox/Boring.exp3.json'] },
        { id: 'surprised', name: 'Surprised', icon: 'ðŸ˜²', files: ['./items/RedFox/Surprised.exp3.json'] },
        { id: 'shocked', name: 'Shocked', icon: 'âš¡', files: ['./items/RedFox/Shocked.exp3.json'] }
      ],
      toggles: [
        { id: 'question', name: 'Question Mark FX', icon: 'â“', files: ['./items/RedFox/Questionmark.exp3.json'] }
      ]
    },
    {
      id: 'blackfox',
      name: 'Shadow Variant',
      model: './items/BlackFox/21-SHADOW VARIANT.model3.json',
      layout: { canvas: 2100, scale: 1.1, anchorY: 0.94, offsetY: -20 },
      defaults: {
        toggles: [
          'sparkleEyes',
          'heartEyes',
          'armStraps',
          'hipChain',
          'necklace',
          'choker',
          'chokerStripes',
          'kitsuneEars',
          'kitsuneEmblem',
          'shadowTailSet',
          'kitsuneTailSet'
        ]
      },
      expressions: [
        { id: 'neutral', name: 'Neutral', icon: 'ðŸ™‚', files: [] },
        { id: 'angry', name: 'Angry', icon: 'ðŸ˜¤', files: ['./items/BlackFox/ANGRY.exp3.json'] },
        { id: 'grin', name: 'Grin', icon: 'ðŸ˜', files: ['./items/BlackFox/GRIN.exp3.json'] },
        { id: 'mischief', name: 'Mischief', icon: 'ðŸ˜', files: ['./items/BlackFox/MISCHIEF.exp3.json'] },
        { id: 'shock', name: 'Shocked', icon: 'ðŸ˜²', files: ['./items/BlackFox/SHOCK.exp3.json'] }
      ],
      toggles: [
        { id: 'sparkleEyes', name: 'Sparkle Eyes', icon: 'âœ¨', files: ['./items/BlackFox/SPARKLE EYES.exp3.json'] },
        { id: 'heartEyes', name: 'Heart Eyes', icon: 'ðŸ’˜', files: ['./items/BlackFox/HEART EYES.exp3.json'] },
        { id: 'armStraps', name: 'Arm Straps', icon: 'ðŸ¦¾', files: ['./items/BlackFox/ARM STRAPS.exp3.json'] },
        { id: 'hipChain', name: 'Hip Chain', icon: 'â›“ï¸', files: ['./items/BlackFox/HIP CHAIN.exp3.json'] },
        { id: 'necklace', name: 'Necklace', icon: 'ðŸ“¿', files: ['./items/BlackFox/NECKLACE.exp3.json'] },
        { id: 'choker', name: 'Choker', icon: 'ðŸŸ£', files: ['./items/BlackFox/CHOKER.exp3.json'] },
        { id: 'chokerStripes', name: 'Choker Stripes', icon: 'ðŸŸª', files: ['./items/BlackFox/CHOKER STRIPES.exp3.json'] },
        { id: 'kitsuneEars', name: 'Kitsune Ears', icon: 'ðŸ¦Š', files: ['./items/BlackFox/KITSUNE EARS.exp3.json'] },
        { id: 'kitsuneEmblem', name: 'Kitsune Emblem', icon: 'ðŸŽ–ï¸', files: ['./items/BlackFox/KITSUNE EMBLEM.exp3.json'] },
        { id: 'shadowTailSet', name: 'Shadow Tail Pack', icon: 'ðŸŒ™', files: [
          './items/BlackFox/SHADOW TAIL L-01.exp3.json',
          './items/BlackFox/SHADOW TAIL L-02.exp3.json',
          './items/BlackFox/SHADOW TAIL L-03.exp3.json',
          './items/BlackFox/SHADOW TAIL R-01.exp3.json',
          './items/BlackFox/SHADOW TAIL R-02.exp3.json',
          './items/BlackFox/SHADOW TAIL R-03.exp3.json'
        ] },
        { id: 'kitsuneTailSet', name: 'Kitsune Tail Pack', icon: 'ðŸª¶', files: [
          './items/BlackFox/KITSUNE TAIL L-01.exp3.json',
          './items/BlackFox/KITSUNE TAIL L-02.exp3.json',
          './items/BlackFox/KITSUNE TAIL L-03.exp3.json',
          './items/BlackFox/KITSUNE TAIL R-01.exp3.json',
          './items/BlackFox/KITSUNE TAIL R-02.exp3.json',
          './items/BlackFox/KITSUNE TAIL R-03.exp3.json'
        ] },
        { id: 'earrings', name: 'Earrings', icon: 'ðŸ’Ž', files: ['./items/BlackFox/EARRING L.exp3.json', './items/BlackFox/EARRING R.exp3.json'] },
        { id: 'customShadow', name: 'Custom Shadow Tails', icon: 'ðŸŒ€', files: ['./items/BlackFox/CUSTOM SHADOW TAILS.exp3.json'] }
      ]
    }
  ];
  const MODEL_BY_ID = new Map(MODEL_CONFIGS.map(config => [config.id, config]));
  const DEFAULT_MODEL_ID = MODEL_CONFIGS[0].id;

  const grid = document.getElementById('grid');
  const search = document.getElementById('search');
  const panelTitle = document.getElementById('panelTitle');
  const panelSub = document.getElementById('panelSub');
  const variantBar = document.getElementById('variantBar');
  const saveBtn = document.getElementById('saveBtn');
  const discardBtn = document.getElementById('discardBtn');
  const modelSelect = document.getElementById('modelSelect');
  const tabAppearance = document.getElementById('tabAppearance');
  const tabOutfit = document.getElementById('tabOutfit');

  const USER_ID = 'demo-user';

  const state = {
    modelId: DEFAULT_MODEL_ID,
    expressionId: 'neutral',
    toggles: new Set()
  };

  let savedState = { modelId: DEFAULT_MODEL_ID, expressionId: 'neutral', toggles: [] };
  let savedFingerprint = fingerprint(savedState);
  let currentSection = 'appearance';
  let selectedItemId = null;

  let app = null;
  let live2dModel = null;
  let currentModelConfig = null;
  let baseParameters = new Map();
  let baseParts = new Map();
  let currentExpressionPackets = [];
  const activeToggleData = new Map();
  const expressionCache = new Map();
  const lockedParameterValues = new Map();
  const lockedPartOpacities = new Map();
  let parameterTicker = null;
  let modelBounds = null;
  let modelLoadToken = 0;

  function fingerprint(obj) {
    return JSON.stringify(obj);
  }

  function normalizeState(target = state) {
    return {
      modelId: target.modelId,
      expressionId: target.expressionId,
      toggles: Array.from(target.toggles).sort()
    };
  }

  function ensureStage() {
    if (app) return;
    const stageEl = document.getElementById('stage');
    app = new PIXI.Application({
      backgroundAlpha: 0,
      resizeTo: stageEl,
      antialias: true,
      powerPreference: 'high-performance'
    });
    stageEl.appendChild(app.view);
    ensureParameterTicker();
    window.addEventListener('resize', () => positionModel(), { passive: true });
  }

  function ensureParameterTicker() {
    if (!app || parameterTicker) return;
    parameterTicker = () => {
      if (!live2dModel || !live2dModel.internalModel) return;
      if (lockedParameterValues.size === 0 && lockedPartOpacities.size === 0) return;
      const core = live2dModel.internalModel.coreModel;
      lockedParameterValues.forEach((value, id) => {
        try {
          core.setParameterValueById(id, value);
        } catch (err) {
          /* ignore */
        }
      });
      if (typeof core.setPartOpacityById === 'function') {
        lockedPartOpacities.forEach((value, id) => {
          try {
            core.setPartOpacityById(id, value);
          } catch (err) {
            /* ignore */
          }
        });
      }
    };
    app.ticker.add(parameterTicker);
  }

  function refreshModelBounds() {
    if (!live2dModel) {
      modelBounds = null;
      return;
    }
    try {
      const bounds = live2dModel.getLocalBounds();
      if (
        bounds &&
        Number.isFinite(bounds.width) && bounds.width > 0 &&
        Number.isFinite(bounds.height) && bounds.height > 0
      ) {
        modelBounds = bounds;
      }
    } catch (err) {
      modelBounds = null;
    }
  }

  function positionModel() {
    if (!app || !live2dModel || !currentModelConfig) return;
    const layout = currentModelConfig.layout || {};
    const canvasInfo = live2dModel.internalModel && live2dModel.internalModel.canvasinfo;
    const fallbackWidth = layout.canvasWidth || layout.canvas || (canvasInfo ? canvasInfo.CanvasWidth : 2000);
    const fallbackHeight = layout.canvasHeight || layout.canvas || (canvasInfo ? canvasInfo.CanvasHeight : fallbackWidth);
    const bounds = modelBounds || (() => {
      try { return live2dModel.getLocalBounds(); } catch (err) { return null; }
    })();
    const contentWidth = bounds && Number.isFinite(bounds.width) && bounds.width > 0 ? bounds.width : fallbackWidth;
    const contentHeight = bounds && Number.isFinite(bounds.height) && bounds.height > 0 ? bounds.height : fallbackHeight;
    const baseScale = layout.scale || 1;
    const anchorX = typeof layout.anchorX === 'number' ? layout.anchorX : 0.5;
    const anchorY = typeof layout.anchorY === 'number' ? layout.anchorY : 0.9;
    const alignX = typeof layout.alignX === 'number' ? layout.alignX : 0.5;
    const marginTop = typeof layout.marginTop === 'number' ? layout.marginTop : 24;
    const marginBottom = typeof layout.marginBottom === 'number' ? layout.marginBottom : 24;
    const marginX = typeof layout.marginX === 'number' ? layout.marginX : 0;
    const offsetX = layout.offsetX || 0;
    const offsetY = layout.offsetY || 0;
    const stageWidth = app.renderer.width;
    const stageHeight = app.renderer.height;
    const usableWidth = Math.max(1, stageWidth - marginX * 2);
    const usableHeight = Math.max(1, stageHeight - marginTop - marginBottom);
    const widthScale = Math.max(0, usableWidth / Math.max(1, contentWidth));
    const heightScale = Math.max(0, usableHeight / Math.max(1, contentHeight));
    const fitScale = Math.min(widthScale, heightScale) || 0;
    let scale = fitScale * baseScale;
    scale = Math.max(0, Math.min(scale, widthScale, heightScale));
    live2dModel.scale.set(scale);
    if (live2dModel.anchor && typeof live2dModel.anchor.set === 'function') {
      live2dModel.anchor.set(0, 0);
    }
    const pivotX = bounds ? bounds.x + contentWidth * anchorX : contentWidth * anchorX;
    const pivotY = bounds ? bounds.y + contentHeight * anchorY : contentHeight * anchorY;
    if (live2dModel.pivot && typeof live2dModel.pivot.set === 'function') {
      live2dModel.pivot.set(pivotX, pivotY);
    }
    const areaRight = stageWidth - marginX;
    const areaBottom = stageHeight - marginBottom;
    const areaLeft = marginX;
    const areaTop = marginTop;
    const bottomSpan = bounds ? bounds.y + contentHeight - pivotY : contentHeight * (1 - anchorY);
    const initialX = areaLeft + usableWidth * alignX + offsetX;
    let x = initialX;
    let y = areaBottom - bottomSpan * scale + offsetY;
    live2dModel.position.set(x, y);
    for (let i = 0; i < 2; i++) {
      const currentBounds = live2dModel.getBounds();
      let dx = 0;
      let dy = 0;
      if (currentBounds.left < areaLeft) {
        dx += areaLeft - currentBounds.left;
      }
      if (currentBounds.right > areaRight) {
        dx -= currentBounds.right - areaRight;
      }
      if (currentBounds.top < areaTop) {
        dy += areaTop - currentBounds.top;
      }
      if (currentBounds.bottom > areaBottom) {
        dy -= currentBounds.bottom - areaBottom;
      }
      if (dx === 0 && dy === 0) break;
      x += dx;
      y += dy;
      live2dModel.position.set(x, y);
    }
  }

  function captureBaseParameters() {
    if (!live2dModel || !live2dModel.internalModel) return;
    const internal = live2dModel.internalModel;
    const core = internal.coreModel;
    baseParameters = new Map();
    baseParts = new Map();
    const parameterIds = typeof core.getParameterIds === 'function' ? core.getParameterIds() : [];
    parameterIds.forEach(id => {
      try {
        baseParameters.set(id, core.getParameterValueById(id));
      } catch (err) {
        baseParameters.set(id, 0);
      }
    });
    if (typeof core.getPartIds === 'function' && typeof core.getPartOpacityById === 'function') {
      try {
        const partIds = core.getPartIds();
        partIds.forEach(id => {
          try {
            baseParts.set(id, core.getPartOpacityById(id));
          } catch (err) {
            baseParts.set(id, 1);
          }
        });
      } catch (err) {
        baseParts = new Map();
      }
    }
    if (typeof internal.saveParameters === 'function') {
      try {
        internal.saveParameters();
      } catch (err) {
        console.warn('Failed to snapshot Live2D parameters', err);
      }
    }
  }

  function accumulatePackets(packets, parameterMap, partMap) {
    packets.forEach(packet => {
      if (packet && Array.isArray(packet.Parameters)) {
        packet.Parameters.forEach(param => {
          const id = param.Id;
          if (!id || typeof param.Value !== 'number') return;
          const blend = typeof param.Blend === 'string' ? param.Blend : 'Add';
          if (!parameterMap.has(id)) {
            parameterMap.set(id, []);
          }
          parameterMap.get(id).push({
            blend: blend === 'Multiply' || blend === 'Overwrite' ? blend : 'Add',
            value: param.Value
          });
        });
      }
      if (packet && Array.isArray(packet.Parts)) {
        packet.Parts.forEach(part => {
          const id = part.Id;
          if (!id || typeof part.Opacity !== 'number') return;
          const blend = typeof part.Blend === 'string' ? part.Blend : 'Overwrite';
          if (!partMap.has(id)) {
            partMap.set(id, []);
          }
          partMap.get(id).push({
            blend: blend === 'Add' || blend === 'Multiply' || blend === 'Overwrite' ? blend : 'Overwrite',
            value: part.Opacity
          });
        });
      }
    });
  }

  function applyParameterState() {
    if (!live2dModel || !live2dModel.internalModel) return;
    const internal = live2dModel.internalModel;
    const core = internal.coreModel;
    if (typeof internal.loadParameters === 'function') {
      try {
        internal.loadParameters();
      } catch (err) {
        console.warn('Failed to restore Live2D parameters', err);
      }
    }
    baseParameters.forEach((value, id) => {
      try {
        core.setParameterValueById(id, value);
      } catch (err) {
        /* ignore */
      }
    });
    if (typeof core.setPartOpacityById === 'function') {
      baseParts.forEach((value, id) => {
        try {
          core.setPartOpacityById(id, value);
        } catch (err) {
          /* ignore */
        }
      });
    }

    lockedParameterValues.clear();
    lockedPartOpacities.clear();

    const expressionParameterOps = new Map();
    const expressionPartOps = new Map();
    const toggleParameterOps = new Map();
    const togglePartOps = new Map();

    accumulatePackets(currentExpressionPackets, expressionParameterOps, expressionPartOps);
    state.toggles.forEach(id => {
      const packets = activeToggleData.get(id);
      if (packets) {
        accumulatePackets(packets, toggleParameterOps, togglePartOps);
      }
    });

    const parameterIds = new Set([
      ...expressionParameterOps.keys(),
      ...toggleParameterOps.keys()
    ]);

    parameterIds.forEach(id => {
      const baseValue = baseParameters.has(id) ? baseParameters.get(id) : safeGetParameterValue(core, id);
      let expressionValue = baseValue;
      if (expressionParameterOps.has(id)) {
        expressionValue = clampParameterValue(id, applyOperations(baseValue, expressionParameterOps.get(id)), core);
      }
      let value = expressionValue;
      if (toggleParameterOps.has(id)) {
        value = clampParameterValue(id, applyOperations(expressionValue, toggleParameterOps.get(id)), core);
      }
      try {
        core.setParameterValueById(id, value);
        lockedParameterValues.set(id, value);
      } catch (err) {
        /* ignore */
      }
    });

    if (typeof core.setPartOpacityById === 'function') {
      const partIds = new Set([
        ...expressionPartOps.keys(),
        ...togglePartOps.keys()
      ]);
      partIds.forEach(id => {
        const baseValue = baseParts.has(id) ? baseParts.get(id) : safeGetPartOpacity(core, id);
        let expressionValue = baseValue;
        if (expressionPartOps.has(id)) {
          expressionValue = clampOpacity(applyOperations(baseValue, expressionPartOps.get(id)));
        }
        let value = expressionValue;
        if (togglePartOps.has(id)) {
          value = clampOpacity(applyOperations(expressionValue, togglePartOps.get(id)));
        }
        try {
          core.setPartOpacityById(id, value);
          lockedPartOpacities.set(id, value);
        } catch (err) {
          /* ignore */
        }
      });
    }

    refreshModelBounds();
    positionModel();
  }

  function applyOperations(baseValue, operations) {
    return operations.reduce((current, op) => {
      if (op.blend === 'Multiply') {
        return current * op.value;
      }
      if (op.blend === 'Overwrite') {
        return op.value;
      }
      return current + op.value;
    }, baseValue);
  }

  function safeGetParameterValue(core, id) {
    try {
      return core.getParameterValueById(id);
    } catch (err) {
      return 0;
    }
  }

  function safeGetPartOpacity(core, id) {
    try {
      return typeof core.getPartOpacityById === 'function' ? core.getPartOpacityById(id) : 1;
    } catch (err) {
      return 1;
    }
  }

  function clampParameterValue(id, value, core) {
    try {
      const min = typeof core.getParameterMinimumValueById === 'function'
        ? core.getParameterMinimumValueById(id)
        : Number.NEGATIVE_INFINITY;
      const max = typeof core.getParameterMaximumValueById === 'function'
        ? core.getParameterMaximumValueById(id)
        : Number.POSITIVE_INFINITY;
      if (Number.isFinite(min) && value < min) return min;
      if (Number.isFinite(max) && value > max) return max;
      return value;
    } catch (err) {
      return value;
    }
  }

  function clampOpacity(value) {
    return Math.max(0, Math.min(1, value));
  }

  async function fetchJSON(url) {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(`Failed to load ${url}: ${res.status}`);
    }
    return res.json();
  }

  async function loadExpressionSource(src) {
    if (!src) return null;
    if (expressionCache.has(src)) return expressionCache.get(src);
    const data = await fetchJSON(src);
    expressionCache.set(src, data);
    return data;
  }

  async function resolveEntryPackets(entry) {
    if (!entry) return [];
    const sources = Array.isArray(entry.files) ? entry.files : entry.file ? [entry.file] : [];
    const packets = [];
    for (const src of sources) {
      try {
        const data = await loadExpressionSource(src);
        if (data) packets.push(data);
      } catch (err) {
        console.warn(`Failed to load expression ${src}`, err);
      }
    }
    return packets;
  }

  async function setExpressionState(expressionId, options = {}) {
    const {
      skipApply = false,
      skipRender = false,
      skipDirty = false,
      skipSelect = false,
      skipNotify = false
    } = options;
    if (!currentModelConfig) return;
    const entry = currentModelConfig.expressions.find(item => item.id === expressionId)
      || currentModelConfig.expressions.find(item => item.id === 'neutral')
      || currentModelConfig.expressions[0];
    const packets = await resolveEntryPackets(entry);
    currentExpressionPackets = packets;
    state.expressionId = entry.id;
    if (!skipSelect) {
      selectedItemId = entry.id;
    }
    if (!skipApply) {
      applyParameterState();
    }
    if (!skipRender) {
      render(search.value);
    }
    if (!skipDirty) {
      updateDirty();
    }
    if (!skipNotify) {
      messageTarget.postMessage({ type: 'expression_changed', modelId: state.modelId, expressionId: state.expressionId }, '*');
    }
  }

  async function setToggleState(toggleId, enabled, options = {}) {
    const {
      skipApply = false,
      skipRender = false,
      skipInspector = false,
      skipDirty = false,
      skipSelect = false,
      skipNotify = false
    } = options;
    if (!currentModelConfig) return;
    const entry = currentModelConfig.toggles.find(item => item.id === toggleId);
    if (!entry) return;
    const isActive = state.toggles.has(toggleId);
    if (enabled === isActive) return;
    if (enabled) {
      const packets = await resolveEntryPackets(entry);
      activeToggleData.set(toggleId, packets);
      state.toggles.add(toggleId);
    } else {
      state.toggles.delete(toggleId);
      activeToggleData.delete(toggleId);
    }
    if (!skipSelect) {
      selectedItemId = enabled ? toggleId : null;
    }
    if (!skipApply) {
      applyParameterState();
    }
    if (!skipRender) {
      render(search.value);
    }
    if (!skipInspector) {
      updateInspector();
    }
    if (!skipDirty) {
      updateDirty();
    }
    if (!skipNotify) {
      messageTarget.postMessage({ type: 'toggle_changed', modelId: state.modelId, toggleId, enabled }, '*');
    }
  }

  function render(filter = '') {
    const config = currentModelConfig;
    if (!config) {
      grid.innerHTML = '<div class="text-center text-secondary py-5">Loading modelâ€¦</div>';
      return;
    }
    const source = currentSection === 'appearance' ? config.expressions : config.toggles;
    const q = (filter || '').toLowerCase();
    const items = source.filter(item => !q || item.name.toLowerCase().includes(q));
    if (!items.length) {
      const emptyText = currentSection === 'appearance'
        ? 'No expressions match your search.'
        : config.toggles.length
          ? 'No attachments match your search.'
          : 'This model does not expose modular attachments.';
      grid.innerHTML = `<div class="text-center text-secondary py-5">${emptyText}</div>`;
      return;
    }
    grid.innerHTML = items.map(item => {
      const isExpression = currentSection === 'appearance';
      const isActive = isExpression ? state.expressionId === item.id : state.toggles.has(item.id);
      const isSelected = selectedItemId === item.id || isActive;
      const showEquipped = !isExpression && isActive;
      const classes = [
        'tile',
        isSelected ? 'selected' : '',
        showEquipped ? 'equipped' : ''
      ].filter(Boolean).join(' ');
      const kind = isExpression ? 'expression' : 'attachment';
      const icon = item.icon || 'ðŸŽ´';
      const equippedLabel = isActive ? 'true' : 'false';
      return `<button type="button" class="${classes}" data-id="${item.id}" data-type="${kind}" data-equipped="${equippedLabel}" aria-pressed="${equippedLabel}">`
        + `<div class="thumb">${icon}</div>`
        + `<div class="fw-semibold">${item.name}</div>`
        + `<small>${kind}</small>`
        + `</button>`;
    }).join('');
  }

  function updateInspector() {
    const config = currentModelConfig;
    if (!config || state.toggles.size === 0) {
      variantBar.classList.add('d-none');
      variantBar.innerHTML = '';
      return;
    }
    const chips = Array.from(state.toggles).map(id => {
      const def = config.toggles.find(item => item.id === id);
      const name = def ? def.name : id;
      return `<span class="badge bg-light text-dark">${name}</span>`;
    }).join(' ');
    variantBar.innerHTML = `
      <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
          <h6 class="mb-1 text-uppercase">Attachments</h6>
          <div class="fw-semibold">${config.name}</div>
        </div>
        <button type="button" class="btn btn-sm btn-outline-light" data-action="clearAttachments">Clear all</button>
      </div>
      <div class="d-flex flex-wrap gap-2">${chips}</div>
    `;
    variantBar.classList.remove('d-none');
  }

  function updateSectionCopy() {
    const config = currentModelConfig;
    if (currentSection === 'appearance') {
      panelTitle.textContent = 'APPEARANCE';
      panelSub.textContent = config ? `Swap facial expressions for ${config.name}.` : 'Swap facial expressions.';
    } else {
      panelTitle.textContent = 'OUTFIT';
      if (config && config.toggles.length) {
        panelSub.textContent = `Toggle accessories and FX for ${config.name}.`;
      } else {
        panelSub.textContent = config ? `${config.name} has no modular attachments.` : 'Toggle accessories.';
      }
    }
  }

  function updateDirty() {
    const dirty = fingerprint(normalizeState()) !== savedFingerprint;
    saveBtn.disabled = !dirty;
    discardBtn.disabled = !dirty;
    return dirty;
  }

  async function loadProfileState(userId) {
    try {
      const raw = localStorage.getItem(`cadence-live2d-${userId}`);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object' ? parsed : null;
    } catch (err) {
      console.warn('Failed to load profile state', err);
      return null;
    }
  }

  async function saveProfileState(userId, payload) {
    try {
      localStorage.setItem(`cadence-live2d-${userId}`, JSON.stringify(payload));
    } catch (err) {
      console.warn('Failed to save profile state', err);
    }
  }

  function sanitizeState(raw) {
    const fallbackModel = raw && typeof raw === 'object' && MODEL_BY_ID.has(raw.modelId) ? raw.modelId : DEFAULT_MODEL_ID;
    const config = MODEL_BY_ID.get(fallbackModel);
    const expressionIds = new Set(config.expressions.map(e => e.id));
    const expressionId = raw && expressionIds.has(raw.expressionId) ? raw.expressionId : 'neutral';
    const validToggleIds = new Set(config.toggles.map(t => t.id));
    let toggles;
    if (raw && Array.isArray(raw.toggles)) {
      toggles = raw.toggles.filter(id => validToggleIds.has(id));
    } else if (raw && raw.toggles === undefined && config.defaults && Array.isArray(config.defaults.toggles)) {
      toggles = config.defaults.toggles.filter(id => validToggleIds.has(id));
    } else if (!raw && config.defaults && Array.isArray(config.defaults.toggles)) {
      toggles = config.defaults.toggles.filter(id => validToggleIds.has(id));
    } else {
      toggles = [];
    }
    const unique = Array.from(new Set(toggles));
    unique.sort();
    return { modelId: fallbackModel, expressionId, toggles: unique };
  }

  async function selectModel(modelId, options = {}) {
    const config = MODEL_BY_ID.get(modelId);
    if (!config) return;
    const { state: desiredState, skipDirty = false, skipNotify = false } = options;
    const token = ++modelLoadToken;
    modelSelect.disabled = true;
    ensureStage();
    grid.innerHTML = '<div class="text-center text-secondary py-5">Loading modelâ€¦</div>';
    try {
      const model = await PIXI.live2d.Live2DModel.from(config.model);
      if (token !== modelLoadToken) {
        model.destroy();
        return;
      }
      model.anchor.set(0.5, 0.5);
      if (live2dModel) {
        app.stage.removeChild(live2dModel);
        live2dModel.destroy();
      }
      live2dModel = model;
      app.stage.addChild(live2dModel);
      currentModelConfig = config;
      baseParameters = new Map();
      baseParts = new Map();
      currentExpressionPackets = [];
      activeToggleData.clear();
      lockedParameterValues.clear();
      lockedPartOpacities.clear();
      state.modelId = modelId;
      state.expressionId = 'neutral';
      state.toggles = new Set();
      selectedItemId = 'neutral';
      captureBaseParameters();
      refreshModelBounds();
      positionModel();
      const targetState = sanitizeState(desiredState ? { ...desiredState, modelId } : { modelId });
      await setExpressionState(targetState.expressionId, { skipApply: true, skipRender: true, skipDirty: true, skipSelect: true, skipNotify: true });
      for (const toggleId of targetState.toggles) {
        await setToggleState(toggleId, true, { skipApply: true, skipRender: true, skipInspector: true, skipDirty: true, skipSelect: true, skipNotify: true });
      }
      applyParameterState();
      selectedItemId = state.expressionId;
      updateSectionCopy();
      render(search.value);
      updateInspector();
      updateModelSelectUI();
      if (!skipDirty) {
        updateDirty();
      }
      if (!skipNotify) {
        messageTarget.postMessage({ type: 'model_changed', modelId: state.modelId }, '*');
      }
    } catch (err) {
      console.error('Failed to load Live2D model', err);
      grid.innerHTML = '<div class="text-danger text-center py-5">Failed to load model.</div>';
    } finally {
      modelSelect.disabled = false;
    }
  }

  async function applySavedState(saved, options = {}) {
    const sanitized = sanitizeState(saved);
    await selectModel(sanitized.modelId, { state: sanitized, skipDirty: true, skipNotify: true });
    if (options.updateSaved !== false) {
      savedState = sanitized;
      savedFingerprint = fingerprint(sanitized);
    }
    updateDirty();
  }

  function renderModelSelect() {
    modelSelect.innerHTML = MODEL_CONFIGS.map(config => `<option value="${config.id}">${config.name}</option>`).join('');
  }

  function updateModelSelectUI() {
    if (modelSelect.value !== state.modelId) {
      modelSelect.value = state.modelId;
    }
  }

  function setSection(next) {
    if (currentSection === next) return;
    currentSection = next;
    tabAppearance.classList.toggle('active', next === 'appearance');
    tabOutfit.classList.toggle('active', next === 'outfit');
    updateSectionCopy();
    render(search.value);
  }

  grid.addEventListener('click', async event => {
    const tile = event.target.closest('.tile');
    if (!tile) return;
    const id = tile.dataset.id;
    const type = tile.dataset.type;
    if (!id || !type) return;
    try {
      if (type === 'expression') {
        const targetId = id === state.expressionId && id !== 'neutral' ? 'neutral' : id;
        await setExpressionState(targetId);
      } else if (type === 'attachment') {
        const enabled = state.toggles.has(id);
        await setToggleState(id, !enabled);
      }
    } catch (err) {
      console.error('Failed to update selection', err);
    }
  });

  variantBar.addEventListener('click', async event => {
    const btn = event.target.closest('[data-action="clearAttachments"]');
    if (!btn) return;
    const active = Array.from(state.toggles);
    if (!active.length) return;
    for (const id of active) {
      await setToggleState(id, false, { skipApply: true, skipRender: true, skipInspector: true, skipDirty: true, skipSelect: true });
    }
    applyParameterState();
    render(search.value);
    updateInspector();
    updateDirty();
  });

  tabAppearance.addEventListener('click', () => setSection('appearance'));
  tabOutfit.addEventListener('click', () => setSection('outfit'));

  search.addEventListener('input', event => {
    render(event.target.value);
  });

  modelSelect.addEventListener('change', async event => {
    const id = event.target.value;
    if (!MODEL_BY_ID.has(id)) return;
    try {
      await selectModel(id);
    } catch (err) {
      console.error('Failed to switch model', err);
    }
  });

  saveBtn.addEventListener('click', async () => {
    const payload = normalizeState();
    await saveProfileState(USER_ID, payload);
    savedState = payload;
    savedFingerprint = fingerprint(payload);
    updateDirty();
    messageTarget.postMessage({ type: 'save_loadout', payload }, '*');
  });

  discardBtn.addEventListener('click', async () => {
    await applySavedState(savedState, { updateSaved: false });
  });

  async function bootstrap() {
    renderModelSelect();
    const saved = await loadProfileState(USER_ID);
    const sanitized = sanitizeState(saved);
    savedState = sanitized;
    savedFingerprint = fingerprint(sanitized);
    await selectModel(sanitized.modelId, { state: sanitized, skipDirty: true, skipNotify: true });
    updateDirty();
    messageTarget.postMessage({ type: 'profile_render' }, '*');
  }

  bootstrap().catch(err => {
    console.error('Failed to bootstrap Live2D wardrobe', err);
  });
})();

</script>
</body>
</html>
